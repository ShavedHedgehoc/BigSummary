
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Batchs
 * 
 */
export type Batchs = $Result.DefaultSelection<Prisma.$BatchsPayload>
/**
 * Model TraceBatches
 * 
 */
export type TraceBatches = $Result.DefaultSelection<Prisma.$TraceBatchesPayload>
/**
 * Model api_errors
 * 
 */
export type api_errors = $Result.DefaultSelection<Prisma.$api_errorsPayload>
/**
 * Model apparatuses
 * 
 */
export type apparatuses = $Result.DefaultSelection<Prisma.$apparatusesPayload>
/**
 * Model bases
 * 
 */
export type bases = $Result.DefaultSelection<Prisma.$basesPayload>
/**
 * Model batchs
 * 
 */
export type batchs = $Result.DefaultSelection<Prisma.$batchsPayload>
/**
 * Model boils
 * 
 */
export type boils = $Result.DefaultSelection<Prisma.$boilsPayload>
/**
 * Model cans
 * 
 */
export type cans = $Result.DefaultSelection<Prisma.$cansPayload>
/**
 * Model conveyors
 * 
 */
export type conveyors = $Result.DefaultSelection<Prisma.$conveyorsPayload>
/**
 * Model dbo_Batchs
 * 
 */
export type dbo_Batchs = $Result.DefaultSelection<Prisma.$dbo_BatchsPayload>
/**
 * Model docs
 * 
 */
export type docs = $Result.DefaultSelection<Prisma.$docsPayload>
/**
 * Model employees
 * 
 */
export type employees = $Result.DefaultSelection<Prisma.$employeesPayload>
/**
 * Model histories
 * 
 */
export type histories = $Result.DefaultSelection<Prisma.$historiesPayload>
/**
 * Model history_types
 * 
 */
export type history_types = $Result.DefaultSelection<Prisma.$history_typesPayload>
/**
 * Model marking_sample
 * 
 */
export type marking_sample = $Result.DefaultSelection<Prisma.$marking_samplePayload>
/**
 * Model notes
 * 
 */
export type notes = $Result.DefaultSelection<Prisma.$notesPayload>
/**
 * Model occupations
 * 
 */
export type occupations = $Result.DefaultSelection<Prisma.$occupationsPayload>
/**
 * Model plants
 * 
 */
export type plants = $Result.DefaultSelection<Prisma.$plantsPayload>
/**
 * Model products
 * 
 */
export type products = $Result.DefaultSelection<Prisma.$productsPayload>
/**
 * Model record_regulations
 * 
 */
export type record_regulations = $Result.DefaultSelection<Prisma.$record_regulationsPayload>
/**
 * Model records
 * 
 */
export type records = $Result.DefaultSelection<Prisma.$recordsPayload>
/**
 * Model regulations
 * 
 */
export type regulations = $Result.DefaultSelection<Prisma.$regulationsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model semi_products
 * 
 */
export type semi_products = $Result.DefaultSelection<Prisma.$semi_productsPayload>
/**
 * Model series
 * 
 */
export type series = $Result.DefaultSelection<Prisma.$seriesPayload>
/**
 * Model signals
 * 
 */
export type signals = $Result.DefaultSelection<Prisma.$signalsPayload>
/**
 * Model tokens
 * 
 */
export type tokens = $Result.DefaultSelection<Prisma.$tokensPayload>
/**
 * Model tube_assembly
 * 
 */
export type tube_assembly = $Result.DefaultSelection<Prisma.$tube_assemblyPayload>
/**
 * Model tube_conveyor_posts
 * 
 */
export type tube_conveyor_posts = $Result.DefaultSelection<Prisma.$tube_conveyor_postsPayload>
/**
 * Model tube_conveyors
 * 
 */
export type tube_conveyors = $Result.DefaultSelection<Prisma.$tube_conveyorsPayload>
/**
 * Model tube_histories
 * 
 */
export type tube_histories = $Result.DefaultSelection<Prisma.$tube_historiesPayload>
/**
 * Model tube_histories_notes
 * 
 */
export type tube_histories_notes = $Result.DefaultSelection<Prisma.$tube_histories_notesPayload>
/**
 * Model tube_history_types
 * 
 */
export type tube_history_types = $Result.DefaultSelection<Prisma.$tube_history_typesPayload>
/**
 * Model tube_materials
 * 
 */
export type tube_materials = $Result.DefaultSelection<Prisma.$tube_materialsPayload>
/**
 * Model tube_parameters
 * 
 */
export type tube_parameters = $Result.DefaultSelection<Prisma.$tube_parametersPayload>
/**
 * Model tube_products
 * 
 */
export type tube_products = $Result.DefaultSelection<Prisma.$tube_productsPayload>
/**
 * Model tube_records
 * 
 */
export type tube_records = $Result.DefaultSelection<Prisma.$tube_recordsPayload>
/**
 * Model tube_sessions
 * 
 */
export type tube_sessions = $Result.DefaultSelection<Prisma.$tube_sessionsPayload>
/**
 * Model tube_specifications
 * 
 */
export type tube_specifications = $Result.DefaultSelection<Prisma.$tube_specificationsPayload>
/**
 * Model user_roles
 * 
 */
export type user_roles = $Result.DefaultSelection<Prisma.$user_rolesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model workshops
 * 
 */
export type workshops = $Result.DefaultSelection<Prisma.$workshopsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Batchs
 * const batchs = await prisma.batchs.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Batchs
   * const batchs = await prisma.batchs.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.batchs`: Exposes CRUD operations for the **Batchs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batchs
    * const batchs = await prisma.batchs.findMany()
    * ```
    */
  get batchs(): Prisma.BatchsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.traceBatches`: Exposes CRUD operations for the **TraceBatches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TraceBatches
    * const traceBatches = await prisma.traceBatches.findMany()
    * ```
    */
  get traceBatches(): Prisma.TraceBatchesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.api_errors`: Exposes CRUD operations for the **api_errors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Api_errors
    * const api_errors = await prisma.api_errors.findMany()
    * ```
    */
  get api_errors(): Prisma.api_errorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apparatuses`: Exposes CRUD operations for the **apparatuses** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apparatuses
    * const apparatuses = await prisma.apparatuses.findMany()
    * ```
    */
  get apparatuses(): Prisma.apparatusesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bases`: Exposes CRUD operations for the **bases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bases
    * const bases = await prisma.bases.findMany()
    * ```
    */
  get bases(): Prisma.basesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.batchs`: Exposes CRUD operations for the **batchs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Batchs
    * const batchs = await prisma.batchs.findMany()
    * ```
    */
  get batchs(): Prisma.batchsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.boils`: Exposes CRUD operations for the **boils** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Boils
    * const boils = await prisma.boils.findMany()
    * ```
    */
  get boils(): Prisma.boilsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cans`: Exposes CRUD operations for the **cans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cans
    * const cans = await prisma.cans.findMany()
    * ```
    */
  get cans(): Prisma.cansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conveyors`: Exposes CRUD operations for the **conveyors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conveyors
    * const conveyors = await prisma.conveyors.findMany()
    * ```
    */
  get conveyors(): Prisma.conveyorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dbo_Batchs`: Exposes CRUD operations for the **dbo_Batchs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dbo_Batchs
    * const dbo_Batchs = await prisma.dbo_Batchs.findMany()
    * ```
    */
  get dbo_Batchs(): Prisma.dbo_BatchsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.docs`: Exposes CRUD operations for the **docs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Docs
    * const docs = await prisma.docs.findMany()
    * ```
    */
  get docs(): Prisma.docsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employees`: Exposes CRUD operations for the **employees** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employees.findMany()
    * ```
    */
  get employees(): Prisma.employeesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.histories`: Exposes CRUD operations for the **histories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Histories
    * const histories = await prisma.histories.findMany()
    * ```
    */
  get histories(): Prisma.historiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.history_types`: Exposes CRUD operations for the **history_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more History_types
    * const history_types = await prisma.history_types.findMany()
    * ```
    */
  get history_types(): Prisma.history_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.marking_sample`: Exposes CRUD operations for the **marking_sample** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Marking_samples
    * const marking_samples = await prisma.marking_sample.findMany()
    * ```
    */
  get marking_sample(): Prisma.marking_sampleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notes`: Exposes CRUD operations for the **notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.notes.findMany()
    * ```
    */
  get notes(): Prisma.notesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.occupations`: Exposes CRUD operations for the **occupations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Occupations
    * const occupations = await prisma.occupations.findMany()
    * ```
    */
  get occupations(): Prisma.occupationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plants`: Exposes CRUD operations for the **plants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plants
    * const plants = await prisma.plants.findMany()
    * ```
    */
  get plants(): Prisma.plantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): Prisma.productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.record_regulations`: Exposes CRUD operations for the **record_regulations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Record_regulations
    * const record_regulations = await prisma.record_regulations.findMany()
    * ```
    */
  get record_regulations(): Prisma.record_regulationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.records`: Exposes CRUD operations for the **records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Records
    * const records = await prisma.records.findMany()
    * ```
    */
  get records(): Prisma.recordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.regulations`: Exposes CRUD operations for the **regulations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regulations
    * const regulations = await prisma.regulations.findMany()
    * ```
    */
  get regulations(): Prisma.regulationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.semi_products`: Exposes CRUD operations for the **semi_products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Semi_products
    * const semi_products = await prisma.semi_products.findMany()
    * ```
    */
  get semi_products(): Prisma.semi_productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.series`: Exposes CRUD operations for the **series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Series
    * const series = await prisma.series.findMany()
    * ```
    */
  get series(): Prisma.seriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.signals`: Exposes CRUD operations for the **signals** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Signals
    * const signals = await prisma.signals.findMany()
    * ```
    */
  get signals(): Prisma.signalsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tokens`: Exposes CRUD operations for the **tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.tokens.findMany()
    * ```
    */
  get tokens(): Prisma.tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_assembly`: Exposes CRUD operations for the **tube_assembly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_assemblies
    * const tube_assemblies = await prisma.tube_assembly.findMany()
    * ```
    */
  get tube_assembly(): Prisma.tube_assemblyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_conveyor_posts`: Exposes CRUD operations for the **tube_conveyor_posts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_conveyor_posts
    * const tube_conveyor_posts = await prisma.tube_conveyor_posts.findMany()
    * ```
    */
  get tube_conveyor_posts(): Prisma.tube_conveyor_postsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_conveyors`: Exposes CRUD operations for the **tube_conveyors** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_conveyors
    * const tube_conveyors = await prisma.tube_conveyors.findMany()
    * ```
    */
  get tube_conveyors(): Prisma.tube_conveyorsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_histories`: Exposes CRUD operations for the **tube_histories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_histories
    * const tube_histories = await prisma.tube_histories.findMany()
    * ```
    */
  get tube_histories(): Prisma.tube_historiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_histories_notes`: Exposes CRUD operations for the **tube_histories_notes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_histories_notes
    * const tube_histories_notes = await prisma.tube_histories_notes.findMany()
    * ```
    */
  get tube_histories_notes(): Prisma.tube_histories_notesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_history_types`: Exposes CRUD operations for the **tube_history_types** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_history_types
    * const tube_history_types = await prisma.tube_history_types.findMany()
    * ```
    */
  get tube_history_types(): Prisma.tube_history_typesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_materials`: Exposes CRUD operations for the **tube_materials** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_materials
    * const tube_materials = await prisma.tube_materials.findMany()
    * ```
    */
  get tube_materials(): Prisma.tube_materialsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_parameters`: Exposes CRUD operations for the **tube_parameters** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_parameters
    * const tube_parameters = await prisma.tube_parameters.findMany()
    * ```
    */
  get tube_parameters(): Prisma.tube_parametersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_products`: Exposes CRUD operations for the **tube_products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_products
    * const tube_products = await prisma.tube_products.findMany()
    * ```
    */
  get tube_products(): Prisma.tube_productsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_records`: Exposes CRUD operations for the **tube_records** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_records
    * const tube_records = await prisma.tube_records.findMany()
    * ```
    */
  get tube_records(): Prisma.tube_recordsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_sessions`: Exposes CRUD operations for the **tube_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_sessions
    * const tube_sessions = await prisma.tube_sessions.findMany()
    * ```
    */
  get tube_sessions(): Prisma.tube_sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tube_specifications`: Exposes CRUD operations for the **tube_specifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tube_specifications
    * const tube_specifications = await prisma.tube_specifications.findMany()
    * ```
    */
  get tube_specifications(): Prisma.tube_specificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user_roles`: Exposes CRUD operations for the **user_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_roles
    * const user_roles = await prisma.user_roles.findMany()
    * ```
    */
  get user_roles(): Prisma.user_rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workshops`: Exposes CRUD operations for the **workshops** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workshops
    * const workshops = await prisma.workshops.findMany()
    * ```
    */
  get workshops(): Prisma.workshopsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Batchs: 'Batchs',
    TraceBatches: 'TraceBatches',
    api_errors: 'api_errors',
    apparatuses: 'apparatuses',
    bases: 'bases',
    batchs: 'batchs',
    boils: 'boils',
    cans: 'cans',
    conveyors: 'conveyors',
    dbo_Batchs: 'dbo_Batchs',
    docs: 'docs',
    employees: 'employees',
    histories: 'histories',
    history_types: 'history_types',
    marking_sample: 'marking_sample',
    notes: 'notes',
    occupations: 'occupations',
    plants: 'plants',
    products: 'products',
    record_regulations: 'record_regulations',
    records: 'records',
    regulations: 'regulations',
    roles: 'roles',
    semi_products: 'semi_products',
    series: 'series',
    signals: 'signals',
    tokens: 'tokens',
    tube_assembly: 'tube_assembly',
    tube_conveyor_posts: 'tube_conveyor_posts',
    tube_conveyors: 'tube_conveyors',
    tube_histories: 'tube_histories',
    tube_histories_notes: 'tube_histories_notes',
    tube_history_types: 'tube_history_types',
    tube_materials: 'tube_materials',
    tube_parameters: 'tube_parameters',
    tube_products: 'tube_products',
    tube_records: 'tube_records',
    tube_sessions: 'tube_sessions',
    tube_specifications: 'tube_specifications',
    user_roles: 'user_roles',
    users: 'users',
    workshops: 'workshops'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "batchs" | "traceBatches" | "api_errors" | "apparatuses" | "bases" | "batchs" | "boils" | "cans" | "conveyors" | "dbo_Batchs" | "docs" | "employees" | "histories" | "history_types" | "marking_sample" | "notes" | "occupations" | "plants" | "products" | "record_regulations" | "records" | "regulations" | "roles" | "semi_products" | "series" | "signals" | "tokens" | "tube_assembly" | "tube_conveyor_posts" | "tube_conveyors" | "tube_histories" | "tube_histories_notes" | "tube_history_types" | "tube_materials" | "tube_parameters" | "tube_products" | "tube_records" | "tube_sessions" | "tube_specifications" | "user_roles" | "users" | "workshops"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Batchs: {
        payload: Prisma.$BatchsPayload<ExtArgs>
        fields: Prisma.BatchsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BatchsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BatchsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>
          }
          findFirst: {
            args: Prisma.BatchsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BatchsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>
          }
          findMany: {
            args: Prisma.BatchsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>[]
          }
          create: {
            args: Prisma.BatchsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>
          }
          createMany: {
            args: Prisma.BatchsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BatchsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>[]
          }
          delete: {
            args: Prisma.BatchsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>
          }
          update: {
            args: Prisma.BatchsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>
          }
          deleteMany: {
            args: Prisma.BatchsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BatchsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BatchsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>[]
          }
          upsert: {
            args: Prisma.BatchsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BatchsPayload>
          }
          aggregate: {
            args: Prisma.BatchsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchs>
          }
          groupBy: {
            args: Prisma.BatchsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchsGroupByOutputType>[]
          }
          count: {
            args: Prisma.BatchsCountArgs<ExtArgs>
            result: $Utils.Optional<BatchsCountAggregateOutputType> | number
          }
        }
      }
      TraceBatches: {
        payload: Prisma.$TraceBatchesPayload<ExtArgs>
        fields: Prisma.TraceBatchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TraceBatchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TraceBatchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>
          }
          findFirst: {
            args: Prisma.TraceBatchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TraceBatchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>
          }
          findMany: {
            args: Prisma.TraceBatchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>[]
          }
          create: {
            args: Prisma.TraceBatchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>
          }
          createMany: {
            args: Prisma.TraceBatchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TraceBatchesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>[]
          }
          delete: {
            args: Prisma.TraceBatchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>
          }
          update: {
            args: Prisma.TraceBatchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>
          }
          deleteMany: {
            args: Prisma.TraceBatchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TraceBatchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TraceBatchesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>[]
          }
          upsert: {
            args: Prisma.TraceBatchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TraceBatchesPayload>
          }
          aggregate: {
            args: Prisma.TraceBatchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTraceBatches>
          }
          groupBy: {
            args: Prisma.TraceBatchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<TraceBatchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.TraceBatchesCountArgs<ExtArgs>
            result: $Utils.Optional<TraceBatchesCountAggregateOutputType> | number
          }
        }
      }
      api_errors: {
        payload: Prisma.$api_errorsPayload<ExtArgs>
        fields: Prisma.api_errorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.api_errorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.api_errorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>
          }
          findFirst: {
            args: Prisma.api_errorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.api_errorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>
          }
          findMany: {
            args: Prisma.api_errorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>[]
          }
          create: {
            args: Prisma.api_errorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>
          }
          createMany: {
            args: Prisma.api_errorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.api_errorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>[]
          }
          delete: {
            args: Prisma.api_errorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>
          }
          update: {
            args: Prisma.api_errorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>
          }
          deleteMany: {
            args: Prisma.api_errorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.api_errorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.api_errorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>[]
          }
          upsert: {
            args: Prisma.api_errorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$api_errorsPayload>
          }
          aggregate: {
            args: Prisma.Api_errorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApi_errors>
          }
          groupBy: {
            args: Prisma.api_errorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Api_errorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.api_errorsCountArgs<ExtArgs>
            result: $Utils.Optional<Api_errorsCountAggregateOutputType> | number
          }
        }
      }
      apparatuses: {
        payload: Prisma.$apparatusesPayload<ExtArgs>
        fields: Prisma.apparatusesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.apparatusesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.apparatusesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>
          }
          findFirst: {
            args: Prisma.apparatusesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.apparatusesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>
          }
          findMany: {
            args: Prisma.apparatusesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>[]
          }
          create: {
            args: Prisma.apparatusesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>
          }
          createMany: {
            args: Prisma.apparatusesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.apparatusesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>[]
          }
          delete: {
            args: Prisma.apparatusesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>
          }
          update: {
            args: Prisma.apparatusesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>
          }
          deleteMany: {
            args: Prisma.apparatusesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.apparatusesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.apparatusesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>[]
          }
          upsert: {
            args: Prisma.apparatusesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$apparatusesPayload>
          }
          aggregate: {
            args: Prisma.ApparatusesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApparatuses>
          }
          groupBy: {
            args: Prisma.apparatusesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApparatusesGroupByOutputType>[]
          }
          count: {
            args: Prisma.apparatusesCountArgs<ExtArgs>
            result: $Utils.Optional<ApparatusesCountAggregateOutputType> | number
          }
        }
      }
      bases: {
        payload: Prisma.$basesPayload<ExtArgs>
        fields: Prisma.basesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.basesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.basesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>
          }
          findFirst: {
            args: Prisma.basesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.basesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>
          }
          findMany: {
            args: Prisma.basesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>[]
          }
          create: {
            args: Prisma.basesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>
          }
          createMany: {
            args: Prisma.basesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.basesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>[]
          }
          delete: {
            args: Prisma.basesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>
          }
          update: {
            args: Prisma.basesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>
          }
          deleteMany: {
            args: Prisma.basesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.basesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.basesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>[]
          }
          upsert: {
            args: Prisma.basesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basesPayload>
          }
          aggregate: {
            args: Prisma.BasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBases>
          }
          groupBy: {
            args: Prisma.basesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.basesCountArgs<ExtArgs>
            result: $Utils.Optional<BasesCountAggregateOutputType> | number
          }
        }
      }
      batchs: {
        payload: Prisma.$batchsPayload<ExtArgs>
        fields: Prisma.batchsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.batchsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.batchsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>
          }
          findFirst: {
            args: Prisma.batchsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.batchsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>
          }
          findMany: {
            args: Prisma.batchsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>[]
          }
          create: {
            args: Prisma.batchsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>
          }
          createMany: {
            args: Prisma.batchsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.batchsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>[]
          }
          delete: {
            args: Prisma.batchsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>
          }
          update: {
            args: Prisma.batchsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>
          }
          deleteMany: {
            args: Prisma.batchsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.batchsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.batchsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>[]
          }
          upsert: {
            args: Prisma.batchsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$batchsPayload>
          }
          aggregate: {
            args: Prisma.BatchsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBatchs>
          }
          groupBy: {
            args: Prisma.batchsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BatchsGroupByOutputType>[]
          }
          count: {
            args: Prisma.batchsCountArgs<ExtArgs>
            result: $Utils.Optional<BatchsCountAggregateOutputType> | number
          }
        }
      }
      boils: {
        payload: Prisma.$boilsPayload<ExtArgs>
        fields: Prisma.boilsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.boilsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.boilsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>
          }
          findFirst: {
            args: Prisma.boilsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.boilsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>
          }
          findMany: {
            args: Prisma.boilsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>[]
          }
          create: {
            args: Prisma.boilsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>
          }
          createMany: {
            args: Prisma.boilsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.boilsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>[]
          }
          delete: {
            args: Prisma.boilsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>
          }
          update: {
            args: Prisma.boilsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>
          }
          deleteMany: {
            args: Prisma.boilsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.boilsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.boilsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>[]
          }
          upsert: {
            args: Prisma.boilsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$boilsPayload>
          }
          aggregate: {
            args: Prisma.BoilsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBoils>
          }
          groupBy: {
            args: Prisma.boilsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BoilsGroupByOutputType>[]
          }
          count: {
            args: Prisma.boilsCountArgs<ExtArgs>
            result: $Utils.Optional<BoilsCountAggregateOutputType> | number
          }
        }
      }
      cans: {
        payload: Prisma.$cansPayload<ExtArgs>
        fields: Prisma.cansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>
          }
          findFirst: {
            args: Prisma.cansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>
          }
          findMany: {
            args: Prisma.cansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>[]
          }
          create: {
            args: Prisma.cansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>
          }
          createMany: {
            args: Prisma.cansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>[]
          }
          delete: {
            args: Prisma.cansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>
          }
          update: {
            args: Prisma.cansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>
          }
          deleteMany: {
            args: Prisma.cansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>[]
          }
          upsert: {
            args: Prisma.cansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cansPayload>
          }
          aggregate: {
            args: Prisma.CansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCans>
          }
          groupBy: {
            args: Prisma.cansGroupByArgs<ExtArgs>
            result: $Utils.Optional<CansGroupByOutputType>[]
          }
          count: {
            args: Prisma.cansCountArgs<ExtArgs>
            result: $Utils.Optional<CansCountAggregateOutputType> | number
          }
        }
      }
      conveyors: {
        payload: Prisma.$conveyorsPayload<ExtArgs>
        fields: Prisma.conveyorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conveyorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conveyorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>
          }
          findFirst: {
            args: Prisma.conveyorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conveyorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>
          }
          findMany: {
            args: Prisma.conveyorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>[]
          }
          create: {
            args: Prisma.conveyorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>
          }
          createMany: {
            args: Prisma.conveyorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conveyorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>[]
          }
          delete: {
            args: Prisma.conveyorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>
          }
          update: {
            args: Prisma.conveyorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>
          }
          deleteMany: {
            args: Prisma.conveyorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conveyorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conveyorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>[]
          }
          upsert: {
            args: Prisma.conveyorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conveyorsPayload>
          }
          aggregate: {
            args: Prisma.ConveyorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConveyors>
          }
          groupBy: {
            args: Prisma.conveyorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConveyorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conveyorsCountArgs<ExtArgs>
            result: $Utils.Optional<ConveyorsCountAggregateOutputType> | number
          }
        }
      }
      dbo_Batchs: {
        payload: Prisma.$dbo_BatchsPayload<ExtArgs>
        fields: Prisma.dbo_BatchsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dbo_BatchsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dbo_BatchsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>
          }
          findFirst: {
            args: Prisma.dbo_BatchsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dbo_BatchsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>
          }
          findMany: {
            args: Prisma.dbo_BatchsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>[]
          }
          create: {
            args: Prisma.dbo_BatchsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>
          }
          createMany: {
            args: Prisma.dbo_BatchsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.dbo_BatchsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>[]
          }
          delete: {
            args: Prisma.dbo_BatchsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>
          }
          update: {
            args: Prisma.dbo_BatchsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>
          }
          deleteMany: {
            args: Prisma.dbo_BatchsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dbo_BatchsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.dbo_BatchsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>[]
          }
          upsert: {
            args: Prisma.dbo_BatchsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dbo_BatchsPayload>
          }
          aggregate: {
            args: Prisma.Dbo_BatchsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDbo_Batchs>
          }
          groupBy: {
            args: Prisma.dbo_BatchsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Dbo_BatchsGroupByOutputType>[]
          }
          count: {
            args: Prisma.dbo_BatchsCountArgs<ExtArgs>
            result: $Utils.Optional<Dbo_BatchsCountAggregateOutputType> | number
          }
        }
      }
      docs: {
        payload: Prisma.$docsPayload<ExtArgs>
        fields: Prisma.docsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.docsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.docsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>
          }
          findFirst: {
            args: Prisma.docsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.docsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>
          }
          findMany: {
            args: Prisma.docsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>[]
          }
          create: {
            args: Prisma.docsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>
          }
          createMany: {
            args: Prisma.docsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.docsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>[]
          }
          delete: {
            args: Prisma.docsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>
          }
          update: {
            args: Prisma.docsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>
          }
          deleteMany: {
            args: Prisma.docsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.docsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.docsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>[]
          }
          upsert: {
            args: Prisma.docsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$docsPayload>
          }
          aggregate: {
            args: Prisma.DocsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocs>
          }
          groupBy: {
            args: Prisma.docsGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocsGroupByOutputType>[]
          }
          count: {
            args: Prisma.docsCountArgs<ExtArgs>
            result: $Utils.Optional<DocsCountAggregateOutputType> | number
          }
        }
      }
      employees: {
        payload: Prisma.$employeesPayload<ExtArgs>
        fields: Prisma.employeesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.employeesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.employeesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          findFirst: {
            args: Prisma.employeesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.employeesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          findMany: {
            args: Prisma.employeesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>[]
          }
          create: {
            args: Prisma.employeesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          createMany: {
            args: Prisma.employeesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.employeesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>[]
          }
          delete: {
            args: Prisma.employeesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          update: {
            args: Prisma.employeesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          deleteMany: {
            args: Prisma.employeesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.employeesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.employeesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>[]
          }
          upsert: {
            args: Prisma.employeesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$employeesPayload>
          }
          aggregate: {
            args: Prisma.EmployeesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployees>
          }
          groupBy: {
            args: Prisma.employeesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeesGroupByOutputType>[]
          }
          count: {
            args: Prisma.employeesCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeesCountAggregateOutputType> | number
          }
        }
      }
      histories: {
        payload: Prisma.$historiesPayload<ExtArgs>
        fields: Prisma.historiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.historiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.historiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>
          }
          findFirst: {
            args: Prisma.historiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.historiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>
          }
          findMany: {
            args: Prisma.historiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>[]
          }
          create: {
            args: Prisma.historiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>
          }
          createMany: {
            args: Prisma.historiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.historiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>[]
          }
          delete: {
            args: Prisma.historiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>
          }
          update: {
            args: Prisma.historiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>
          }
          deleteMany: {
            args: Prisma.historiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.historiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.historiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>[]
          }
          upsert: {
            args: Prisma.historiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$historiesPayload>
          }
          aggregate: {
            args: Prisma.HistoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistories>
          }
          groupBy: {
            args: Prisma.historiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.historiesCountArgs<ExtArgs>
            result: $Utils.Optional<HistoriesCountAggregateOutputType> | number
          }
        }
      }
      history_types: {
        payload: Prisma.$history_typesPayload<ExtArgs>
        fields: Prisma.history_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.history_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.history_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>
          }
          findFirst: {
            args: Prisma.history_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.history_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>
          }
          findMany: {
            args: Prisma.history_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>[]
          }
          create: {
            args: Prisma.history_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>
          }
          createMany: {
            args: Prisma.history_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.history_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>[]
          }
          delete: {
            args: Prisma.history_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>
          }
          update: {
            args: Prisma.history_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>
          }
          deleteMany: {
            args: Prisma.history_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.history_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.history_typesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>[]
          }
          upsert: {
            args: Prisma.history_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$history_typesPayload>
          }
          aggregate: {
            args: Prisma.History_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistory_types>
          }
          groupBy: {
            args: Prisma.history_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<History_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.history_typesCountArgs<ExtArgs>
            result: $Utils.Optional<History_typesCountAggregateOutputType> | number
          }
        }
      }
      marking_sample: {
        payload: Prisma.$marking_samplePayload<ExtArgs>
        fields: Prisma.marking_sampleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.marking_sampleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.marking_sampleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>
          }
          findFirst: {
            args: Prisma.marking_sampleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.marking_sampleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>
          }
          findMany: {
            args: Prisma.marking_sampleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>[]
          }
          create: {
            args: Prisma.marking_sampleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>
          }
          createMany: {
            args: Prisma.marking_sampleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.marking_sampleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>[]
          }
          delete: {
            args: Prisma.marking_sampleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>
          }
          update: {
            args: Prisma.marking_sampleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>
          }
          deleteMany: {
            args: Prisma.marking_sampleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.marking_sampleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.marking_sampleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>[]
          }
          upsert: {
            args: Prisma.marking_sampleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$marking_samplePayload>
          }
          aggregate: {
            args: Prisma.Marking_sampleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMarking_sample>
          }
          groupBy: {
            args: Prisma.marking_sampleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Marking_sampleGroupByOutputType>[]
          }
          count: {
            args: Prisma.marking_sampleCountArgs<ExtArgs>
            result: $Utils.Optional<Marking_sampleCountAggregateOutputType> | number
          }
        }
      }
      notes: {
        payload: Prisma.$notesPayload<ExtArgs>
        fields: Prisma.notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findFirst: {
            args: Prisma.notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          findMany: {
            args: Prisma.notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          create: {
            args: Prisma.notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          createMany: {
            args: Prisma.notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.notesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          delete: {
            args: Prisma.notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          update: {
            args: Prisma.notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          deleteMany: {
            args: Prisma.notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.notesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>[]
          }
          upsert: {
            args: Prisma.notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notesPayload>
          }
          aggregate: {
            args: Prisma.NotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotes>
          }
          groupBy: {
            args: Prisma.notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.notesCountArgs<ExtArgs>
            result: $Utils.Optional<NotesCountAggregateOutputType> | number
          }
        }
      }
      occupations: {
        payload: Prisma.$occupationsPayload<ExtArgs>
        fields: Prisma.occupationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.occupationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.occupationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>
          }
          findFirst: {
            args: Prisma.occupationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.occupationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>
          }
          findMany: {
            args: Prisma.occupationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>[]
          }
          create: {
            args: Prisma.occupationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>
          }
          createMany: {
            args: Prisma.occupationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.occupationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>[]
          }
          delete: {
            args: Prisma.occupationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>
          }
          update: {
            args: Prisma.occupationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>
          }
          deleteMany: {
            args: Prisma.occupationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.occupationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.occupationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>[]
          }
          upsert: {
            args: Prisma.occupationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$occupationsPayload>
          }
          aggregate: {
            args: Prisma.OccupationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOccupations>
          }
          groupBy: {
            args: Prisma.occupationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<OccupationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.occupationsCountArgs<ExtArgs>
            result: $Utils.Optional<OccupationsCountAggregateOutputType> | number
          }
        }
      }
      plants: {
        payload: Prisma.$plantsPayload<ExtArgs>
        fields: Prisma.plantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.plantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.plantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>
          }
          findFirst: {
            args: Prisma.plantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.plantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>
          }
          findMany: {
            args: Prisma.plantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>[]
          }
          create: {
            args: Prisma.plantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>
          }
          createMany: {
            args: Prisma.plantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.plantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>[]
          }
          delete: {
            args: Prisma.plantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>
          }
          update: {
            args: Prisma.plantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>
          }
          deleteMany: {
            args: Prisma.plantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.plantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.plantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>[]
          }
          upsert: {
            args: Prisma.plantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$plantsPayload>
          }
          aggregate: {
            args: Prisma.PlantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlants>
          }
          groupBy: {
            args: Prisma.plantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.plantsCountArgs<ExtArgs>
            result: $Utils.Optional<PlantsCountAggregateOutputType> | number
          }
        }
      }
      products: {
        payload: Prisma.$productsPayload<ExtArgs>
        fields: Prisma.productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findFirst: {
            args: Prisma.productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          findMany: {
            args: Prisma.productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          create: {
            args: Prisma.productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          createMany: {
            args: Prisma.productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.productsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          delete: {
            args: Prisma.productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          update: {
            args: Prisma.productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          deleteMany: {
            args: Prisma.productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.productsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>[]
          }
          upsert: {
            args: Prisma.productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$productsPayload>
          }
          aggregate: {
            args: Prisma.ProductsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProducts>
          }
          groupBy: {
            args: Prisma.productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductsGroupByOutputType>[]
          }
          count: {
            args: Prisma.productsCountArgs<ExtArgs>
            result: $Utils.Optional<ProductsCountAggregateOutputType> | number
          }
        }
      }
      record_regulations: {
        payload: Prisma.$record_regulationsPayload<ExtArgs>
        fields: Prisma.record_regulationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.record_regulationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.record_regulationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>
          }
          findFirst: {
            args: Prisma.record_regulationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.record_regulationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>
          }
          findMany: {
            args: Prisma.record_regulationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>[]
          }
          create: {
            args: Prisma.record_regulationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>
          }
          createMany: {
            args: Prisma.record_regulationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.record_regulationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>[]
          }
          delete: {
            args: Prisma.record_regulationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>
          }
          update: {
            args: Prisma.record_regulationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>
          }
          deleteMany: {
            args: Prisma.record_regulationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.record_regulationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.record_regulationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>[]
          }
          upsert: {
            args: Prisma.record_regulationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$record_regulationsPayload>
          }
          aggregate: {
            args: Prisma.Record_regulationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecord_regulations>
          }
          groupBy: {
            args: Prisma.record_regulationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Record_regulationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.record_regulationsCountArgs<ExtArgs>
            result: $Utils.Optional<Record_regulationsCountAggregateOutputType> | number
          }
        }
      }
      records: {
        payload: Prisma.$recordsPayload<ExtArgs>
        fields: Prisma.recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>
          }
          findFirst: {
            args: Prisma.recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>
          }
          findMany: {
            args: Prisma.recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>[]
          }
          create: {
            args: Prisma.recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>
          }
          createMany: {
            args: Prisma.recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.recordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>[]
          }
          delete: {
            args: Prisma.recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>
          }
          update: {
            args: Prisma.recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>
          }
          deleteMany: {
            args: Prisma.recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.recordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>[]
          }
          upsert: {
            args: Prisma.recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$recordsPayload>
          }
          aggregate: {
            args: Prisma.RecordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRecords>
          }
          groupBy: {
            args: Prisma.recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RecordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.recordsCountArgs<ExtArgs>
            result: $Utils.Optional<RecordsCountAggregateOutputType> | number
          }
        }
      }
      regulations: {
        payload: Prisma.$regulationsPayload<ExtArgs>
        fields: Prisma.regulationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.regulationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.regulationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>
          }
          findFirst: {
            args: Prisma.regulationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.regulationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>
          }
          findMany: {
            args: Prisma.regulationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>[]
          }
          create: {
            args: Prisma.regulationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>
          }
          createMany: {
            args: Prisma.regulationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.regulationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>[]
          }
          delete: {
            args: Prisma.regulationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>
          }
          update: {
            args: Prisma.regulationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>
          }
          deleteMany: {
            args: Prisma.regulationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.regulationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.regulationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>[]
          }
          upsert: {
            args: Prisma.regulationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$regulationsPayload>
          }
          aggregate: {
            args: Prisma.RegulationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegulations>
          }
          groupBy: {
            args: Prisma.regulationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegulationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.regulationsCountArgs<ExtArgs>
            result: $Utils.Optional<RegulationsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      semi_products: {
        payload: Prisma.$semi_productsPayload<ExtArgs>
        fields: Prisma.semi_productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.semi_productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.semi_productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>
          }
          findFirst: {
            args: Prisma.semi_productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.semi_productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>
          }
          findMany: {
            args: Prisma.semi_productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>[]
          }
          create: {
            args: Prisma.semi_productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>
          }
          createMany: {
            args: Prisma.semi_productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.semi_productsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>[]
          }
          delete: {
            args: Prisma.semi_productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>
          }
          update: {
            args: Prisma.semi_productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>
          }
          deleteMany: {
            args: Prisma.semi_productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.semi_productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.semi_productsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>[]
          }
          upsert: {
            args: Prisma.semi_productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$semi_productsPayload>
          }
          aggregate: {
            args: Prisma.Semi_productsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSemi_products>
          }
          groupBy: {
            args: Prisma.semi_productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Semi_productsGroupByOutputType>[]
          }
          count: {
            args: Prisma.semi_productsCountArgs<ExtArgs>
            result: $Utils.Optional<Semi_productsCountAggregateOutputType> | number
          }
        }
      }
      series: {
        payload: Prisma.$seriesPayload<ExtArgs>
        fields: Prisma.seriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.seriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.seriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>
          }
          findFirst: {
            args: Prisma.seriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.seriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>
          }
          findMany: {
            args: Prisma.seriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>[]
          }
          create: {
            args: Prisma.seriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>
          }
          createMany: {
            args: Prisma.seriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.seriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>[]
          }
          delete: {
            args: Prisma.seriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>
          }
          update: {
            args: Prisma.seriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>
          }
          deleteMany: {
            args: Prisma.seriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.seriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.seriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>[]
          }
          upsert: {
            args: Prisma.seriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$seriesPayload>
          }
          aggregate: {
            args: Prisma.SeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeries>
          }
          groupBy: {
            args: Prisma.seriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.seriesCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesCountAggregateOutputType> | number
          }
        }
      }
      signals: {
        payload: Prisma.$signalsPayload<ExtArgs>
        fields: Prisma.signalsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.signalsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.signalsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          findFirst: {
            args: Prisma.signalsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.signalsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          findMany: {
            args: Prisma.signalsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>[]
          }
          create: {
            args: Prisma.signalsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          createMany: {
            args: Prisma.signalsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.signalsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>[]
          }
          delete: {
            args: Prisma.signalsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          update: {
            args: Prisma.signalsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          deleteMany: {
            args: Prisma.signalsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.signalsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.signalsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>[]
          }
          upsert: {
            args: Prisma.signalsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$signalsPayload>
          }
          aggregate: {
            args: Prisma.SignalsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSignals>
          }
          groupBy: {
            args: Prisma.signalsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SignalsGroupByOutputType>[]
          }
          count: {
            args: Prisma.signalsCountArgs<ExtArgs>
            result: $Utils.Optional<SignalsCountAggregateOutputType> | number
          }
        }
      }
      tokens: {
        payload: Prisma.$tokensPayload<ExtArgs>
        fields: Prisma.tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          findFirst: {
            args: Prisma.tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          findMany: {
            args: Prisma.tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          create: {
            args: Prisma.tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          createMany: {
            args: Prisma.tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          delete: {
            args: Prisma.tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          update: {
            args: Prisma.tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          deleteMany: {
            args: Prisma.tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>[]
          }
          upsert: {
            args: Prisma.tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tokensPayload>
          }
          aggregate: {
            args: Prisma.TokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokens>
          }
          groupBy: {
            args: Prisma.tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.tokensCountArgs<ExtArgs>
            result: $Utils.Optional<TokensCountAggregateOutputType> | number
          }
        }
      }
      tube_assembly: {
        payload: Prisma.$tube_assemblyPayload<ExtArgs>
        fields: Prisma.tube_assemblyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_assemblyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_assemblyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>
          }
          findFirst: {
            args: Prisma.tube_assemblyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_assemblyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>
          }
          findMany: {
            args: Prisma.tube_assemblyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>[]
          }
          create: {
            args: Prisma.tube_assemblyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>
          }
          createMany: {
            args: Prisma.tube_assemblyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_assemblyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>[]
          }
          delete: {
            args: Prisma.tube_assemblyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>
          }
          update: {
            args: Prisma.tube_assemblyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>
          }
          deleteMany: {
            args: Prisma.tube_assemblyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_assemblyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_assemblyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>[]
          }
          upsert: {
            args: Prisma.tube_assemblyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_assemblyPayload>
          }
          aggregate: {
            args: Prisma.Tube_assemblyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_assembly>
          }
          groupBy: {
            args: Prisma.tube_assemblyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_assemblyGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_assemblyCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_assemblyCountAggregateOutputType> | number
          }
        }
      }
      tube_conveyor_posts: {
        payload: Prisma.$tube_conveyor_postsPayload<ExtArgs>
        fields: Prisma.tube_conveyor_postsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_conveyor_postsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_conveyor_postsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>
          }
          findFirst: {
            args: Prisma.tube_conveyor_postsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_conveyor_postsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>
          }
          findMany: {
            args: Prisma.tube_conveyor_postsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>[]
          }
          create: {
            args: Prisma.tube_conveyor_postsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>
          }
          createMany: {
            args: Prisma.tube_conveyor_postsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_conveyor_postsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>[]
          }
          delete: {
            args: Prisma.tube_conveyor_postsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>
          }
          update: {
            args: Prisma.tube_conveyor_postsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>
          }
          deleteMany: {
            args: Prisma.tube_conveyor_postsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_conveyor_postsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_conveyor_postsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>[]
          }
          upsert: {
            args: Prisma.tube_conveyor_postsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyor_postsPayload>
          }
          aggregate: {
            args: Prisma.Tube_conveyor_postsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_conveyor_posts>
          }
          groupBy: {
            args: Prisma.tube_conveyor_postsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_conveyor_postsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_conveyor_postsCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_conveyor_postsCountAggregateOutputType> | number
          }
        }
      }
      tube_conveyors: {
        payload: Prisma.$tube_conveyorsPayload<ExtArgs>
        fields: Prisma.tube_conveyorsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_conveyorsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_conveyorsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>
          }
          findFirst: {
            args: Prisma.tube_conveyorsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_conveyorsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>
          }
          findMany: {
            args: Prisma.tube_conveyorsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>[]
          }
          create: {
            args: Prisma.tube_conveyorsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>
          }
          createMany: {
            args: Prisma.tube_conveyorsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_conveyorsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>[]
          }
          delete: {
            args: Prisma.tube_conveyorsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>
          }
          update: {
            args: Prisma.tube_conveyorsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>
          }
          deleteMany: {
            args: Prisma.tube_conveyorsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_conveyorsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_conveyorsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>[]
          }
          upsert: {
            args: Prisma.tube_conveyorsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_conveyorsPayload>
          }
          aggregate: {
            args: Prisma.Tube_conveyorsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_conveyors>
          }
          groupBy: {
            args: Prisma.tube_conveyorsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_conveyorsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_conveyorsCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_conveyorsCountAggregateOutputType> | number
          }
        }
      }
      tube_histories: {
        payload: Prisma.$tube_historiesPayload<ExtArgs>
        fields: Prisma.tube_historiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_historiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_historiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>
          }
          findFirst: {
            args: Prisma.tube_historiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_historiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>
          }
          findMany: {
            args: Prisma.tube_historiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>[]
          }
          create: {
            args: Prisma.tube_historiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>
          }
          createMany: {
            args: Prisma.tube_historiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_historiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>[]
          }
          delete: {
            args: Prisma.tube_historiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>
          }
          update: {
            args: Prisma.tube_historiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>
          }
          deleteMany: {
            args: Prisma.tube_historiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_historiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_historiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>[]
          }
          upsert: {
            args: Prisma.tube_historiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_historiesPayload>
          }
          aggregate: {
            args: Prisma.Tube_historiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_histories>
          }
          groupBy: {
            args: Prisma.tube_historiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_historiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_historiesCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_historiesCountAggregateOutputType> | number
          }
        }
      }
      tube_histories_notes: {
        payload: Prisma.$tube_histories_notesPayload<ExtArgs>
        fields: Prisma.tube_histories_notesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_histories_notesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_histories_notesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>
          }
          findFirst: {
            args: Prisma.tube_histories_notesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_histories_notesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>
          }
          findMany: {
            args: Prisma.tube_histories_notesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>[]
          }
          create: {
            args: Prisma.tube_histories_notesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>
          }
          createMany: {
            args: Prisma.tube_histories_notesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_histories_notesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>[]
          }
          delete: {
            args: Prisma.tube_histories_notesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>
          }
          update: {
            args: Prisma.tube_histories_notesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>
          }
          deleteMany: {
            args: Prisma.tube_histories_notesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_histories_notesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_histories_notesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>[]
          }
          upsert: {
            args: Prisma.tube_histories_notesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_histories_notesPayload>
          }
          aggregate: {
            args: Prisma.Tube_histories_notesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_histories_notes>
          }
          groupBy: {
            args: Prisma.tube_histories_notesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_histories_notesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_histories_notesCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_histories_notesCountAggregateOutputType> | number
          }
        }
      }
      tube_history_types: {
        payload: Prisma.$tube_history_typesPayload<ExtArgs>
        fields: Prisma.tube_history_typesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_history_typesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_history_typesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>
          }
          findFirst: {
            args: Prisma.tube_history_typesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_history_typesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>
          }
          findMany: {
            args: Prisma.tube_history_typesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>[]
          }
          create: {
            args: Prisma.tube_history_typesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>
          }
          createMany: {
            args: Prisma.tube_history_typesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_history_typesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>[]
          }
          delete: {
            args: Prisma.tube_history_typesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>
          }
          update: {
            args: Prisma.tube_history_typesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>
          }
          deleteMany: {
            args: Prisma.tube_history_typesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_history_typesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_history_typesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>[]
          }
          upsert: {
            args: Prisma.tube_history_typesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_history_typesPayload>
          }
          aggregate: {
            args: Prisma.Tube_history_typesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_history_types>
          }
          groupBy: {
            args: Prisma.tube_history_typesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_history_typesGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_history_typesCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_history_typesCountAggregateOutputType> | number
          }
        }
      }
      tube_materials: {
        payload: Prisma.$tube_materialsPayload<ExtArgs>
        fields: Prisma.tube_materialsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_materialsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_materialsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>
          }
          findFirst: {
            args: Prisma.tube_materialsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_materialsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>
          }
          findMany: {
            args: Prisma.tube_materialsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>[]
          }
          create: {
            args: Prisma.tube_materialsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>
          }
          createMany: {
            args: Prisma.tube_materialsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_materialsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>[]
          }
          delete: {
            args: Prisma.tube_materialsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>
          }
          update: {
            args: Prisma.tube_materialsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>
          }
          deleteMany: {
            args: Prisma.tube_materialsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_materialsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_materialsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>[]
          }
          upsert: {
            args: Prisma.tube_materialsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_materialsPayload>
          }
          aggregate: {
            args: Prisma.Tube_materialsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_materials>
          }
          groupBy: {
            args: Prisma.tube_materialsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_materialsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_materialsCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_materialsCountAggregateOutputType> | number
          }
        }
      }
      tube_parameters: {
        payload: Prisma.$tube_parametersPayload<ExtArgs>
        fields: Prisma.tube_parametersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_parametersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_parametersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>
          }
          findFirst: {
            args: Prisma.tube_parametersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_parametersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>
          }
          findMany: {
            args: Prisma.tube_parametersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>[]
          }
          create: {
            args: Prisma.tube_parametersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>
          }
          createMany: {
            args: Prisma.tube_parametersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_parametersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>[]
          }
          delete: {
            args: Prisma.tube_parametersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>
          }
          update: {
            args: Prisma.tube_parametersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>
          }
          deleteMany: {
            args: Prisma.tube_parametersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_parametersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_parametersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>[]
          }
          upsert: {
            args: Prisma.tube_parametersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_parametersPayload>
          }
          aggregate: {
            args: Prisma.Tube_parametersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_parameters>
          }
          groupBy: {
            args: Prisma.tube_parametersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_parametersGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_parametersCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_parametersCountAggregateOutputType> | number
          }
        }
      }
      tube_products: {
        payload: Prisma.$tube_productsPayload<ExtArgs>
        fields: Prisma.tube_productsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_productsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_productsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>
          }
          findFirst: {
            args: Prisma.tube_productsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_productsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>
          }
          findMany: {
            args: Prisma.tube_productsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>[]
          }
          create: {
            args: Prisma.tube_productsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>
          }
          createMany: {
            args: Prisma.tube_productsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_productsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>[]
          }
          delete: {
            args: Prisma.tube_productsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>
          }
          update: {
            args: Prisma.tube_productsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>
          }
          deleteMany: {
            args: Prisma.tube_productsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_productsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_productsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>[]
          }
          upsert: {
            args: Prisma.tube_productsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_productsPayload>
          }
          aggregate: {
            args: Prisma.Tube_productsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_products>
          }
          groupBy: {
            args: Prisma.tube_productsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_productsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_productsCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_productsCountAggregateOutputType> | number
          }
        }
      }
      tube_records: {
        payload: Prisma.$tube_recordsPayload<ExtArgs>
        fields: Prisma.tube_recordsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_recordsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_recordsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>
          }
          findFirst: {
            args: Prisma.tube_recordsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_recordsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>
          }
          findMany: {
            args: Prisma.tube_recordsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>[]
          }
          create: {
            args: Prisma.tube_recordsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>
          }
          createMany: {
            args: Prisma.tube_recordsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_recordsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>[]
          }
          delete: {
            args: Prisma.tube_recordsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>
          }
          update: {
            args: Prisma.tube_recordsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>
          }
          deleteMany: {
            args: Prisma.tube_recordsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_recordsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_recordsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>[]
          }
          upsert: {
            args: Prisma.tube_recordsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_recordsPayload>
          }
          aggregate: {
            args: Prisma.Tube_recordsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_records>
          }
          groupBy: {
            args: Prisma.tube_recordsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_recordsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_recordsCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_recordsCountAggregateOutputType> | number
          }
        }
      }
      tube_sessions: {
        payload: Prisma.$tube_sessionsPayload<ExtArgs>
        fields: Prisma.tube_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>
          }
          findFirst: {
            args: Prisma.tube_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>
          }
          findMany: {
            args: Prisma.tube_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>[]
          }
          create: {
            args: Prisma.tube_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>
          }
          createMany: {
            args: Prisma.tube_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>[]
          }
          delete: {
            args: Prisma.tube_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>
          }
          update: {
            args: Prisma.tube_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.tube_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>[]
          }
          upsert: {
            args: Prisma.tube_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Tube_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_sessions>
          }
          groupBy: {
            args: Prisma.tube_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_sessionsCountAggregateOutputType> | number
          }
        }
      }
      tube_specifications: {
        payload: Prisma.$tube_specificationsPayload<ExtArgs>
        fields: Prisma.tube_specificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tube_specificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tube_specificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>
          }
          findFirst: {
            args: Prisma.tube_specificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tube_specificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>
          }
          findMany: {
            args: Prisma.tube_specificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>[]
          }
          create: {
            args: Prisma.tube_specificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>
          }
          createMany: {
            args: Prisma.tube_specificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tube_specificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>[]
          }
          delete: {
            args: Prisma.tube_specificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>
          }
          update: {
            args: Prisma.tube_specificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>
          }
          deleteMany: {
            args: Prisma.tube_specificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tube_specificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tube_specificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>[]
          }
          upsert: {
            args: Prisma.tube_specificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tube_specificationsPayload>
          }
          aggregate: {
            args: Prisma.Tube_specificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTube_specifications>
          }
          groupBy: {
            args: Prisma.tube_specificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Tube_specificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tube_specificationsCountArgs<ExtArgs>
            result: $Utils.Optional<Tube_specificationsCountAggregateOutputType> | number
          }
        }
      }
      user_roles: {
        payload: Prisma.$user_rolesPayload<ExtArgs>
        fields: Prisma.user_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findFirst: {
            args: Prisma.user_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          findMany: {
            args: Prisma.user_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          create: {
            args: Prisma.user_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          createMany: {
            args: Prisma.user_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.user_rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          delete: {
            args: Prisma.user_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          update: {
            args: Prisma.user_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          deleteMany: {
            args: Prisma.user_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.user_rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>[]
          }
          upsert: {
            args: Prisma.user_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_rolesPayload>
          }
          aggregate: {
            args: Prisma.User_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_roles>
          }
          groupBy: {
            args: Prisma.user_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.user_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<User_rolesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      workshops: {
        payload: Prisma.$workshopsPayload<ExtArgs>
        fields: Prisma.workshopsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.workshopsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.workshopsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>
          }
          findFirst: {
            args: Prisma.workshopsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.workshopsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>
          }
          findMany: {
            args: Prisma.workshopsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>[]
          }
          create: {
            args: Prisma.workshopsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>
          }
          createMany: {
            args: Prisma.workshopsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.workshopsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>[]
          }
          delete: {
            args: Prisma.workshopsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>
          }
          update: {
            args: Prisma.workshopsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>
          }
          deleteMany: {
            args: Prisma.workshopsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.workshopsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.workshopsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>[]
          }
          upsert: {
            args: Prisma.workshopsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$workshopsPayload>
          }
          aggregate: {
            args: Prisma.WorkshopsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkshops>
          }
          groupBy: {
            args: Prisma.workshopsGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkshopsGroupByOutputType>[]
          }
          count: {
            args: Prisma.workshopsCountArgs<ExtArgs>
            result: $Utils.Optional<WorkshopsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    batchs?: BatchsOmit
    traceBatches?: TraceBatchesOmit
    api_errors?: api_errorsOmit
    apparatuses?: apparatusesOmit
    bases?: basesOmit
    batchs?: batchsOmit
    boils?: boilsOmit
    cans?: cansOmit
    conveyors?: conveyorsOmit
    dbo_Batchs?: dbo_BatchsOmit
    docs?: docsOmit
    employees?: employeesOmit
    histories?: historiesOmit
    history_types?: history_typesOmit
    marking_sample?: marking_sampleOmit
    notes?: notesOmit
    occupations?: occupationsOmit
    plants?: plantsOmit
    products?: productsOmit
    record_regulations?: record_regulationsOmit
    records?: recordsOmit
    regulations?: regulationsOmit
    roles?: rolesOmit
    semi_products?: semi_productsOmit
    series?: seriesOmit
    signals?: signalsOmit
    tokens?: tokensOmit
    tube_assembly?: tube_assemblyOmit
    tube_conveyor_posts?: tube_conveyor_postsOmit
    tube_conveyors?: tube_conveyorsOmit
    tube_histories?: tube_historiesOmit
    tube_histories_notes?: tube_histories_notesOmit
    tube_history_types?: tube_history_typesOmit
    tube_materials?: tube_materialsOmit
    tube_parameters?: tube_parametersOmit
    tube_products?: tube_productsOmit
    tube_records?: tube_recordsOmit
    tube_sessions?: tube_sessionsOmit
    tube_specifications?: tube_specificationsOmit
    user_roles?: user_rolesOmit
    users?: usersOmit
    workshops?: workshopsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ApparatusesCountOutputType
   */

  export type ApparatusesCountOutputType = {
    records: number
  }

  export type ApparatusesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | ApparatusesCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * ApparatusesCountOutputType without action
   */
  export type ApparatusesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApparatusesCountOutputType
     */
    select?: ApparatusesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ApparatusesCountOutputType without action
   */
  export type ApparatusesCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
  }


  /**
   * Count Type BasesCountOutputType
   */

  export type BasesCountOutputType = {
    boils: number
  }

  export type BasesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | BasesCountOutputTypeCountBoilsArgs
  }

  // Custom InputTypes
  /**
   * BasesCountOutputType without action
   */
  export type BasesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BasesCountOutputType
     */
    select?: BasesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BasesCountOutputType without action
   */
  export type BasesCountOutputTypeCountBoilsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: boilsWhereInput
  }


  /**
   * Count Type BoilsCountOutputType
   */

  export type BoilsCountOutputType = {
    semi_products: number
    tube_records: number
    records: number
  }

  export type BoilsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    semi_products?: boolean | BoilsCountOutputTypeCountSemi_productsArgs
    tube_records?: boolean | BoilsCountOutputTypeCountTube_recordsArgs
    records?: boolean | BoilsCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * BoilsCountOutputType without action
   */
  export type BoilsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BoilsCountOutputType
     */
    select?: BoilsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BoilsCountOutputType without action
   */
  export type BoilsCountOutputTypeCountSemi_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: semi_productsWhereInput
  }

  /**
   * BoilsCountOutputType without action
   */
  export type BoilsCountOutputTypeCountTube_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_recordsWhereInput
  }

  /**
   * BoilsCountOutputType without action
   */
  export type BoilsCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
  }


  /**
   * Count Type CansCountOutputType
   */

  export type CansCountOutputType = {
    records: number
  }

  export type CansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | CansCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * CansCountOutputType without action
   */
  export type CansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CansCountOutputType
     */
    select?: CansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CansCountOutputType without action
   */
  export type CansCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
  }


  /**
   * Count Type ConveyorsCountOutputType
   */

  export type ConveyorsCountOutputType = {
    records: number
  }

  export type ConveyorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | ConveyorsCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * ConveyorsCountOutputType without action
   */
  export type ConveyorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConveyorsCountOutputType
     */
    select?: ConveyorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConveyorsCountOutputType without action
   */
  export type ConveyorsCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
  }


  /**
   * Count Type DocsCountOutputType
   */

  export type DocsCountOutputType = {
    records: number
  }

  export type DocsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | DocsCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * DocsCountOutputType without action
   */
  export type DocsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocsCountOutputType
     */
    select?: DocsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocsCountOutputType without action
   */
  export type DocsCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
  }


  /**
   * Count Type EmployeesCountOutputType
   */

  export type EmployeesCountOutputType = {
    histories: number
    tube_histories: number
    tube_sessions: number
  }

  export type EmployeesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | EmployeesCountOutputTypeCountHistoriesArgs
    tube_histories?: boolean | EmployeesCountOutputTypeCountTube_historiesArgs
    tube_sessions?: boolean | EmployeesCountOutputTypeCountTube_sessionsArgs
  }

  // Custom InputTypes
  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeesCountOutputType
     */
    select?: EmployeesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historiesWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountTube_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_historiesWhereInput
  }

  /**
   * EmployeesCountOutputType without action
   */
  export type EmployeesCountOutputTypeCountTube_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_sessionsWhereInput
  }


  /**
   * Count Type History_typesCountOutputType
   */

  export type History_typesCountOutputType = {
    histories: number
  }

  export type History_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | History_typesCountOutputTypeCountHistoriesArgs
  }

  // Custom InputTypes
  /**
   * History_typesCountOutputType without action
   */
  export type History_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the History_typesCountOutputType
     */
    select?: History_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * History_typesCountOutputType without action
   */
  export type History_typesCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historiesWhereInput
  }


  /**
   * Count Type Marking_sampleCountOutputType
   */

  export type Marking_sampleCountOutputType = {
    record_regulations: number
    regulations: number
  }

  export type Marking_sampleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    record_regulations?: boolean | Marking_sampleCountOutputTypeCountRecord_regulationsArgs
    regulations?: boolean | Marking_sampleCountOutputTypeCountRegulationsArgs
  }

  // Custom InputTypes
  /**
   * Marking_sampleCountOutputType without action
   */
  export type Marking_sampleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Marking_sampleCountOutputType
     */
    select?: Marking_sampleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Marking_sampleCountOutputType without action
   */
  export type Marking_sampleCountOutputTypeCountRecord_regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: record_regulationsWhereInput
  }

  /**
   * Marking_sampleCountOutputType without action
   */
  export type Marking_sampleCountOutputTypeCountRegulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: regulationsWhereInput
  }


  /**
   * Count Type OccupationsCountOutputType
   */

  export type OccupationsCountOutputType = {
    employees: number
  }

  export type OccupationsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | OccupationsCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * OccupationsCountOutputType without action
   */
  export type OccupationsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OccupationsCountOutputType
     */
    select?: OccupationsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OccupationsCountOutputType without action
   */
  export type OccupationsCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeesWhereInput
  }


  /**
   * Count Type PlantsCountOutputType
   */

  export type PlantsCountOutputType = {
    docs: number
  }

  export type PlantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docs?: boolean | PlantsCountOutputTypeCountDocsArgs
  }

  // Custom InputTypes
  /**
   * PlantsCountOutputType without action
   */
  export type PlantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlantsCountOutputType
     */
    select?: PlantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlantsCountOutputType without action
   */
  export type PlantsCountOutputTypeCountDocsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: docsWhereInput
  }


  /**
   * Count Type ProductsCountOutputType
   */

  export type ProductsCountOutputType = {
    records: number
    regulations: number
    semi_products: number
  }

  export type ProductsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | ProductsCountOutputTypeCountRecordsArgs
    regulations?: boolean | ProductsCountOutputTypeCountRegulationsArgs
    semi_products?: boolean | ProductsCountOutputTypeCountSemi_productsArgs
  }

  // Custom InputTypes
  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductsCountOutputType
     */
    select?: ProductsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountRegulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: regulationsWhereInput
  }

  /**
   * ProductsCountOutputType without action
   */
  export type ProductsCountOutputTypeCountSemi_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: semi_productsWhereInput
  }


  /**
   * Count Type RecordsCountOutputType
   */

  export type RecordsCountOutputType = {
    histories: number
    record_regulations: number
    semi_products: number
  }

  export type RecordsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | RecordsCountOutputTypeCountHistoriesArgs
    record_regulations?: boolean | RecordsCountOutputTypeCountRecord_regulationsArgs
    semi_products?: boolean | RecordsCountOutputTypeCountSemi_productsArgs
  }

  // Custom InputTypes
  /**
   * RecordsCountOutputType without action
   */
  export type RecordsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RecordsCountOutputType
     */
    select?: RecordsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RecordsCountOutputType without action
   */
  export type RecordsCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historiesWhereInput
  }

  /**
   * RecordsCountOutputType without action
   */
  export type RecordsCountOutputTypeCountRecord_regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: record_regulationsWhereInput
  }

  /**
   * RecordsCountOutputType without action
   */
  export type RecordsCountOutputTypeCountSemi_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: semi_productsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    user_roles: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | RolesCountOutputTypeCountUser_rolesArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Count Type SeriesCountOutputType
   */

  export type SeriesCountOutputType = {
    products: number
  }

  export type SeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | SeriesCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesCountOutputType
     */
    select?: SeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
  }


  /**
   * Count Type Tube_conveyor_postsCountOutputType
   */

  export type Tube_conveyor_postsCountOutputType = {
    tube_assembly: number
  }

  export type Tube_conveyor_postsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_assembly?: boolean | Tube_conveyor_postsCountOutputTypeCountTube_assemblyArgs
  }

  // Custom InputTypes
  /**
   * Tube_conveyor_postsCountOutputType without action
   */
  export type Tube_conveyor_postsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tube_conveyor_postsCountOutputType
     */
    select?: Tube_conveyor_postsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tube_conveyor_postsCountOutputType without action
   */
  export type Tube_conveyor_postsCountOutputTypeCountTube_assemblyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_assemblyWhereInput
  }


  /**
   * Count Type Tube_conveyorsCountOutputType
   */

  export type Tube_conveyorsCountOutputType = {
    tube_records: number
    tube_sessions: number
  }

  export type Tube_conveyorsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_records?: boolean | Tube_conveyorsCountOutputTypeCountTube_recordsArgs
    tube_sessions?: boolean | Tube_conveyorsCountOutputTypeCountTube_sessionsArgs
  }

  // Custom InputTypes
  /**
   * Tube_conveyorsCountOutputType without action
   */
  export type Tube_conveyorsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tube_conveyorsCountOutputType
     */
    select?: Tube_conveyorsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tube_conveyorsCountOutputType without action
   */
  export type Tube_conveyorsCountOutputTypeCountTube_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_recordsWhereInput
  }

  /**
   * Tube_conveyorsCountOutputType without action
   */
  export type Tube_conveyorsCountOutputTypeCountTube_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_sessionsWhereInput
  }


  /**
   * Count Type Tube_histories_notesCountOutputType
   */

  export type Tube_histories_notesCountOutputType = {
    tube_histories: number
  }

  export type Tube_histories_notesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_histories?: boolean | Tube_histories_notesCountOutputTypeCountTube_historiesArgs
  }

  // Custom InputTypes
  /**
   * Tube_histories_notesCountOutputType without action
   */
  export type Tube_histories_notesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tube_histories_notesCountOutputType
     */
    select?: Tube_histories_notesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tube_histories_notesCountOutputType without action
   */
  export type Tube_histories_notesCountOutputTypeCountTube_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_historiesWhereInput
  }


  /**
   * Count Type Tube_history_typesCountOutputType
   */

  export type Tube_history_typesCountOutputType = {
    tube_histories: number
  }

  export type Tube_history_typesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_histories?: boolean | Tube_history_typesCountOutputTypeCountTube_historiesArgs
  }

  // Custom InputTypes
  /**
   * Tube_history_typesCountOutputType without action
   */
  export type Tube_history_typesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tube_history_typesCountOutputType
     */
    select?: Tube_history_typesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tube_history_typesCountOutputType without action
   */
  export type Tube_history_typesCountOutputTypeCountTube_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_historiesWhereInput
  }


  /**
   * Count Type Tube_materialsCountOutputType
   */

  export type Tube_materialsCountOutputType = {
    tube_assembly: number
    tube_specifications: number
  }

  export type Tube_materialsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_assembly?: boolean | Tube_materialsCountOutputTypeCountTube_assemblyArgs
    tube_specifications?: boolean | Tube_materialsCountOutputTypeCountTube_specificationsArgs
  }

  // Custom InputTypes
  /**
   * Tube_materialsCountOutputType without action
   */
  export type Tube_materialsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tube_materialsCountOutputType
     */
    select?: Tube_materialsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tube_materialsCountOutputType without action
   */
  export type Tube_materialsCountOutputTypeCountTube_assemblyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_assemblyWhereInput
  }

  /**
   * Tube_materialsCountOutputType without action
   */
  export type Tube_materialsCountOutputTypeCountTube_specificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_specificationsWhereInput
  }


  /**
   * Count Type Tube_productsCountOutputType
   */

  export type Tube_productsCountOutputType = {
    tube_records: number
    tube_specifications: number
  }

  export type Tube_productsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_records?: boolean | Tube_productsCountOutputTypeCountTube_recordsArgs
    tube_specifications?: boolean | Tube_productsCountOutputTypeCountTube_specificationsArgs
  }

  // Custom InputTypes
  /**
   * Tube_productsCountOutputType without action
   */
  export type Tube_productsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tube_productsCountOutputType
     */
    select?: Tube_productsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Tube_productsCountOutputType without action
   */
  export type Tube_productsCountOutputTypeCountTube_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_recordsWhereInput
  }

  /**
   * Tube_productsCountOutputType without action
   */
  export type Tube_productsCountOutputTypeCountTube_specificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_specificationsWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    histories: number
    tokens: number
    user_roles: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | UsersCountOutputTypeCountHistoriesArgs
    tokens?: boolean | UsersCountOutputTypeCountTokensArgs
    user_roles?: boolean | UsersCountOutputTypeCountUser_rolesArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historiesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokensWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUser_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
  }


  /**
   * Count Type WorkshopsCountOutputType
   */

  export type WorkshopsCountOutputType = {
    records: number
  }

  export type WorkshopsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | WorkshopsCountOutputTypeCountRecordsArgs
  }

  // Custom InputTypes
  /**
   * WorkshopsCountOutputType without action
   */
  export type WorkshopsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkshopsCountOutputType
     */
    select?: WorkshopsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkshopsCountOutputType without action
   */
  export type WorkshopsCountOutputTypeCountRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Batchs
   */

  export type AggregateBatchs = {
    _count: BatchsCountAggregateOutputType | null
    _avg: BatchsAvgAggregateOutputType | null
    _sum: BatchsSumAggregateOutputType | null
    _min: BatchsMinAggregateOutputType | null
    _max: BatchsMaxAggregateOutputType | null
  }

  export type BatchsAvgAggregateOutputType = {
    BatchPK: number | null
  }

  export type BatchsSumAggregateOutputType = {
    BatchPK: number | null
  }

  export type BatchsMinAggregateOutputType = {
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchsMaxAggregateOutputType = {
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchsCountAggregateOutputType = {
    BatchPK: number
    BatchName: number
    BatchDate: number
    Plant: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchsAvgAggregateInputType = {
    BatchPK?: true
  }

  export type BatchsSumAggregateInputType = {
    BatchPK?: true
  }

  export type BatchsMinAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchsMaxAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchsCountAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batchs to aggregate.
     */
    where?: BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batchs to fetch.
     */
    orderBy?: BatchsOrderByWithRelationInput | BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Batchs
    **/
    _count?: true | BatchsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchsMaxAggregateInputType
  }

  export type GetBatchsAggregateType<T extends BatchsAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchs[P]>
      : GetScalarType<T[P], AggregateBatchs[P]>
  }




  export type BatchsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BatchsWhereInput
    orderBy?: BatchsOrderByWithAggregationInput | BatchsOrderByWithAggregationInput[]
    by: BatchsScalarFieldEnum[] | BatchsScalarFieldEnum
    having?: BatchsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchsCountAggregateInputType | true
    _avg?: BatchsAvgAggregateInputType
    _sum?: BatchsSumAggregateInputType
    _min?: BatchsMinAggregateInputType
    _max?: BatchsMaxAggregateInputType
  }

  export type BatchsGroupByOutputType = {
    BatchPK: number
    BatchName: string
    BatchDate: Date | null
    Plant: string
    createdAt: Date
    updatedAt: Date
    _count: BatchsCountAggregateOutputType | null
    _avg: BatchsAvgAggregateOutputType | null
    _sum: BatchsSumAggregateOutputType | null
    _min: BatchsMinAggregateOutputType | null
    _max: BatchsMaxAggregateOutputType | null
  }

  type GetBatchsGroupByPayload<T extends BatchsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchsGroupByOutputType[P]>
            : GetScalarType<T[P], BatchsGroupByOutputType[P]>
        }
      >
    >


  export type BatchsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchs"]>

  export type BatchsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchs"]>

  export type BatchsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchs"]>

  export type BatchsSelectScalar = {
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BatchsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"BatchPK" | "BatchName" | "BatchDate" | "Plant" | "createdAt" | "updatedAt", ExtArgs["result"]["batchs"]>

  export type $BatchsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Batchs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      BatchPK: number
      BatchName: string
      BatchDate: Date | null
      Plant: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batchs"]>
    composites: {}
  }

  type BatchsGetPayload<S extends boolean | null | undefined | BatchsDefaultArgs> = $Result.GetResult<Prisma.$BatchsPayload, S>

  type BatchsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BatchsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchsCountAggregateInputType | true
    }

  export interface BatchsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Batchs'], meta: { name: 'Batchs' } }
    /**
     * Find zero or one Batchs that matches the filter.
     * @param {BatchsFindUniqueArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BatchsFindUniqueArgs>(args: SelectSubset<T, BatchsFindUniqueArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batchs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BatchsFindUniqueOrThrowArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BatchsFindUniqueOrThrowArgs>(args: SelectSubset<T, BatchsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsFindFirstArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BatchsFindFirstArgs>(args?: SelectSubset<T, BatchsFindFirstArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batchs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsFindFirstOrThrowArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BatchsFindFirstOrThrowArgs>(args?: SelectSubset<T, BatchsFindFirstOrThrowArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batchs
     * const batchs = await prisma.batchs.findMany()
     * 
     * // Get first 10 Batchs
     * const batchs = await prisma.batchs.findMany({ take: 10 })
     * 
     * // Only select the `BatchPK`
     * const batchsWithBatchPKOnly = await prisma.batchs.findMany({ select: { BatchPK: true } })
     * 
     */
    findMany<T extends BatchsFindManyArgs>(args?: SelectSubset<T, BatchsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batchs.
     * @param {BatchsCreateArgs} args - Arguments to create a Batchs.
     * @example
     * // Create one Batchs
     * const Batchs = await prisma.batchs.create({
     *   data: {
     *     // ... data to create a Batchs
     *   }
     * })
     * 
     */
    create<T extends BatchsCreateArgs>(args: SelectSubset<T, BatchsCreateArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batchs.
     * @param {BatchsCreateManyArgs} args - Arguments to create many Batchs.
     * @example
     * // Create many Batchs
     * const batchs = await prisma.batchs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BatchsCreateManyArgs>(args?: SelectSubset<T, BatchsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batchs and returns the data saved in the database.
     * @param {BatchsCreateManyAndReturnArgs} args - Arguments to create many Batchs.
     * @example
     * // Create many Batchs
     * const batchs = await prisma.batchs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batchs and only return the `BatchPK`
     * const batchsWithBatchPKOnly = await prisma.batchs.createManyAndReturn({
     *   select: { BatchPK: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BatchsCreateManyAndReturnArgs>(args?: SelectSubset<T, BatchsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batchs.
     * @param {BatchsDeleteArgs} args - Arguments to delete one Batchs.
     * @example
     * // Delete one Batchs
     * const Batchs = await prisma.batchs.delete({
     *   where: {
     *     // ... filter to delete one Batchs
     *   }
     * })
     * 
     */
    delete<T extends BatchsDeleteArgs>(args: SelectSubset<T, BatchsDeleteArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batchs.
     * @param {BatchsUpdateArgs} args - Arguments to update one Batchs.
     * @example
     * // Update one Batchs
     * const batchs = await prisma.batchs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BatchsUpdateArgs>(args: SelectSubset<T, BatchsUpdateArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batchs.
     * @param {BatchsDeleteManyArgs} args - Arguments to filter Batchs to delete.
     * @example
     * // Delete a few Batchs
     * const { count } = await prisma.batchs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BatchsDeleteManyArgs>(args?: SelectSubset<T, BatchsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batchs
     * const batchs = await prisma.batchs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BatchsUpdateManyArgs>(args: SelectSubset<T, BatchsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batchs and returns the data updated in the database.
     * @param {BatchsUpdateManyAndReturnArgs} args - Arguments to update many Batchs.
     * @example
     * // Update many Batchs
     * const batchs = await prisma.batchs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batchs and only return the `BatchPK`
     * const batchsWithBatchPKOnly = await prisma.batchs.updateManyAndReturn({
     *   select: { BatchPK: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BatchsUpdateManyAndReturnArgs>(args: SelectSubset<T, BatchsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batchs.
     * @param {BatchsUpsertArgs} args - Arguments to update or create a Batchs.
     * @example
     * // Update or create a Batchs
     * const batchs = await prisma.batchs.upsert({
     *   create: {
     *     // ... data to create a Batchs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batchs we want to update
     *   }
     * })
     */
    upsert<T extends BatchsUpsertArgs>(args: SelectSubset<T, BatchsUpsertArgs<ExtArgs>>): Prisma__BatchsClient<$Result.GetResult<Prisma.$BatchsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsCountArgs} args - Arguments to filter Batchs to count.
     * @example
     * // Count the number of Batchs
     * const count = await prisma.batchs.count({
     *   where: {
     *     // ... the filter for the Batchs we want to count
     *   }
     * })
    **/
    count<T extends BatchsCountArgs>(
      args?: Subset<T, BatchsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchsAggregateArgs>(args: Subset<T, BatchsAggregateArgs>): Prisma.PrismaPromise<GetBatchsAggregateType<T>>

    /**
     * Group by Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BatchsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BatchsGroupByArgs['orderBy'] }
        : { orderBy?: BatchsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BatchsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Batchs model
   */
  readonly fields: BatchsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Batchs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BatchsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Batchs model
   */
  interface BatchsFieldRefs {
    readonly BatchPK: FieldRef<"Batchs", 'Int'>
    readonly BatchName: FieldRef<"Batchs", 'String'>
    readonly BatchDate: FieldRef<"Batchs", 'DateTime'>
    readonly Plant: FieldRef<"Batchs", 'String'>
    readonly createdAt: FieldRef<"Batchs", 'DateTime'>
    readonly updatedAt: FieldRef<"Batchs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Batchs findUnique
   */
  export type BatchsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * Filter, which Batchs to fetch.
     */
    where: BatchsWhereUniqueInput
  }

  /**
   * Batchs findUniqueOrThrow
   */
  export type BatchsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * Filter, which Batchs to fetch.
     */
    where: BatchsWhereUniqueInput
  }

  /**
   * Batchs findFirst
   */
  export type BatchsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * Filter, which Batchs to fetch.
     */
    where?: BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batchs to fetch.
     */
    orderBy?: BatchsOrderByWithRelationInput | BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batchs.
     */
    cursor?: BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batchs.
     */
    distinct?: BatchsScalarFieldEnum | BatchsScalarFieldEnum[]
  }

  /**
   * Batchs findFirstOrThrow
   */
  export type BatchsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * Filter, which Batchs to fetch.
     */
    where?: BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batchs to fetch.
     */
    orderBy?: BatchsOrderByWithRelationInput | BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Batchs.
     */
    cursor?: BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Batchs.
     */
    distinct?: BatchsScalarFieldEnum | BatchsScalarFieldEnum[]
  }

  /**
   * Batchs findMany
   */
  export type BatchsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * Filter, which Batchs to fetch.
     */
    where?: BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Batchs to fetch.
     */
    orderBy?: BatchsOrderByWithRelationInput | BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Batchs.
     */
    cursor?: BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Batchs.
     */
    skip?: number
    distinct?: BatchsScalarFieldEnum | BatchsScalarFieldEnum[]
  }

  /**
   * Batchs create
   */
  export type BatchsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * The data needed to create a Batchs.
     */
    data: XOR<BatchsCreateInput, BatchsUncheckedCreateInput>
  }

  /**
   * Batchs createMany
   */
  export type BatchsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Batchs.
     */
    data: BatchsCreateManyInput | BatchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batchs createManyAndReturn
   */
  export type BatchsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * The data used to create many Batchs.
     */
    data: BatchsCreateManyInput | BatchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Batchs update
   */
  export type BatchsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * The data needed to update a Batchs.
     */
    data: XOR<BatchsUpdateInput, BatchsUncheckedUpdateInput>
    /**
     * Choose, which Batchs to update.
     */
    where: BatchsWhereUniqueInput
  }

  /**
   * Batchs updateMany
   */
  export type BatchsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Batchs.
     */
    data: XOR<BatchsUpdateManyMutationInput, BatchsUncheckedUpdateManyInput>
    /**
     * Filter which Batchs to update
     */
    where?: BatchsWhereInput
    /**
     * Limit how many Batchs to update.
     */
    limit?: number
  }

  /**
   * Batchs updateManyAndReturn
   */
  export type BatchsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * The data used to update Batchs.
     */
    data: XOR<BatchsUpdateManyMutationInput, BatchsUncheckedUpdateManyInput>
    /**
     * Filter which Batchs to update
     */
    where?: BatchsWhereInput
    /**
     * Limit how many Batchs to update.
     */
    limit?: number
  }

  /**
   * Batchs upsert
   */
  export type BatchsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * The filter to search for the Batchs to update in case it exists.
     */
    where: BatchsWhereUniqueInput
    /**
     * In case the Batchs found by the `where` argument doesn't exist, create a new Batchs with this data.
     */
    create: XOR<BatchsCreateInput, BatchsUncheckedCreateInput>
    /**
     * In case the Batchs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BatchsUpdateInput, BatchsUncheckedUpdateInput>
  }

  /**
   * Batchs delete
   */
  export type BatchsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
    /**
     * Filter which Batchs to delete.
     */
    where: BatchsWhereUniqueInput
  }

  /**
   * Batchs deleteMany
   */
  export type BatchsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Batchs to delete
     */
    where?: BatchsWhereInput
    /**
     * Limit how many Batchs to delete.
     */
    limit?: number
  }

  /**
   * Batchs without action
   */
  export type BatchsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Batchs
     */
    select?: BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Batchs
     */
    omit?: BatchsOmit<ExtArgs> | null
  }


  /**
   * Model TraceBatches
   */

  export type AggregateTraceBatches = {
    _count: TraceBatchesCountAggregateOutputType | null
    _avg: TraceBatchesAvgAggregateOutputType | null
    _sum: TraceBatchesSumAggregateOutputType | null
    _min: TraceBatchesMinAggregateOutputType | null
    _max: TraceBatchesMaxAggregateOutputType | null
  }

  export type TraceBatchesAvgAggregateOutputType = {
    id: number | null
    BatchPK: number | null
  }

  export type TraceBatchesSumAggregateOutputType = {
    id: number | null
    BatchPK: number | null
  }

  export type TraceBatchesMinAggregateOutputType = {
    id: number | null
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TraceBatchesMaxAggregateOutputType = {
    id: number | null
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TraceBatchesCountAggregateOutputType = {
    id: number
    BatchPK: number
    BatchName: number
    BatchDate: number
    Plant: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TraceBatchesAvgAggregateInputType = {
    id?: true
    BatchPK?: true
  }

  export type TraceBatchesSumAggregateInputType = {
    id?: true
    BatchPK?: true
  }

  export type TraceBatchesMinAggregateInputType = {
    id?: true
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TraceBatchesMaxAggregateInputType = {
    id?: true
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TraceBatchesCountAggregateInputType = {
    id?: true
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TraceBatchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceBatches to aggregate.
     */
    where?: TraceBatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceBatches to fetch.
     */
    orderBy?: TraceBatchesOrderByWithRelationInput | TraceBatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TraceBatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TraceBatches
    **/
    _count?: true | TraceBatchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TraceBatchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TraceBatchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TraceBatchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TraceBatchesMaxAggregateInputType
  }

  export type GetTraceBatchesAggregateType<T extends TraceBatchesAggregateArgs> = {
        [P in keyof T & keyof AggregateTraceBatches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTraceBatches[P]>
      : GetScalarType<T[P], AggregateTraceBatches[P]>
  }




  export type TraceBatchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TraceBatchesWhereInput
    orderBy?: TraceBatchesOrderByWithAggregationInput | TraceBatchesOrderByWithAggregationInput[]
    by: TraceBatchesScalarFieldEnum[] | TraceBatchesScalarFieldEnum
    having?: TraceBatchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TraceBatchesCountAggregateInputType | true
    _avg?: TraceBatchesAvgAggregateInputType
    _sum?: TraceBatchesSumAggregateInputType
    _min?: TraceBatchesMinAggregateInputType
    _max?: TraceBatchesMaxAggregateInputType
  }

  export type TraceBatchesGroupByOutputType = {
    id: number
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date
    updatedAt: Date
    _count: TraceBatchesCountAggregateOutputType | null
    _avg: TraceBatchesAvgAggregateOutputType | null
    _sum: TraceBatchesSumAggregateOutputType | null
    _min: TraceBatchesMinAggregateOutputType | null
    _max: TraceBatchesMaxAggregateOutputType | null
  }

  type GetTraceBatchesGroupByPayload<T extends TraceBatchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TraceBatchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TraceBatchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TraceBatchesGroupByOutputType[P]>
            : GetScalarType<T[P], TraceBatchesGroupByOutputType[P]>
        }
      >
    >


  export type TraceBatchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["traceBatches"]>

  export type TraceBatchesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["traceBatches"]>

  export type TraceBatchesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["traceBatches"]>

  export type TraceBatchesSelectScalar = {
    id?: boolean
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TraceBatchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "BatchPK" | "BatchName" | "BatchDate" | "Plant" | "createdAt" | "updatedAt", ExtArgs["result"]["traceBatches"]>

  export type $TraceBatchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TraceBatches"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      BatchPK: number | null
      BatchName: string | null
      BatchDate: Date | null
      Plant: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["traceBatches"]>
    composites: {}
  }

  type TraceBatchesGetPayload<S extends boolean | null | undefined | TraceBatchesDefaultArgs> = $Result.GetResult<Prisma.$TraceBatchesPayload, S>

  type TraceBatchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TraceBatchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TraceBatchesCountAggregateInputType | true
    }

  export interface TraceBatchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TraceBatches'], meta: { name: 'TraceBatches' } }
    /**
     * Find zero or one TraceBatches that matches the filter.
     * @param {TraceBatchesFindUniqueArgs} args - Arguments to find a TraceBatches
     * @example
     * // Get one TraceBatches
     * const traceBatches = await prisma.traceBatches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TraceBatchesFindUniqueArgs>(args: SelectSubset<T, TraceBatchesFindUniqueArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TraceBatches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TraceBatchesFindUniqueOrThrowArgs} args - Arguments to find a TraceBatches
     * @example
     * // Get one TraceBatches
     * const traceBatches = await prisma.traceBatches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TraceBatchesFindUniqueOrThrowArgs>(args: SelectSubset<T, TraceBatchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraceBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceBatchesFindFirstArgs} args - Arguments to find a TraceBatches
     * @example
     * // Get one TraceBatches
     * const traceBatches = await prisma.traceBatches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TraceBatchesFindFirstArgs>(args?: SelectSubset<T, TraceBatchesFindFirstArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TraceBatches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceBatchesFindFirstOrThrowArgs} args - Arguments to find a TraceBatches
     * @example
     * // Get one TraceBatches
     * const traceBatches = await prisma.traceBatches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TraceBatchesFindFirstOrThrowArgs>(args?: SelectSubset<T, TraceBatchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TraceBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceBatchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TraceBatches
     * const traceBatches = await prisma.traceBatches.findMany()
     * 
     * // Get first 10 TraceBatches
     * const traceBatches = await prisma.traceBatches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const traceBatchesWithIdOnly = await prisma.traceBatches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TraceBatchesFindManyArgs>(args?: SelectSubset<T, TraceBatchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TraceBatches.
     * @param {TraceBatchesCreateArgs} args - Arguments to create a TraceBatches.
     * @example
     * // Create one TraceBatches
     * const TraceBatches = await prisma.traceBatches.create({
     *   data: {
     *     // ... data to create a TraceBatches
     *   }
     * })
     * 
     */
    create<T extends TraceBatchesCreateArgs>(args: SelectSubset<T, TraceBatchesCreateArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TraceBatches.
     * @param {TraceBatchesCreateManyArgs} args - Arguments to create many TraceBatches.
     * @example
     * // Create many TraceBatches
     * const traceBatches = await prisma.traceBatches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TraceBatchesCreateManyArgs>(args?: SelectSubset<T, TraceBatchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TraceBatches and returns the data saved in the database.
     * @param {TraceBatchesCreateManyAndReturnArgs} args - Arguments to create many TraceBatches.
     * @example
     * // Create many TraceBatches
     * const traceBatches = await prisma.traceBatches.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TraceBatches and only return the `id`
     * const traceBatchesWithIdOnly = await prisma.traceBatches.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TraceBatchesCreateManyAndReturnArgs>(args?: SelectSubset<T, TraceBatchesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TraceBatches.
     * @param {TraceBatchesDeleteArgs} args - Arguments to delete one TraceBatches.
     * @example
     * // Delete one TraceBatches
     * const TraceBatches = await prisma.traceBatches.delete({
     *   where: {
     *     // ... filter to delete one TraceBatches
     *   }
     * })
     * 
     */
    delete<T extends TraceBatchesDeleteArgs>(args: SelectSubset<T, TraceBatchesDeleteArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TraceBatches.
     * @param {TraceBatchesUpdateArgs} args - Arguments to update one TraceBatches.
     * @example
     * // Update one TraceBatches
     * const traceBatches = await prisma.traceBatches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TraceBatchesUpdateArgs>(args: SelectSubset<T, TraceBatchesUpdateArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TraceBatches.
     * @param {TraceBatchesDeleteManyArgs} args - Arguments to filter TraceBatches to delete.
     * @example
     * // Delete a few TraceBatches
     * const { count } = await prisma.traceBatches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TraceBatchesDeleteManyArgs>(args?: SelectSubset<T, TraceBatchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraceBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceBatchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TraceBatches
     * const traceBatches = await prisma.traceBatches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TraceBatchesUpdateManyArgs>(args: SelectSubset<T, TraceBatchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TraceBatches and returns the data updated in the database.
     * @param {TraceBatchesUpdateManyAndReturnArgs} args - Arguments to update many TraceBatches.
     * @example
     * // Update many TraceBatches
     * const traceBatches = await prisma.traceBatches.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TraceBatches and only return the `id`
     * const traceBatchesWithIdOnly = await prisma.traceBatches.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TraceBatchesUpdateManyAndReturnArgs>(args: SelectSubset<T, TraceBatchesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TraceBatches.
     * @param {TraceBatchesUpsertArgs} args - Arguments to update or create a TraceBatches.
     * @example
     * // Update or create a TraceBatches
     * const traceBatches = await prisma.traceBatches.upsert({
     *   create: {
     *     // ... data to create a TraceBatches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TraceBatches we want to update
     *   }
     * })
     */
    upsert<T extends TraceBatchesUpsertArgs>(args: SelectSubset<T, TraceBatchesUpsertArgs<ExtArgs>>): Prisma__TraceBatchesClient<$Result.GetResult<Prisma.$TraceBatchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TraceBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceBatchesCountArgs} args - Arguments to filter TraceBatches to count.
     * @example
     * // Count the number of TraceBatches
     * const count = await prisma.traceBatches.count({
     *   where: {
     *     // ... the filter for the TraceBatches we want to count
     *   }
     * })
    **/
    count<T extends TraceBatchesCountArgs>(
      args?: Subset<T, TraceBatchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TraceBatchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TraceBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceBatchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TraceBatchesAggregateArgs>(args: Subset<T, TraceBatchesAggregateArgs>): Prisma.PrismaPromise<GetTraceBatchesAggregateType<T>>

    /**
     * Group by TraceBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TraceBatchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TraceBatchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TraceBatchesGroupByArgs['orderBy'] }
        : { orderBy?: TraceBatchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TraceBatchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTraceBatchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TraceBatches model
   */
  readonly fields: TraceBatchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TraceBatches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TraceBatchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TraceBatches model
   */
  interface TraceBatchesFieldRefs {
    readonly id: FieldRef<"TraceBatches", 'Int'>
    readonly BatchPK: FieldRef<"TraceBatches", 'Int'>
    readonly BatchName: FieldRef<"TraceBatches", 'String'>
    readonly BatchDate: FieldRef<"TraceBatches", 'DateTime'>
    readonly Plant: FieldRef<"TraceBatches", 'String'>
    readonly createdAt: FieldRef<"TraceBatches", 'DateTime'>
    readonly updatedAt: FieldRef<"TraceBatches", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TraceBatches findUnique
   */
  export type TraceBatchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * Filter, which TraceBatches to fetch.
     */
    where: TraceBatchesWhereUniqueInput
  }

  /**
   * TraceBatches findUniqueOrThrow
   */
  export type TraceBatchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * Filter, which TraceBatches to fetch.
     */
    where: TraceBatchesWhereUniqueInput
  }

  /**
   * TraceBatches findFirst
   */
  export type TraceBatchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * Filter, which TraceBatches to fetch.
     */
    where?: TraceBatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceBatches to fetch.
     */
    orderBy?: TraceBatchesOrderByWithRelationInput | TraceBatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceBatches.
     */
    cursor?: TraceBatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceBatches.
     */
    distinct?: TraceBatchesScalarFieldEnum | TraceBatchesScalarFieldEnum[]
  }

  /**
   * TraceBatches findFirstOrThrow
   */
  export type TraceBatchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * Filter, which TraceBatches to fetch.
     */
    where?: TraceBatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceBatches to fetch.
     */
    orderBy?: TraceBatchesOrderByWithRelationInput | TraceBatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TraceBatches.
     */
    cursor?: TraceBatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TraceBatches.
     */
    distinct?: TraceBatchesScalarFieldEnum | TraceBatchesScalarFieldEnum[]
  }

  /**
   * TraceBatches findMany
   */
  export type TraceBatchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * Filter, which TraceBatches to fetch.
     */
    where?: TraceBatchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TraceBatches to fetch.
     */
    orderBy?: TraceBatchesOrderByWithRelationInput | TraceBatchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TraceBatches.
     */
    cursor?: TraceBatchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TraceBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TraceBatches.
     */
    skip?: number
    distinct?: TraceBatchesScalarFieldEnum | TraceBatchesScalarFieldEnum[]
  }

  /**
   * TraceBatches create
   */
  export type TraceBatchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * The data needed to create a TraceBatches.
     */
    data: XOR<TraceBatchesCreateInput, TraceBatchesUncheckedCreateInput>
  }

  /**
   * TraceBatches createMany
   */
  export type TraceBatchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TraceBatches.
     */
    data: TraceBatchesCreateManyInput | TraceBatchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraceBatches createManyAndReturn
   */
  export type TraceBatchesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * The data used to create many TraceBatches.
     */
    data: TraceBatchesCreateManyInput | TraceBatchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TraceBatches update
   */
  export type TraceBatchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * The data needed to update a TraceBatches.
     */
    data: XOR<TraceBatchesUpdateInput, TraceBatchesUncheckedUpdateInput>
    /**
     * Choose, which TraceBatches to update.
     */
    where: TraceBatchesWhereUniqueInput
  }

  /**
   * TraceBatches updateMany
   */
  export type TraceBatchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TraceBatches.
     */
    data: XOR<TraceBatchesUpdateManyMutationInput, TraceBatchesUncheckedUpdateManyInput>
    /**
     * Filter which TraceBatches to update
     */
    where?: TraceBatchesWhereInput
    /**
     * Limit how many TraceBatches to update.
     */
    limit?: number
  }

  /**
   * TraceBatches updateManyAndReturn
   */
  export type TraceBatchesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * The data used to update TraceBatches.
     */
    data: XOR<TraceBatchesUpdateManyMutationInput, TraceBatchesUncheckedUpdateManyInput>
    /**
     * Filter which TraceBatches to update
     */
    where?: TraceBatchesWhereInput
    /**
     * Limit how many TraceBatches to update.
     */
    limit?: number
  }

  /**
   * TraceBatches upsert
   */
  export type TraceBatchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * The filter to search for the TraceBatches to update in case it exists.
     */
    where: TraceBatchesWhereUniqueInput
    /**
     * In case the TraceBatches found by the `where` argument doesn't exist, create a new TraceBatches with this data.
     */
    create: XOR<TraceBatchesCreateInput, TraceBatchesUncheckedCreateInput>
    /**
     * In case the TraceBatches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TraceBatchesUpdateInput, TraceBatchesUncheckedUpdateInput>
  }

  /**
   * TraceBatches delete
   */
  export type TraceBatchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
    /**
     * Filter which TraceBatches to delete.
     */
    where: TraceBatchesWhereUniqueInput
  }

  /**
   * TraceBatches deleteMany
   */
  export type TraceBatchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TraceBatches to delete
     */
    where?: TraceBatchesWhereInput
    /**
     * Limit how many TraceBatches to delete.
     */
    limit?: number
  }

  /**
   * TraceBatches without action
   */
  export type TraceBatchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TraceBatches
     */
    select?: TraceBatchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TraceBatches
     */
    omit?: TraceBatchesOmit<ExtArgs> | null
  }


  /**
   * Model api_errors
   */

  export type AggregateApi_errors = {
    _count: Api_errorsCountAggregateOutputType | null
    _avg: Api_errorsAvgAggregateOutputType | null
    _sum: Api_errorsSumAggregateOutputType | null
    _min: Api_errorsMinAggregateOutputType | null
    _max: Api_errorsMaxAggregateOutputType | null
  }

  export type Api_errorsAvgAggregateOutputType = {
    id: number | null
  }

  export type Api_errorsSumAggregateOutputType = {
    id: number | null
  }

  export type Api_errorsMinAggregateOutputType = {
    id: number | null
    dto: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Api_errorsMaxAggregateOutputType = {
    id: number | null
    dto: string | null
    message: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Api_errorsCountAggregateOutputType = {
    id: number
    dto: number
    message: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Api_errorsAvgAggregateInputType = {
    id?: true
  }

  export type Api_errorsSumAggregateInputType = {
    id?: true
  }

  export type Api_errorsMinAggregateInputType = {
    id?: true
    dto?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Api_errorsMaxAggregateInputType = {
    id?: true
    dto?: true
    message?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Api_errorsCountAggregateInputType = {
    id?: true
    dto?: true
    message?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Api_errorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_errors to aggregate.
     */
    where?: api_errorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_errors to fetch.
     */
    orderBy?: api_errorsOrderByWithRelationInput | api_errorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: api_errorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned api_errors
    **/
    _count?: true | Api_errorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Api_errorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Api_errorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Api_errorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Api_errorsMaxAggregateInputType
  }

  export type GetApi_errorsAggregateType<T extends Api_errorsAggregateArgs> = {
        [P in keyof T & keyof AggregateApi_errors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApi_errors[P]>
      : GetScalarType<T[P], AggregateApi_errors[P]>
  }




  export type api_errorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: api_errorsWhereInput
    orderBy?: api_errorsOrderByWithAggregationInput | api_errorsOrderByWithAggregationInput[]
    by: Api_errorsScalarFieldEnum[] | Api_errorsScalarFieldEnum
    having?: api_errorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Api_errorsCountAggregateInputType | true
    _avg?: Api_errorsAvgAggregateInputType
    _sum?: Api_errorsSumAggregateInputType
    _min?: Api_errorsMinAggregateInputType
    _max?: Api_errorsMaxAggregateInputType
  }

  export type Api_errorsGroupByOutputType = {
    id: number
    dto: string | null
    message: string | null
    createdAt: Date
    updatedAt: Date
    _count: Api_errorsCountAggregateOutputType | null
    _avg: Api_errorsAvgAggregateOutputType | null
    _sum: Api_errorsSumAggregateOutputType | null
    _min: Api_errorsMinAggregateOutputType | null
    _max: Api_errorsMaxAggregateOutputType | null
  }

  type GetApi_errorsGroupByPayload<T extends api_errorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Api_errorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Api_errorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Api_errorsGroupByOutputType[P]>
            : GetScalarType<T[P], Api_errorsGroupByOutputType[P]>
        }
      >
    >


  export type api_errorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dto?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["api_errors"]>

  export type api_errorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dto?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["api_errors"]>

  export type api_errorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dto?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["api_errors"]>

  export type api_errorsSelectScalar = {
    id?: boolean
    dto?: boolean
    message?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type api_errorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dto" | "message" | "createdAt" | "updatedAt", ExtArgs["result"]["api_errors"]>

  export type $api_errorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "api_errors"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      dto: string | null
      message: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["api_errors"]>
    composites: {}
  }

  type api_errorsGetPayload<S extends boolean | null | undefined | api_errorsDefaultArgs> = $Result.GetResult<Prisma.$api_errorsPayload, S>

  type api_errorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<api_errorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Api_errorsCountAggregateInputType | true
    }

  export interface api_errorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['api_errors'], meta: { name: 'api_errors' } }
    /**
     * Find zero or one Api_errors that matches the filter.
     * @param {api_errorsFindUniqueArgs} args - Arguments to find a Api_errors
     * @example
     * // Get one Api_errors
     * const api_errors = await prisma.api_errors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends api_errorsFindUniqueArgs>(args: SelectSubset<T, api_errorsFindUniqueArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Api_errors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {api_errorsFindUniqueOrThrowArgs} args - Arguments to find a Api_errors
     * @example
     * // Get one Api_errors
     * const api_errors = await prisma.api_errors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends api_errorsFindUniqueOrThrowArgs>(args: SelectSubset<T, api_errorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_errorsFindFirstArgs} args - Arguments to find a Api_errors
     * @example
     * // Get one Api_errors
     * const api_errors = await prisma.api_errors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends api_errorsFindFirstArgs>(args?: SelectSubset<T, api_errorsFindFirstArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Api_errors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_errorsFindFirstOrThrowArgs} args - Arguments to find a Api_errors
     * @example
     * // Get one Api_errors
     * const api_errors = await prisma.api_errors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends api_errorsFindFirstOrThrowArgs>(args?: SelectSubset<T, api_errorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Api_errors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_errorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Api_errors
     * const api_errors = await prisma.api_errors.findMany()
     * 
     * // Get first 10 Api_errors
     * const api_errors = await prisma.api_errors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const api_errorsWithIdOnly = await prisma.api_errors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends api_errorsFindManyArgs>(args?: SelectSubset<T, api_errorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Api_errors.
     * @param {api_errorsCreateArgs} args - Arguments to create a Api_errors.
     * @example
     * // Create one Api_errors
     * const Api_errors = await prisma.api_errors.create({
     *   data: {
     *     // ... data to create a Api_errors
     *   }
     * })
     * 
     */
    create<T extends api_errorsCreateArgs>(args: SelectSubset<T, api_errorsCreateArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Api_errors.
     * @param {api_errorsCreateManyArgs} args - Arguments to create many Api_errors.
     * @example
     * // Create many Api_errors
     * const api_errors = await prisma.api_errors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends api_errorsCreateManyArgs>(args?: SelectSubset<T, api_errorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Api_errors and returns the data saved in the database.
     * @param {api_errorsCreateManyAndReturnArgs} args - Arguments to create many Api_errors.
     * @example
     * // Create many Api_errors
     * const api_errors = await prisma.api_errors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Api_errors and only return the `id`
     * const api_errorsWithIdOnly = await prisma.api_errors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends api_errorsCreateManyAndReturnArgs>(args?: SelectSubset<T, api_errorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Api_errors.
     * @param {api_errorsDeleteArgs} args - Arguments to delete one Api_errors.
     * @example
     * // Delete one Api_errors
     * const Api_errors = await prisma.api_errors.delete({
     *   where: {
     *     // ... filter to delete one Api_errors
     *   }
     * })
     * 
     */
    delete<T extends api_errorsDeleteArgs>(args: SelectSubset<T, api_errorsDeleteArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Api_errors.
     * @param {api_errorsUpdateArgs} args - Arguments to update one Api_errors.
     * @example
     * // Update one Api_errors
     * const api_errors = await prisma.api_errors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends api_errorsUpdateArgs>(args: SelectSubset<T, api_errorsUpdateArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Api_errors.
     * @param {api_errorsDeleteManyArgs} args - Arguments to filter Api_errors to delete.
     * @example
     * // Delete a few Api_errors
     * const { count } = await prisma.api_errors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends api_errorsDeleteManyArgs>(args?: SelectSubset<T, api_errorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_errorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Api_errors
     * const api_errors = await prisma.api_errors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends api_errorsUpdateManyArgs>(args: SelectSubset<T, api_errorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Api_errors and returns the data updated in the database.
     * @param {api_errorsUpdateManyAndReturnArgs} args - Arguments to update many Api_errors.
     * @example
     * // Update many Api_errors
     * const api_errors = await prisma.api_errors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Api_errors and only return the `id`
     * const api_errorsWithIdOnly = await prisma.api_errors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends api_errorsUpdateManyAndReturnArgs>(args: SelectSubset<T, api_errorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Api_errors.
     * @param {api_errorsUpsertArgs} args - Arguments to update or create a Api_errors.
     * @example
     * // Update or create a Api_errors
     * const api_errors = await prisma.api_errors.upsert({
     *   create: {
     *     // ... data to create a Api_errors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Api_errors we want to update
     *   }
     * })
     */
    upsert<T extends api_errorsUpsertArgs>(args: SelectSubset<T, api_errorsUpsertArgs<ExtArgs>>): Prisma__api_errorsClient<$Result.GetResult<Prisma.$api_errorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Api_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_errorsCountArgs} args - Arguments to filter Api_errors to count.
     * @example
     * // Count the number of Api_errors
     * const count = await prisma.api_errors.count({
     *   where: {
     *     // ... the filter for the Api_errors we want to count
     *   }
     * })
    **/
    count<T extends api_errorsCountArgs>(
      args?: Subset<T, api_errorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Api_errorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Api_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Api_errorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Api_errorsAggregateArgs>(args: Subset<T, Api_errorsAggregateArgs>): Prisma.PrismaPromise<GetApi_errorsAggregateType<T>>

    /**
     * Group by Api_errors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {api_errorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends api_errorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: api_errorsGroupByArgs['orderBy'] }
        : { orderBy?: api_errorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, api_errorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApi_errorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the api_errors model
   */
  readonly fields: api_errorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for api_errors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__api_errorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the api_errors model
   */
  interface api_errorsFieldRefs {
    readonly id: FieldRef<"api_errors", 'Int'>
    readonly dto: FieldRef<"api_errors", 'String'>
    readonly message: FieldRef<"api_errors", 'String'>
    readonly createdAt: FieldRef<"api_errors", 'DateTime'>
    readonly updatedAt: FieldRef<"api_errors", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * api_errors findUnique
   */
  export type api_errorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * Filter, which api_errors to fetch.
     */
    where: api_errorsWhereUniqueInput
  }

  /**
   * api_errors findUniqueOrThrow
   */
  export type api_errorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * Filter, which api_errors to fetch.
     */
    where: api_errorsWhereUniqueInput
  }

  /**
   * api_errors findFirst
   */
  export type api_errorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * Filter, which api_errors to fetch.
     */
    where?: api_errorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_errors to fetch.
     */
    orderBy?: api_errorsOrderByWithRelationInput | api_errorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_errors.
     */
    cursor?: api_errorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_errors.
     */
    distinct?: Api_errorsScalarFieldEnum | Api_errorsScalarFieldEnum[]
  }

  /**
   * api_errors findFirstOrThrow
   */
  export type api_errorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * Filter, which api_errors to fetch.
     */
    where?: api_errorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_errors to fetch.
     */
    orderBy?: api_errorsOrderByWithRelationInput | api_errorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for api_errors.
     */
    cursor?: api_errorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_errors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of api_errors.
     */
    distinct?: Api_errorsScalarFieldEnum | Api_errorsScalarFieldEnum[]
  }

  /**
   * api_errors findMany
   */
  export type api_errorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * Filter, which api_errors to fetch.
     */
    where?: api_errorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of api_errors to fetch.
     */
    orderBy?: api_errorsOrderByWithRelationInput | api_errorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing api_errors.
     */
    cursor?: api_errorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` api_errors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` api_errors.
     */
    skip?: number
    distinct?: Api_errorsScalarFieldEnum | Api_errorsScalarFieldEnum[]
  }

  /**
   * api_errors create
   */
  export type api_errorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * The data needed to create a api_errors.
     */
    data: XOR<api_errorsCreateInput, api_errorsUncheckedCreateInput>
  }

  /**
   * api_errors createMany
   */
  export type api_errorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many api_errors.
     */
    data: api_errorsCreateManyInput | api_errorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * api_errors createManyAndReturn
   */
  export type api_errorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * The data used to create many api_errors.
     */
    data: api_errorsCreateManyInput | api_errorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * api_errors update
   */
  export type api_errorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * The data needed to update a api_errors.
     */
    data: XOR<api_errorsUpdateInput, api_errorsUncheckedUpdateInput>
    /**
     * Choose, which api_errors to update.
     */
    where: api_errorsWhereUniqueInput
  }

  /**
   * api_errors updateMany
   */
  export type api_errorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update api_errors.
     */
    data: XOR<api_errorsUpdateManyMutationInput, api_errorsUncheckedUpdateManyInput>
    /**
     * Filter which api_errors to update
     */
    where?: api_errorsWhereInput
    /**
     * Limit how many api_errors to update.
     */
    limit?: number
  }

  /**
   * api_errors updateManyAndReturn
   */
  export type api_errorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * The data used to update api_errors.
     */
    data: XOR<api_errorsUpdateManyMutationInput, api_errorsUncheckedUpdateManyInput>
    /**
     * Filter which api_errors to update
     */
    where?: api_errorsWhereInput
    /**
     * Limit how many api_errors to update.
     */
    limit?: number
  }

  /**
   * api_errors upsert
   */
  export type api_errorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * The filter to search for the api_errors to update in case it exists.
     */
    where: api_errorsWhereUniqueInput
    /**
     * In case the api_errors found by the `where` argument doesn't exist, create a new api_errors with this data.
     */
    create: XOR<api_errorsCreateInput, api_errorsUncheckedCreateInput>
    /**
     * In case the api_errors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<api_errorsUpdateInput, api_errorsUncheckedUpdateInput>
  }

  /**
   * api_errors delete
   */
  export type api_errorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
    /**
     * Filter which api_errors to delete.
     */
    where: api_errorsWhereUniqueInput
  }

  /**
   * api_errors deleteMany
   */
  export type api_errorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which api_errors to delete
     */
    where?: api_errorsWhereInput
    /**
     * Limit how many api_errors to delete.
     */
    limit?: number
  }

  /**
   * api_errors without action
   */
  export type api_errorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the api_errors
     */
    select?: api_errorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the api_errors
     */
    omit?: api_errorsOmit<ExtArgs> | null
  }


  /**
   * Model apparatuses
   */

  export type AggregateApparatuses = {
    _count: ApparatusesCountAggregateOutputType | null
    _avg: ApparatusesAvgAggregateOutputType | null
    _sum: ApparatusesSumAggregateOutputType | null
    _min: ApparatusesMinAggregateOutputType | null
    _max: ApparatusesMaxAggregateOutputType | null
  }

  export type ApparatusesAvgAggregateOutputType = {
    id: number | null
  }

  export type ApparatusesSumAggregateOutputType = {
    id: number | null
  }

  export type ApparatusesMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type ApparatusesMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type ApparatusesCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type ApparatusesAvgAggregateInputType = {
    id?: true
  }

  export type ApparatusesSumAggregateInputType = {
    id?: true
  }

  export type ApparatusesMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type ApparatusesMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type ApparatusesCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type ApparatusesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apparatuses to aggregate.
     */
    where?: apparatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apparatuses to fetch.
     */
    orderBy?: apparatusesOrderByWithRelationInput | apparatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: apparatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apparatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apparatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned apparatuses
    **/
    _count?: true | ApparatusesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApparatusesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApparatusesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApparatusesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApparatusesMaxAggregateInputType
  }

  export type GetApparatusesAggregateType<T extends ApparatusesAggregateArgs> = {
        [P in keyof T & keyof AggregateApparatuses]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApparatuses[P]>
      : GetScalarType<T[P], AggregateApparatuses[P]>
  }




  export type apparatusesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: apparatusesWhereInput
    orderBy?: apparatusesOrderByWithAggregationInput | apparatusesOrderByWithAggregationInput[]
    by: ApparatusesScalarFieldEnum[] | ApparatusesScalarFieldEnum
    having?: apparatusesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApparatusesCountAggregateInputType | true
    _avg?: ApparatusesAvgAggregateInputType
    _sum?: ApparatusesSumAggregateInputType
    _min?: ApparatusesMinAggregateInputType
    _max?: ApparatusesMaxAggregateInputType
  }

  export type ApparatusesGroupByOutputType = {
    id: number
    value: string
    _count: ApparatusesCountAggregateOutputType | null
    _avg: ApparatusesAvgAggregateOutputType | null
    _sum: ApparatusesSumAggregateOutputType | null
    _min: ApparatusesMinAggregateOutputType | null
    _max: ApparatusesMaxAggregateOutputType | null
  }

  type GetApparatusesGroupByPayload<T extends apparatusesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApparatusesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApparatusesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApparatusesGroupByOutputType[P]>
            : GetScalarType<T[P], ApparatusesGroupByOutputType[P]>
        }
      >
    >


  export type apparatusesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    records?: boolean | apparatuses$recordsArgs<ExtArgs>
    _count?: boolean | ApparatusesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apparatuses"]>

  export type apparatusesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["apparatuses"]>

  export type apparatusesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["apparatuses"]>

  export type apparatusesSelectScalar = {
    id?: boolean
    value?: boolean
  }

  export type apparatusesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value", ExtArgs["result"]["apparatuses"]>
  export type apparatusesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | apparatuses$recordsArgs<ExtArgs>
    _count?: boolean | ApparatusesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type apparatusesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type apparatusesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $apparatusesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "apparatuses"
    objects: {
      records: Prisma.$recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
    }, ExtArgs["result"]["apparatuses"]>
    composites: {}
  }

  type apparatusesGetPayload<S extends boolean | null | undefined | apparatusesDefaultArgs> = $Result.GetResult<Prisma.$apparatusesPayload, S>

  type apparatusesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<apparatusesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApparatusesCountAggregateInputType | true
    }

  export interface apparatusesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['apparatuses'], meta: { name: 'apparatuses' } }
    /**
     * Find zero or one Apparatuses that matches the filter.
     * @param {apparatusesFindUniqueArgs} args - Arguments to find a Apparatuses
     * @example
     * // Get one Apparatuses
     * const apparatuses = await prisma.apparatuses.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends apparatusesFindUniqueArgs>(args: SelectSubset<T, apparatusesFindUniqueArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Apparatuses that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {apparatusesFindUniqueOrThrowArgs} args - Arguments to find a Apparatuses
     * @example
     * // Get one Apparatuses
     * const apparatuses = await prisma.apparatuses.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends apparatusesFindUniqueOrThrowArgs>(args: SelectSubset<T, apparatusesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apparatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apparatusesFindFirstArgs} args - Arguments to find a Apparatuses
     * @example
     * // Get one Apparatuses
     * const apparatuses = await prisma.apparatuses.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends apparatusesFindFirstArgs>(args?: SelectSubset<T, apparatusesFindFirstArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Apparatuses that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apparatusesFindFirstOrThrowArgs} args - Arguments to find a Apparatuses
     * @example
     * // Get one Apparatuses
     * const apparatuses = await prisma.apparatuses.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends apparatusesFindFirstOrThrowArgs>(args?: SelectSubset<T, apparatusesFindFirstOrThrowArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apparatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apparatusesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apparatuses
     * const apparatuses = await prisma.apparatuses.findMany()
     * 
     * // Get first 10 Apparatuses
     * const apparatuses = await prisma.apparatuses.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apparatusesWithIdOnly = await prisma.apparatuses.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends apparatusesFindManyArgs>(args?: SelectSubset<T, apparatusesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Apparatuses.
     * @param {apparatusesCreateArgs} args - Arguments to create a Apparatuses.
     * @example
     * // Create one Apparatuses
     * const Apparatuses = await prisma.apparatuses.create({
     *   data: {
     *     // ... data to create a Apparatuses
     *   }
     * })
     * 
     */
    create<T extends apparatusesCreateArgs>(args: SelectSubset<T, apparatusesCreateArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apparatuses.
     * @param {apparatusesCreateManyArgs} args - Arguments to create many Apparatuses.
     * @example
     * // Create many Apparatuses
     * const apparatuses = await prisma.apparatuses.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends apparatusesCreateManyArgs>(args?: SelectSubset<T, apparatusesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Apparatuses and returns the data saved in the database.
     * @param {apparatusesCreateManyAndReturnArgs} args - Arguments to create many Apparatuses.
     * @example
     * // Create many Apparatuses
     * const apparatuses = await prisma.apparatuses.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Apparatuses and only return the `id`
     * const apparatusesWithIdOnly = await prisma.apparatuses.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends apparatusesCreateManyAndReturnArgs>(args?: SelectSubset<T, apparatusesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Apparatuses.
     * @param {apparatusesDeleteArgs} args - Arguments to delete one Apparatuses.
     * @example
     * // Delete one Apparatuses
     * const Apparatuses = await prisma.apparatuses.delete({
     *   where: {
     *     // ... filter to delete one Apparatuses
     *   }
     * })
     * 
     */
    delete<T extends apparatusesDeleteArgs>(args: SelectSubset<T, apparatusesDeleteArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Apparatuses.
     * @param {apparatusesUpdateArgs} args - Arguments to update one Apparatuses.
     * @example
     * // Update one Apparatuses
     * const apparatuses = await prisma.apparatuses.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends apparatusesUpdateArgs>(args: SelectSubset<T, apparatusesUpdateArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apparatuses.
     * @param {apparatusesDeleteManyArgs} args - Arguments to filter Apparatuses to delete.
     * @example
     * // Delete a few Apparatuses
     * const { count } = await prisma.apparatuses.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends apparatusesDeleteManyArgs>(args?: SelectSubset<T, apparatusesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apparatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apparatusesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apparatuses
     * const apparatuses = await prisma.apparatuses.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends apparatusesUpdateManyArgs>(args: SelectSubset<T, apparatusesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apparatuses and returns the data updated in the database.
     * @param {apparatusesUpdateManyAndReturnArgs} args - Arguments to update many Apparatuses.
     * @example
     * // Update many Apparatuses
     * const apparatuses = await prisma.apparatuses.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Apparatuses and only return the `id`
     * const apparatusesWithIdOnly = await prisma.apparatuses.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends apparatusesUpdateManyAndReturnArgs>(args: SelectSubset<T, apparatusesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Apparatuses.
     * @param {apparatusesUpsertArgs} args - Arguments to update or create a Apparatuses.
     * @example
     * // Update or create a Apparatuses
     * const apparatuses = await prisma.apparatuses.upsert({
     *   create: {
     *     // ... data to create a Apparatuses
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apparatuses we want to update
     *   }
     * })
     */
    upsert<T extends apparatusesUpsertArgs>(args: SelectSubset<T, apparatusesUpsertArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apparatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apparatusesCountArgs} args - Arguments to filter Apparatuses to count.
     * @example
     * // Count the number of Apparatuses
     * const count = await prisma.apparatuses.count({
     *   where: {
     *     // ... the filter for the Apparatuses we want to count
     *   }
     * })
    **/
    count<T extends apparatusesCountArgs>(
      args?: Subset<T, apparatusesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApparatusesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apparatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApparatusesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApparatusesAggregateArgs>(args: Subset<T, ApparatusesAggregateArgs>): Prisma.PrismaPromise<GetApparatusesAggregateType<T>>

    /**
     * Group by Apparatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {apparatusesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends apparatusesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: apparatusesGroupByArgs['orderBy'] }
        : { orderBy?: apparatusesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, apparatusesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApparatusesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the apparatuses model
   */
  readonly fields: apparatusesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for apparatuses.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__apparatusesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    records<T extends apparatuses$recordsArgs<ExtArgs> = {}>(args?: Subset<T, apparatuses$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the apparatuses model
   */
  interface apparatusesFieldRefs {
    readonly id: FieldRef<"apparatuses", 'Int'>
    readonly value: FieldRef<"apparatuses", 'String'>
  }
    

  // Custom InputTypes
  /**
   * apparatuses findUnique
   */
  export type apparatusesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * Filter, which apparatuses to fetch.
     */
    where: apparatusesWhereUniqueInput
  }

  /**
   * apparatuses findUniqueOrThrow
   */
  export type apparatusesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * Filter, which apparatuses to fetch.
     */
    where: apparatusesWhereUniqueInput
  }

  /**
   * apparatuses findFirst
   */
  export type apparatusesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * Filter, which apparatuses to fetch.
     */
    where?: apparatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apparatuses to fetch.
     */
    orderBy?: apparatusesOrderByWithRelationInput | apparatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apparatuses.
     */
    cursor?: apparatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apparatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apparatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apparatuses.
     */
    distinct?: ApparatusesScalarFieldEnum | ApparatusesScalarFieldEnum[]
  }

  /**
   * apparatuses findFirstOrThrow
   */
  export type apparatusesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * Filter, which apparatuses to fetch.
     */
    where?: apparatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apparatuses to fetch.
     */
    orderBy?: apparatusesOrderByWithRelationInput | apparatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for apparatuses.
     */
    cursor?: apparatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apparatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apparatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of apparatuses.
     */
    distinct?: ApparatusesScalarFieldEnum | ApparatusesScalarFieldEnum[]
  }

  /**
   * apparatuses findMany
   */
  export type apparatusesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * Filter, which apparatuses to fetch.
     */
    where?: apparatusesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of apparatuses to fetch.
     */
    orderBy?: apparatusesOrderByWithRelationInput | apparatusesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing apparatuses.
     */
    cursor?: apparatusesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` apparatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` apparatuses.
     */
    skip?: number
    distinct?: ApparatusesScalarFieldEnum | ApparatusesScalarFieldEnum[]
  }

  /**
   * apparatuses create
   */
  export type apparatusesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * The data needed to create a apparatuses.
     */
    data: XOR<apparatusesCreateInput, apparatusesUncheckedCreateInput>
  }

  /**
   * apparatuses createMany
   */
  export type apparatusesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many apparatuses.
     */
    data: apparatusesCreateManyInput | apparatusesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apparatuses createManyAndReturn
   */
  export type apparatusesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * The data used to create many apparatuses.
     */
    data: apparatusesCreateManyInput | apparatusesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * apparatuses update
   */
  export type apparatusesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * The data needed to update a apparatuses.
     */
    data: XOR<apparatusesUpdateInput, apparatusesUncheckedUpdateInput>
    /**
     * Choose, which apparatuses to update.
     */
    where: apparatusesWhereUniqueInput
  }

  /**
   * apparatuses updateMany
   */
  export type apparatusesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update apparatuses.
     */
    data: XOR<apparatusesUpdateManyMutationInput, apparatusesUncheckedUpdateManyInput>
    /**
     * Filter which apparatuses to update
     */
    where?: apparatusesWhereInput
    /**
     * Limit how many apparatuses to update.
     */
    limit?: number
  }

  /**
   * apparatuses updateManyAndReturn
   */
  export type apparatusesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * The data used to update apparatuses.
     */
    data: XOR<apparatusesUpdateManyMutationInput, apparatusesUncheckedUpdateManyInput>
    /**
     * Filter which apparatuses to update
     */
    where?: apparatusesWhereInput
    /**
     * Limit how many apparatuses to update.
     */
    limit?: number
  }

  /**
   * apparatuses upsert
   */
  export type apparatusesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * The filter to search for the apparatuses to update in case it exists.
     */
    where: apparatusesWhereUniqueInput
    /**
     * In case the apparatuses found by the `where` argument doesn't exist, create a new apparatuses with this data.
     */
    create: XOR<apparatusesCreateInput, apparatusesUncheckedCreateInput>
    /**
     * In case the apparatuses was found with the provided `where` argument, update it with this data.
     */
    update: XOR<apparatusesUpdateInput, apparatusesUncheckedUpdateInput>
  }

  /**
   * apparatuses delete
   */
  export type apparatusesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    /**
     * Filter which apparatuses to delete.
     */
    where: apparatusesWhereUniqueInput
  }

  /**
   * apparatuses deleteMany
   */
  export type apparatusesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which apparatuses to delete
     */
    where?: apparatusesWhereInput
    /**
     * Limit how many apparatuses to delete.
     */
    limit?: number
  }

  /**
   * apparatuses.records
   */
  export type apparatuses$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    cursor?: recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * apparatuses without action
   */
  export type apparatusesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
  }


  /**
   * Model bases
   */

  export type AggregateBases = {
    _count: BasesCountAggregateOutputType | null
    _avg: BasesAvgAggregateOutputType | null
    _sum: BasesSumAggregateOutputType | null
    _min: BasesMinAggregateOutputType | null
    _max: BasesMaxAggregateOutputType | null
  }

  export type BasesAvgAggregateOutputType = {
    id: number | null
  }

  export type BasesSumAggregateOutputType = {
    id: number | null
  }

  export type BasesMinAggregateOutputType = {
    id: number | null
    code: string | null
    marking: string | null
  }

  export type BasesMaxAggregateOutputType = {
    id: number | null
    code: string | null
    marking: string | null
  }

  export type BasesCountAggregateOutputType = {
    id: number
    code: number
    marking: number
    _all: number
  }


  export type BasesAvgAggregateInputType = {
    id?: true
  }

  export type BasesSumAggregateInputType = {
    id?: true
  }

  export type BasesMinAggregateInputType = {
    id?: true
    code?: true
    marking?: true
  }

  export type BasesMaxAggregateInputType = {
    id?: true
    code?: true
    marking?: true
  }

  export type BasesCountAggregateInputType = {
    id?: true
    code?: true
    marking?: true
    _all?: true
  }

  export type BasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bases to aggregate.
     */
    where?: basesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bases to fetch.
     */
    orderBy?: basesOrderByWithRelationInput | basesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: basesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bases
    **/
    _count?: true | BasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BasesMaxAggregateInputType
  }

  export type GetBasesAggregateType<T extends BasesAggregateArgs> = {
        [P in keyof T & keyof AggregateBases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBases[P]>
      : GetScalarType<T[P], AggregateBases[P]>
  }




  export type basesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: basesWhereInput
    orderBy?: basesOrderByWithAggregationInput | basesOrderByWithAggregationInput[]
    by: BasesScalarFieldEnum[] | BasesScalarFieldEnum
    having?: basesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BasesCountAggregateInputType | true
    _avg?: BasesAvgAggregateInputType
    _sum?: BasesSumAggregateInputType
    _min?: BasesMinAggregateInputType
    _max?: BasesMaxAggregateInputType
  }

  export type BasesGroupByOutputType = {
    id: number
    code: string
    marking: string | null
    _count: BasesCountAggregateOutputType | null
    _avg: BasesAvgAggregateOutputType | null
    _sum: BasesSumAggregateOutputType | null
    _min: BasesMinAggregateOutputType | null
    _max: BasesMaxAggregateOutputType | null
  }

  type GetBasesGroupByPayload<T extends basesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BasesGroupByOutputType[P]>
            : GetScalarType<T[P], BasesGroupByOutputType[P]>
        }
      >
    >


  export type basesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    marking?: boolean
    boils?: boolean | bases$boilsArgs<ExtArgs>
    _count?: boolean | BasesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bases"]>

  export type basesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    marking?: boolean
  }, ExtArgs["result"]["bases"]>

  export type basesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    marking?: boolean
  }, ExtArgs["result"]["bases"]>

  export type basesSelectScalar = {
    id?: boolean
    code?: boolean
    marking?: boolean
  }

  export type basesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "marking", ExtArgs["result"]["bases"]>
  export type basesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | bases$boilsArgs<ExtArgs>
    _count?: boolean | BasesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type basesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type basesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $basesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bases"
    objects: {
      boils: Prisma.$boilsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      marking: string | null
    }, ExtArgs["result"]["bases"]>
    composites: {}
  }

  type basesGetPayload<S extends boolean | null | undefined | basesDefaultArgs> = $Result.GetResult<Prisma.$basesPayload, S>

  type basesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<basesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BasesCountAggregateInputType | true
    }

  export interface basesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bases'], meta: { name: 'bases' } }
    /**
     * Find zero or one Bases that matches the filter.
     * @param {basesFindUniqueArgs} args - Arguments to find a Bases
     * @example
     * // Get one Bases
     * const bases = await prisma.bases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends basesFindUniqueArgs>(args: SelectSubset<T, basesFindUniqueArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {basesFindUniqueOrThrowArgs} args - Arguments to find a Bases
     * @example
     * // Get one Bases
     * const bases = await prisma.bases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends basesFindUniqueOrThrowArgs>(args: SelectSubset<T, basesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basesFindFirstArgs} args - Arguments to find a Bases
     * @example
     * // Get one Bases
     * const bases = await prisma.bases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends basesFindFirstArgs>(args?: SelectSubset<T, basesFindFirstArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basesFindFirstOrThrowArgs} args - Arguments to find a Bases
     * @example
     * // Get one Bases
     * const bases = await prisma.bases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends basesFindFirstOrThrowArgs>(args?: SelectSubset<T, basesFindFirstOrThrowArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bases
     * const bases = await prisma.bases.findMany()
     * 
     * // Get first 10 Bases
     * const bases = await prisma.bases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const basesWithIdOnly = await prisma.bases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends basesFindManyArgs>(args?: SelectSubset<T, basesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bases.
     * @param {basesCreateArgs} args - Arguments to create a Bases.
     * @example
     * // Create one Bases
     * const Bases = await prisma.bases.create({
     *   data: {
     *     // ... data to create a Bases
     *   }
     * })
     * 
     */
    create<T extends basesCreateArgs>(args: SelectSubset<T, basesCreateArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bases.
     * @param {basesCreateManyArgs} args - Arguments to create many Bases.
     * @example
     * // Create many Bases
     * const bases = await prisma.bases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends basesCreateManyArgs>(args?: SelectSubset<T, basesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bases and returns the data saved in the database.
     * @param {basesCreateManyAndReturnArgs} args - Arguments to create many Bases.
     * @example
     * // Create many Bases
     * const bases = await prisma.bases.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bases and only return the `id`
     * const basesWithIdOnly = await prisma.bases.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends basesCreateManyAndReturnArgs>(args?: SelectSubset<T, basesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bases.
     * @param {basesDeleteArgs} args - Arguments to delete one Bases.
     * @example
     * // Delete one Bases
     * const Bases = await prisma.bases.delete({
     *   where: {
     *     // ... filter to delete one Bases
     *   }
     * })
     * 
     */
    delete<T extends basesDeleteArgs>(args: SelectSubset<T, basesDeleteArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bases.
     * @param {basesUpdateArgs} args - Arguments to update one Bases.
     * @example
     * // Update one Bases
     * const bases = await prisma.bases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends basesUpdateArgs>(args: SelectSubset<T, basesUpdateArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bases.
     * @param {basesDeleteManyArgs} args - Arguments to filter Bases to delete.
     * @example
     * // Delete a few Bases
     * const { count } = await prisma.bases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends basesDeleteManyArgs>(args?: SelectSubset<T, basesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bases
     * const bases = await prisma.bases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends basesUpdateManyArgs>(args: SelectSubset<T, basesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bases and returns the data updated in the database.
     * @param {basesUpdateManyAndReturnArgs} args - Arguments to update many Bases.
     * @example
     * // Update many Bases
     * const bases = await prisma.bases.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bases and only return the `id`
     * const basesWithIdOnly = await prisma.bases.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends basesUpdateManyAndReturnArgs>(args: SelectSubset<T, basesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bases.
     * @param {basesUpsertArgs} args - Arguments to update or create a Bases.
     * @example
     * // Update or create a Bases
     * const bases = await prisma.bases.upsert({
     *   create: {
     *     // ... data to create a Bases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bases we want to update
     *   }
     * })
     */
    upsert<T extends basesUpsertArgs>(args: SelectSubset<T, basesUpsertArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basesCountArgs} args - Arguments to filter Bases to count.
     * @example
     * // Count the number of Bases
     * const count = await prisma.bases.count({
     *   where: {
     *     // ... the filter for the Bases we want to count
     *   }
     * })
    **/
    count<T extends basesCountArgs>(
      args?: Subset<T, basesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BasesAggregateArgs>(args: Subset<T, BasesAggregateArgs>): Prisma.PrismaPromise<GetBasesAggregateType<T>>

    /**
     * Group by Bases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends basesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: basesGroupByArgs['orderBy'] }
        : { orderBy?: basesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, basesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bases model
   */
  readonly fields: basesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__basesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boils<T extends bases$boilsArgs<ExtArgs> = {}>(args?: Subset<T, bases$boilsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bases model
   */
  interface basesFieldRefs {
    readonly id: FieldRef<"bases", 'Int'>
    readonly code: FieldRef<"bases", 'String'>
    readonly marking: FieldRef<"bases", 'String'>
  }
    

  // Custom InputTypes
  /**
   * bases findUnique
   */
  export type basesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * Filter, which bases to fetch.
     */
    where: basesWhereUniqueInput
  }

  /**
   * bases findUniqueOrThrow
   */
  export type basesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * Filter, which bases to fetch.
     */
    where: basesWhereUniqueInput
  }

  /**
   * bases findFirst
   */
  export type basesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * Filter, which bases to fetch.
     */
    where?: basesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bases to fetch.
     */
    orderBy?: basesOrderByWithRelationInput | basesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bases.
     */
    cursor?: basesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bases.
     */
    distinct?: BasesScalarFieldEnum | BasesScalarFieldEnum[]
  }

  /**
   * bases findFirstOrThrow
   */
  export type basesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * Filter, which bases to fetch.
     */
    where?: basesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bases to fetch.
     */
    orderBy?: basesOrderByWithRelationInput | basesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bases.
     */
    cursor?: basesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bases.
     */
    distinct?: BasesScalarFieldEnum | BasesScalarFieldEnum[]
  }

  /**
   * bases findMany
   */
  export type basesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * Filter, which bases to fetch.
     */
    where?: basesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bases to fetch.
     */
    orderBy?: basesOrderByWithRelationInput | basesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bases.
     */
    cursor?: basesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bases.
     */
    skip?: number
    distinct?: BasesScalarFieldEnum | BasesScalarFieldEnum[]
  }

  /**
   * bases create
   */
  export type basesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * The data needed to create a bases.
     */
    data: XOR<basesCreateInput, basesUncheckedCreateInput>
  }

  /**
   * bases createMany
   */
  export type basesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bases.
     */
    data: basesCreateManyInput | basesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bases createManyAndReturn
   */
  export type basesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * The data used to create many bases.
     */
    data: basesCreateManyInput | basesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * bases update
   */
  export type basesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * The data needed to update a bases.
     */
    data: XOR<basesUpdateInput, basesUncheckedUpdateInput>
    /**
     * Choose, which bases to update.
     */
    where: basesWhereUniqueInput
  }

  /**
   * bases updateMany
   */
  export type basesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bases.
     */
    data: XOR<basesUpdateManyMutationInput, basesUncheckedUpdateManyInput>
    /**
     * Filter which bases to update
     */
    where?: basesWhereInput
    /**
     * Limit how many bases to update.
     */
    limit?: number
  }

  /**
   * bases updateManyAndReturn
   */
  export type basesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * The data used to update bases.
     */
    data: XOR<basesUpdateManyMutationInput, basesUncheckedUpdateManyInput>
    /**
     * Filter which bases to update
     */
    where?: basesWhereInput
    /**
     * Limit how many bases to update.
     */
    limit?: number
  }

  /**
   * bases upsert
   */
  export type basesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * The filter to search for the bases to update in case it exists.
     */
    where: basesWhereUniqueInput
    /**
     * In case the bases found by the `where` argument doesn't exist, create a new bases with this data.
     */
    create: XOR<basesCreateInput, basesUncheckedCreateInput>
    /**
     * In case the bases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<basesUpdateInput, basesUncheckedUpdateInput>
  }

  /**
   * bases delete
   */
  export type basesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    /**
     * Filter which bases to delete.
     */
    where: basesWhereUniqueInput
  }

  /**
   * bases deleteMany
   */
  export type basesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bases to delete
     */
    where?: basesWhereInput
    /**
     * Limit how many bases to delete.
     */
    limit?: number
  }

  /**
   * bases.boils
   */
  export type bases$boilsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    where?: boilsWhereInput
    orderBy?: boilsOrderByWithRelationInput | boilsOrderByWithRelationInput[]
    cursor?: boilsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BoilsScalarFieldEnum | BoilsScalarFieldEnum[]
  }

  /**
   * bases without action
   */
  export type basesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
  }


  /**
   * Model batchs
   */

  export type AggregateBatchs = {
    _count: BatchsCountAggregateOutputType | null
    _avg: BatchsAvgAggregateOutputType | null
    _sum: BatchsSumAggregateOutputType | null
    _min: BatchsMinAggregateOutputType | null
    _max: BatchsMaxAggregateOutputType | null
  }

  export type BatchsAvgAggregateOutputType = {
    BatchPK: number | null
  }

  export type BatchsSumAggregateOutputType = {
    BatchPK: number | null
  }

  export type BatchsMinAggregateOutputType = {
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchsMaxAggregateOutputType = {
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BatchsCountAggregateOutputType = {
    BatchPK: number
    BatchName: number
    BatchDate: number
    Plant: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BatchsAvgAggregateInputType = {
    BatchPK?: true
  }

  export type BatchsSumAggregateInputType = {
    BatchPK?: true
  }

  export type BatchsMinAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchsMaxAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BatchsCountAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BatchsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which batchs to aggregate.
     */
    where?: batchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batchs to fetch.
     */
    orderBy?: batchsOrderByWithRelationInput | batchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: batchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned batchs
    **/
    _count?: true | BatchsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BatchsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BatchsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BatchsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BatchsMaxAggregateInputType
  }

  export type GetBatchsAggregateType<T extends BatchsAggregateArgs> = {
        [P in keyof T & keyof AggregateBatchs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBatchs[P]>
      : GetScalarType<T[P], AggregateBatchs[P]>
  }




  export type batchsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: batchsWhereInput
    orderBy?: batchsOrderByWithAggregationInput | batchsOrderByWithAggregationInput[]
    by: BatchsScalarFieldEnum[] | BatchsScalarFieldEnum
    having?: batchsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BatchsCountAggregateInputType | true
    _avg?: BatchsAvgAggregateInputType
    _sum?: BatchsSumAggregateInputType
    _min?: BatchsMinAggregateInputType
    _max?: BatchsMaxAggregateInputType
  }

  export type BatchsGroupByOutputType = {
    BatchPK: number
    BatchName: string
    BatchDate: Date | null
    Plant: string
    createdAt: Date
    updatedAt: Date
    _count: BatchsCountAggregateOutputType | null
    _avg: BatchsAvgAggregateOutputType | null
    _sum: BatchsSumAggregateOutputType | null
    _min: BatchsMinAggregateOutputType | null
    _max: BatchsMaxAggregateOutputType | null
  }

  type GetBatchsGroupByPayload<T extends batchsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BatchsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BatchsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BatchsGroupByOutputType[P]>
            : GetScalarType<T[P], BatchsGroupByOutputType[P]>
        }
      >
    >


  export type batchsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchs"]>

  export type batchsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchs"]>

  export type batchsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["batchs"]>

  export type batchsSelectScalar = {
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type batchsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"BatchPK" | "BatchName" | "BatchDate" | "Plant" | "createdAt" | "updatedAt", ExtArgs["result"]["batchs"]>

  export type $batchsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "batchs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      BatchPK: number
      BatchName: string
      BatchDate: Date | null
      Plant: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["batchs"]>
    composites: {}
  }

  type batchsGetPayload<S extends boolean | null | undefined | batchsDefaultArgs> = $Result.GetResult<Prisma.$batchsPayload, S>

  type batchsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<batchsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BatchsCountAggregateInputType | true
    }

  export interface batchsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['batchs'], meta: { name: 'batchs' } }
    /**
     * Find zero or one Batchs that matches the filter.
     * @param {batchsFindUniqueArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends batchsFindUniqueArgs>(args: SelectSubset<T, batchsFindUniqueArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Batchs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {batchsFindUniqueOrThrowArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends batchsFindUniqueOrThrowArgs>(args: SelectSubset<T, batchsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchsFindFirstArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends batchsFindFirstArgs>(args?: SelectSubset<T, batchsFindFirstArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Batchs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchsFindFirstOrThrowArgs} args - Arguments to find a Batchs
     * @example
     * // Get one Batchs
     * const batchs = await prisma.batchs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends batchsFindFirstOrThrowArgs>(args?: SelectSubset<T, batchsFindFirstOrThrowArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Batchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Batchs
     * const batchs = await prisma.batchs.findMany()
     * 
     * // Get first 10 Batchs
     * const batchs = await prisma.batchs.findMany({ take: 10 })
     * 
     * // Only select the `BatchPK`
     * const batchsWithBatchPKOnly = await prisma.batchs.findMany({ select: { BatchPK: true } })
     * 
     */
    findMany<T extends batchsFindManyArgs>(args?: SelectSubset<T, batchsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Batchs.
     * @param {batchsCreateArgs} args - Arguments to create a Batchs.
     * @example
     * // Create one Batchs
     * const Batchs = await prisma.batchs.create({
     *   data: {
     *     // ... data to create a Batchs
     *   }
     * })
     * 
     */
    create<T extends batchsCreateArgs>(args: SelectSubset<T, batchsCreateArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Batchs.
     * @param {batchsCreateManyArgs} args - Arguments to create many Batchs.
     * @example
     * // Create many Batchs
     * const batchs = await prisma.batchs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends batchsCreateManyArgs>(args?: SelectSubset<T, batchsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Batchs and returns the data saved in the database.
     * @param {batchsCreateManyAndReturnArgs} args - Arguments to create many Batchs.
     * @example
     * // Create many Batchs
     * const batchs = await prisma.batchs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Batchs and only return the `BatchPK`
     * const batchsWithBatchPKOnly = await prisma.batchs.createManyAndReturn({
     *   select: { BatchPK: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends batchsCreateManyAndReturnArgs>(args?: SelectSubset<T, batchsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Batchs.
     * @param {batchsDeleteArgs} args - Arguments to delete one Batchs.
     * @example
     * // Delete one Batchs
     * const Batchs = await prisma.batchs.delete({
     *   where: {
     *     // ... filter to delete one Batchs
     *   }
     * })
     * 
     */
    delete<T extends batchsDeleteArgs>(args: SelectSubset<T, batchsDeleteArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Batchs.
     * @param {batchsUpdateArgs} args - Arguments to update one Batchs.
     * @example
     * // Update one Batchs
     * const batchs = await prisma.batchs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends batchsUpdateArgs>(args: SelectSubset<T, batchsUpdateArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Batchs.
     * @param {batchsDeleteManyArgs} args - Arguments to filter Batchs to delete.
     * @example
     * // Delete a few Batchs
     * const { count } = await prisma.batchs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends batchsDeleteManyArgs>(args?: SelectSubset<T, batchsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Batchs
     * const batchs = await prisma.batchs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends batchsUpdateManyArgs>(args: SelectSubset<T, batchsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Batchs and returns the data updated in the database.
     * @param {batchsUpdateManyAndReturnArgs} args - Arguments to update many Batchs.
     * @example
     * // Update many Batchs
     * const batchs = await prisma.batchs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Batchs and only return the `BatchPK`
     * const batchsWithBatchPKOnly = await prisma.batchs.updateManyAndReturn({
     *   select: { BatchPK: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends batchsUpdateManyAndReturnArgs>(args: SelectSubset<T, batchsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Batchs.
     * @param {batchsUpsertArgs} args - Arguments to update or create a Batchs.
     * @example
     * // Update or create a Batchs
     * const batchs = await prisma.batchs.upsert({
     *   create: {
     *     // ... data to create a Batchs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Batchs we want to update
     *   }
     * })
     */
    upsert<T extends batchsUpsertArgs>(args: SelectSubset<T, batchsUpsertArgs<ExtArgs>>): Prisma__batchsClient<$Result.GetResult<Prisma.$batchsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchsCountArgs} args - Arguments to filter Batchs to count.
     * @example
     * // Count the number of Batchs
     * const count = await prisma.batchs.count({
     *   where: {
     *     // ... the filter for the Batchs we want to count
     *   }
     * })
    **/
    count<T extends batchsCountArgs>(
      args?: Subset<T, batchsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BatchsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BatchsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BatchsAggregateArgs>(args: Subset<T, BatchsAggregateArgs>): Prisma.PrismaPromise<GetBatchsAggregateType<T>>

    /**
     * Group by Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {batchsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends batchsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: batchsGroupByArgs['orderBy'] }
        : { orderBy?: batchsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, batchsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBatchsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the batchs model
   */
  readonly fields: batchsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for batchs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__batchsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the batchs model
   */
  interface batchsFieldRefs {
    readonly BatchPK: FieldRef<"batchs", 'Int'>
    readonly BatchName: FieldRef<"batchs", 'String'>
    readonly BatchDate: FieldRef<"batchs", 'DateTime'>
    readonly Plant: FieldRef<"batchs", 'String'>
    readonly createdAt: FieldRef<"batchs", 'DateTime'>
    readonly updatedAt: FieldRef<"batchs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * batchs findUnique
   */
  export type batchsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * Filter, which batchs to fetch.
     */
    where: batchsWhereUniqueInput
  }

  /**
   * batchs findUniqueOrThrow
   */
  export type batchsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * Filter, which batchs to fetch.
     */
    where: batchsWhereUniqueInput
  }

  /**
   * batchs findFirst
   */
  export type batchsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * Filter, which batchs to fetch.
     */
    where?: batchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batchs to fetch.
     */
    orderBy?: batchsOrderByWithRelationInput | batchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for batchs.
     */
    cursor?: batchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of batchs.
     */
    distinct?: BatchsScalarFieldEnum | BatchsScalarFieldEnum[]
  }

  /**
   * batchs findFirstOrThrow
   */
  export type batchsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * Filter, which batchs to fetch.
     */
    where?: batchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batchs to fetch.
     */
    orderBy?: batchsOrderByWithRelationInput | batchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for batchs.
     */
    cursor?: batchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of batchs.
     */
    distinct?: BatchsScalarFieldEnum | BatchsScalarFieldEnum[]
  }

  /**
   * batchs findMany
   */
  export type batchsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * Filter, which batchs to fetch.
     */
    where?: batchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of batchs to fetch.
     */
    orderBy?: batchsOrderByWithRelationInput | batchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing batchs.
     */
    cursor?: batchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` batchs.
     */
    skip?: number
    distinct?: BatchsScalarFieldEnum | BatchsScalarFieldEnum[]
  }

  /**
   * batchs create
   */
  export type batchsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * The data needed to create a batchs.
     */
    data: XOR<batchsCreateInput, batchsUncheckedCreateInput>
  }

  /**
   * batchs createMany
   */
  export type batchsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many batchs.
     */
    data: batchsCreateManyInput | batchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * batchs createManyAndReturn
   */
  export type batchsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * The data used to create many batchs.
     */
    data: batchsCreateManyInput | batchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * batchs update
   */
  export type batchsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * The data needed to update a batchs.
     */
    data: XOR<batchsUpdateInput, batchsUncheckedUpdateInput>
    /**
     * Choose, which batchs to update.
     */
    where: batchsWhereUniqueInput
  }

  /**
   * batchs updateMany
   */
  export type batchsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update batchs.
     */
    data: XOR<batchsUpdateManyMutationInput, batchsUncheckedUpdateManyInput>
    /**
     * Filter which batchs to update
     */
    where?: batchsWhereInput
    /**
     * Limit how many batchs to update.
     */
    limit?: number
  }

  /**
   * batchs updateManyAndReturn
   */
  export type batchsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * The data used to update batchs.
     */
    data: XOR<batchsUpdateManyMutationInput, batchsUncheckedUpdateManyInput>
    /**
     * Filter which batchs to update
     */
    where?: batchsWhereInput
    /**
     * Limit how many batchs to update.
     */
    limit?: number
  }

  /**
   * batchs upsert
   */
  export type batchsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * The filter to search for the batchs to update in case it exists.
     */
    where: batchsWhereUniqueInput
    /**
     * In case the batchs found by the `where` argument doesn't exist, create a new batchs with this data.
     */
    create: XOR<batchsCreateInput, batchsUncheckedCreateInput>
    /**
     * In case the batchs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<batchsUpdateInput, batchsUncheckedUpdateInput>
  }

  /**
   * batchs delete
   */
  export type batchsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
    /**
     * Filter which batchs to delete.
     */
    where: batchsWhereUniqueInput
  }

  /**
   * batchs deleteMany
   */
  export type batchsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which batchs to delete
     */
    where?: batchsWhereInput
    /**
     * Limit how many batchs to delete.
     */
    limit?: number
  }

  /**
   * batchs without action
   */
  export type batchsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the batchs
     */
    select?: batchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the batchs
     */
    omit?: batchsOmit<ExtArgs> | null
  }


  /**
   * Model boils
   */

  export type AggregateBoils = {
    _count: BoilsCountAggregateOutputType | null
    _avg: BoilsAvgAggregateOutputType | null
    _sum: BoilsSumAggregateOutputType | null
    _min: BoilsMinAggregateOutputType | null
    _max: BoilsMaxAggregateOutputType | null
  }

  export type BoilsAvgAggregateOutputType = {
    id: number | null
    base_id: number | null
    year: Decimal | null
    number: Decimal | null
    plant_id: number | null
  }

  export type BoilsSumAggregateOutputType = {
    id: number | null
    base_id: number | null
    year: Decimal | null
    number: Decimal | null
    plant_id: number | null
  }

  export type BoilsMinAggregateOutputType = {
    id: number | null
    value: string | null
    base_id: number | null
    letter: string | null
    year: Decimal | null
    number: Decimal | null
    plant_id: number | null
  }

  export type BoilsMaxAggregateOutputType = {
    id: number | null
    value: string | null
    base_id: number | null
    letter: string | null
    year: Decimal | null
    number: Decimal | null
    plant_id: number | null
  }

  export type BoilsCountAggregateOutputType = {
    id: number
    value: number
    base_id: number
    letter: number
    year: number
    number: number
    plant_id: number
    _all: number
  }


  export type BoilsAvgAggregateInputType = {
    id?: true
    base_id?: true
    year?: true
    number?: true
    plant_id?: true
  }

  export type BoilsSumAggregateInputType = {
    id?: true
    base_id?: true
    year?: true
    number?: true
    plant_id?: true
  }

  export type BoilsMinAggregateInputType = {
    id?: true
    value?: true
    base_id?: true
    letter?: true
    year?: true
    number?: true
    plant_id?: true
  }

  export type BoilsMaxAggregateInputType = {
    id?: true
    value?: true
    base_id?: true
    letter?: true
    year?: true
    number?: true
    plant_id?: true
  }

  export type BoilsCountAggregateInputType = {
    id?: true
    value?: true
    base_id?: true
    letter?: true
    year?: true
    number?: true
    plant_id?: true
    _all?: true
  }

  export type BoilsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boils to aggregate.
     */
    where?: boilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boils to fetch.
     */
    orderBy?: boilsOrderByWithRelationInput | boilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: boilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned boils
    **/
    _count?: true | BoilsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BoilsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BoilsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BoilsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BoilsMaxAggregateInputType
  }

  export type GetBoilsAggregateType<T extends BoilsAggregateArgs> = {
        [P in keyof T & keyof AggregateBoils]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBoils[P]>
      : GetScalarType<T[P], AggregateBoils[P]>
  }




  export type boilsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: boilsWhereInput
    orderBy?: boilsOrderByWithAggregationInput | boilsOrderByWithAggregationInput[]
    by: BoilsScalarFieldEnum[] | BoilsScalarFieldEnum
    having?: boilsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BoilsCountAggregateInputType | true
    _avg?: BoilsAvgAggregateInputType
    _sum?: BoilsSumAggregateInputType
    _min?: BoilsMinAggregateInputType
    _max?: BoilsMaxAggregateInputType
  }

  export type BoilsGroupByOutputType = {
    id: number
    value: string
    base_id: number | null
    letter: string | null
    year: Decimal | null
    number: Decimal | null
    plant_id: number | null
    _count: BoilsCountAggregateOutputType | null
    _avg: BoilsAvgAggregateOutputType | null
    _sum: BoilsSumAggregateOutputType | null
    _min: BoilsMinAggregateOutputType | null
    _max: BoilsMaxAggregateOutputType | null
  }

  type GetBoilsGroupByPayload<T extends boilsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BoilsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BoilsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BoilsGroupByOutputType[P]>
            : GetScalarType<T[P], BoilsGroupByOutputType[P]>
        }
      >
    >


  export type boilsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    base_id?: boolean
    letter?: boolean
    year?: boolean
    number?: boolean
    plant_id?: boolean
    bases?: boolean | boils$basesArgs<ExtArgs>
    semi_products?: boolean | boils$semi_productsArgs<ExtArgs>
    tube_records?: boolean | boils$tube_recordsArgs<ExtArgs>
    records?: boolean | boils$recordsArgs<ExtArgs>
    _count?: boolean | BoilsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["boils"]>

  export type boilsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    base_id?: boolean
    letter?: boolean
    year?: boolean
    number?: boolean
    plant_id?: boolean
    bases?: boolean | boils$basesArgs<ExtArgs>
  }, ExtArgs["result"]["boils"]>

  export type boilsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    base_id?: boolean
    letter?: boolean
    year?: boolean
    number?: boolean
    plant_id?: boolean
    bases?: boolean | boils$basesArgs<ExtArgs>
  }, ExtArgs["result"]["boils"]>

  export type boilsSelectScalar = {
    id?: boolean
    value?: boolean
    base_id?: boolean
    letter?: boolean
    year?: boolean
    number?: boolean
    plant_id?: boolean
  }

  export type boilsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "base_id" | "letter" | "year" | "number" | "plant_id", ExtArgs["result"]["boils"]>
  export type boilsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bases?: boolean | boils$basesArgs<ExtArgs>
    semi_products?: boolean | boils$semi_productsArgs<ExtArgs>
    tube_records?: boolean | boils$tube_recordsArgs<ExtArgs>
    records?: boolean | boils$recordsArgs<ExtArgs>
    _count?: boolean | BoilsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type boilsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bases?: boolean | boils$basesArgs<ExtArgs>
  }
  export type boilsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bases?: boolean | boils$basesArgs<ExtArgs>
  }

  export type $boilsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "boils"
    objects: {
      bases: Prisma.$basesPayload<ExtArgs> | null
      semi_products: Prisma.$semi_productsPayload<ExtArgs>[]
      tube_records: Prisma.$tube_recordsPayload<ExtArgs>[]
      records: Prisma.$recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      base_id: number | null
      letter: string | null
      year: Prisma.Decimal | null
      number: Prisma.Decimal | null
      plant_id: number | null
    }, ExtArgs["result"]["boils"]>
    composites: {}
  }

  type boilsGetPayload<S extends boolean | null | undefined | boilsDefaultArgs> = $Result.GetResult<Prisma.$boilsPayload, S>

  type boilsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<boilsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BoilsCountAggregateInputType | true
    }

  export interface boilsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['boils'], meta: { name: 'boils' } }
    /**
     * Find zero or one Boils that matches the filter.
     * @param {boilsFindUniqueArgs} args - Arguments to find a Boils
     * @example
     * // Get one Boils
     * const boils = await prisma.boils.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends boilsFindUniqueArgs>(args: SelectSubset<T, boilsFindUniqueArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Boils that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {boilsFindUniqueOrThrowArgs} args - Arguments to find a Boils
     * @example
     * // Get one Boils
     * const boils = await prisma.boils.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends boilsFindUniqueOrThrowArgs>(args: SelectSubset<T, boilsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boilsFindFirstArgs} args - Arguments to find a Boils
     * @example
     * // Get one Boils
     * const boils = await prisma.boils.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends boilsFindFirstArgs>(args?: SelectSubset<T, boilsFindFirstArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Boils that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boilsFindFirstOrThrowArgs} args - Arguments to find a Boils
     * @example
     * // Get one Boils
     * const boils = await prisma.boils.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends boilsFindFirstOrThrowArgs>(args?: SelectSubset<T, boilsFindFirstOrThrowArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Boils that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boilsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Boils
     * const boils = await prisma.boils.findMany()
     * 
     * // Get first 10 Boils
     * const boils = await prisma.boils.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const boilsWithIdOnly = await prisma.boils.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends boilsFindManyArgs>(args?: SelectSubset<T, boilsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Boils.
     * @param {boilsCreateArgs} args - Arguments to create a Boils.
     * @example
     * // Create one Boils
     * const Boils = await prisma.boils.create({
     *   data: {
     *     // ... data to create a Boils
     *   }
     * })
     * 
     */
    create<T extends boilsCreateArgs>(args: SelectSubset<T, boilsCreateArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Boils.
     * @param {boilsCreateManyArgs} args - Arguments to create many Boils.
     * @example
     * // Create many Boils
     * const boils = await prisma.boils.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends boilsCreateManyArgs>(args?: SelectSubset<T, boilsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Boils and returns the data saved in the database.
     * @param {boilsCreateManyAndReturnArgs} args - Arguments to create many Boils.
     * @example
     * // Create many Boils
     * const boils = await prisma.boils.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Boils and only return the `id`
     * const boilsWithIdOnly = await prisma.boils.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends boilsCreateManyAndReturnArgs>(args?: SelectSubset<T, boilsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Boils.
     * @param {boilsDeleteArgs} args - Arguments to delete one Boils.
     * @example
     * // Delete one Boils
     * const Boils = await prisma.boils.delete({
     *   where: {
     *     // ... filter to delete one Boils
     *   }
     * })
     * 
     */
    delete<T extends boilsDeleteArgs>(args: SelectSubset<T, boilsDeleteArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Boils.
     * @param {boilsUpdateArgs} args - Arguments to update one Boils.
     * @example
     * // Update one Boils
     * const boils = await prisma.boils.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends boilsUpdateArgs>(args: SelectSubset<T, boilsUpdateArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Boils.
     * @param {boilsDeleteManyArgs} args - Arguments to filter Boils to delete.
     * @example
     * // Delete a few Boils
     * const { count } = await prisma.boils.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends boilsDeleteManyArgs>(args?: SelectSubset<T, boilsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boilsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Boils
     * const boils = await prisma.boils.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends boilsUpdateManyArgs>(args: SelectSubset<T, boilsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Boils and returns the data updated in the database.
     * @param {boilsUpdateManyAndReturnArgs} args - Arguments to update many Boils.
     * @example
     * // Update many Boils
     * const boils = await prisma.boils.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Boils and only return the `id`
     * const boilsWithIdOnly = await prisma.boils.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends boilsUpdateManyAndReturnArgs>(args: SelectSubset<T, boilsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Boils.
     * @param {boilsUpsertArgs} args - Arguments to update or create a Boils.
     * @example
     * // Update or create a Boils
     * const boils = await prisma.boils.upsert({
     *   create: {
     *     // ... data to create a Boils
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Boils we want to update
     *   }
     * })
     */
    upsert<T extends boilsUpsertArgs>(args: SelectSubset<T, boilsUpsertArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Boils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boilsCountArgs} args - Arguments to filter Boils to count.
     * @example
     * // Count the number of Boils
     * const count = await prisma.boils.count({
     *   where: {
     *     // ... the filter for the Boils we want to count
     *   }
     * })
    **/
    count<T extends boilsCountArgs>(
      args?: Subset<T, boilsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BoilsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Boils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BoilsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BoilsAggregateArgs>(args: Subset<T, BoilsAggregateArgs>): Prisma.PrismaPromise<GetBoilsAggregateType<T>>

    /**
     * Group by Boils.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {boilsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends boilsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: boilsGroupByArgs['orderBy'] }
        : { orderBy?: boilsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, boilsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBoilsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the boils model
   */
  readonly fields: boilsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for boils.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__boilsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bases<T extends boils$basesArgs<ExtArgs> = {}>(args?: Subset<T, boils$basesArgs<ExtArgs>>): Prisma__basesClient<$Result.GetResult<Prisma.$basesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    semi_products<T extends boils$semi_productsArgs<ExtArgs> = {}>(args?: Subset<T, boils$semi_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tube_records<T extends boils$tube_recordsArgs<ExtArgs> = {}>(args?: Subset<T, boils$tube_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    records<T extends boils$recordsArgs<ExtArgs> = {}>(args?: Subset<T, boils$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the boils model
   */
  interface boilsFieldRefs {
    readonly id: FieldRef<"boils", 'Int'>
    readonly value: FieldRef<"boils", 'String'>
    readonly base_id: FieldRef<"boils", 'Int'>
    readonly letter: FieldRef<"boils", 'String'>
    readonly year: FieldRef<"boils", 'Decimal'>
    readonly number: FieldRef<"boils", 'Decimal'>
    readonly plant_id: FieldRef<"boils", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * boils findUnique
   */
  export type boilsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * Filter, which boils to fetch.
     */
    where: boilsWhereUniqueInput
  }

  /**
   * boils findUniqueOrThrow
   */
  export type boilsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * Filter, which boils to fetch.
     */
    where: boilsWhereUniqueInput
  }

  /**
   * boils findFirst
   */
  export type boilsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * Filter, which boils to fetch.
     */
    where?: boilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boils to fetch.
     */
    orderBy?: boilsOrderByWithRelationInput | boilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boils.
     */
    cursor?: boilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boils.
     */
    distinct?: BoilsScalarFieldEnum | BoilsScalarFieldEnum[]
  }

  /**
   * boils findFirstOrThrow
   */
  export type boilsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * Filter, which boils to fetch.
     */
    where?: boilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boils to fetch.
     */
    orderBy?: boilsOrderByWithRelationInput | boilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for boils.
     */
    cursor?: boilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boils.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of boils.
     */
    distinct?: BoilsScalarFieldEnum | BoilsScalarFieldEnum[]
  }

  /**
   * boils findMany
   */
  export type boilsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * Filter, which boils to fetch.
     */
    where?: boilsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of boils to fetch.
     */
    orderBy?: boilsOrderByWithRelationInput | boilsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing boils.
     */
    cursor?: boilsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` boils from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` boils.
     */
    skip?: number
    distinct?: BoilsScalarFieldEnum | BoilsScalarFieldEnum[]
  }

  /**
   * boils create
   */
  export type boilsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * The data needed to create a boils.
     */
    data: XOR<boilsCreateInput, boilsUncheckedCreateInput>
  }

  /**
   * boils createMany
   */
  export type boilsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many boils.
     */
    data: boilsCreateManyInput | boilsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * boils createManyAndReturn
   */
  export type boilsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * The data used to create many boils.
     */
    data: boilsCreateManyInput | boilsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * boils update
   */
  export type boilsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * The data needed to update a boils.
     */
    data: XOR<boilsUpdateInput, boilsUncheckedUpdateInput>
    /**
     * Choose, which boils to update.
     */
    where: boilsWhereUniqueInput
  }

  /**
   * boils updateMany
   */
  export type boilsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update boils.
     */
    data: XOR<boilsUpdateManyMutationInput, boilsUncheckedUpdateManyInput>
    /**
     * Filter which boils to update
     */
    where?: boilsWhereInput
    /**
     * Limit how many boils to update.
     */
    limit?: number
  }

  /**
   * boils updateManyAndReturn
   */
  export type boilsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * The data used to update boils.
     */
    data: XOR<boilsUpdateManyMutationInput, boilsUncheckedUpdateManyInput>
    /**
     * Filter which boils to update
     */
    where?: boilsWhereInput
    /**
     * Limit how many boils to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * boils upsert
   */
  export type boilsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * The filter to search for the boils to update in case it exists.
     */
    where: boilsWhereUniqueInput
    /**
     * In case the boils found by the `where` argument doesn't exist, create a new boils with this data.
     */
    create: XOR<boilsCreateInput, boilsUncheckedCreateInput>
    /**
     * In case the boils was found with the provided `where` argument, update it with this data.
     */
    update: XOR<boilsUpdateInput, boilsUncheckedUpdateInput>
  }

  /**
   * boils delete
   */
  export type boilsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    /**
     * Filter which boils to delete.
     */
    where: boilsWhereUniqueInput
  }

  /**
   * boils deleteMany
   */
  export type boilsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which boils to delete
     */
    where?: boilsWhereInput
    /**
     * Limit how many boils to delete.
     */
    limit?: number
  }

  /**
   * boils.bases
   */
  export type boils$basesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bases
     */
    select?: basesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bases
     */
    omit?: basesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basesInclude<ExtArgs> | null
    where?: basesWhereInput
  }

  /**
   * boils.semi_products
   */
  export type boils$semi_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    where?: semi_productsWhereInput
    orderBy?: semi_productsOrderByWithRelationInput | semi_productsOrderByWithRelationInput[]
    cursor?: semi_productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Semi_productsScalarFieldEnum | Semi_productsScalarFieldEnum[]
  }

  /**
   * boils.tube_records
   */
  export type boils$tube_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    where?: tube_recordsWhereInput
    orderBy?: tube_recordsOrderByWithRelationInput | tube_recordsOrderByWithRelationInput[]
    cursor?: tube_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_recordsScalarFieldEnum | Tube_recordsScalarFieldEnum[]
  }

  /**
   * boils.records
   */
  export type boils$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    cursor?: recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * boils without action
   */
  export type boilsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
  }


  /**
   * Model cans
   */

  export type AggregateCans = {
    _count: CansCountAggregateOutputType | null
    _avg: CansAvgAggregateOutputType | null
    _sum: CansSumAggregateOutputType | null
    _min: CansMinAggregateOutputType | null
    _max: CansMaxAggregateOutputType | null
  }

  export type CansAvgAggregateOutputType = {
    id: number | null
  }

  export type CansSumAggregateOutputType = {
    id: number | null
  }

  export type CansMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type CansMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type CansCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type CansAvgAggregateInputType = {
    id?: true
  }

  export type CansSumAggregateInputType = {
    id?: true
  }

  export type CansMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type CansMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type CansCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type CansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cans to aggregate.
     */
    where?: cansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cans to fetch.
     */
    orderBy?: cansOrderByWithRelationInput | cansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cans
    **/
    _count?: true | CansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CansMaxAggregateInputType
  }

  export type GetCansAggregateType<T extends CansAggregateArgs> = {
        [P in keyof T & keyof AggregateCans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCans[P]>
      : GetScalarType<T[P], AggregateCans[P]>
  }




  export type cansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cansWhereInput
    orderBy?: cansOrderByWithAggregationInput | cansOrderByWithAggregationInput[]
    by: CansScalarFieldEnum[] | CansScalarFieldEnum
    having?: cansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CansCountAggregateInputType | true
    _avg?: CansAvgAggregateInputType
    _sum?: CansSumAggregateInputType
    _min?: CansMinAggregateInputType
    _max?: CansMaxAggregateInputType
  }

  export type CansGroupByOutputType = {
    id: number
    value: string
    _count: CansCountAggregateOutputType | null
    _avg: CansAvgAggregateOutputType | null
    _sum: CansSumAggregateOutputType | null
    _min: CansMinAggregateOutputType | null
    _max: CansMaxAggregateOutputType | null
  }

  type GetCansGroupByPayload<T extends cansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CansGroupByOutputType[P]>
            : GetScalarType<T[P], CansGroupByOutputType[P]>
        }
      >
    >


  export type cansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    records?: boolean | cans$recordsArgs<ExtArgs>
    _count?: boolean | CansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cans"]>

  export type cansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["cans"]>

  export type cansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["cans"]>

  export type cansSelectScalar = {
    id?: boolean
    value?: boolean
  }

  export type cansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value", ExtArgs["result"]["cans"]>
  export type cansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | cans$recordsArgs<ExtArgs>
    _count?: boolean | CansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type cansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $cansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cans"
    objects: {
      records: Prisma.$recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
    }, ExtArgs["result"]["cans"]>
    composites: {}
  }

  type cansGetPayload<S extends boolean | null | undefined | cansDefaultArgs> = $Result.GetResult<Prisma.$cansPayload, S>

  type cansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CansCountAggregateInputType | true
    }

  export interface cansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cans'], meta: { name: 'cans' } }
    /**
     * Find zero or one Cans that matches the filter.
     * @param {cansFindUniqueArgs} args - Arguments to find a Cans
     * @example
     * // Get one Cans
     * const cans = await prisma.cans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cansFindUniqueArgs>(args: SelectSubset<T, cansFindUniqueArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cansFindUniqueOrThrowArgs} args - Arguments to find a Cans
     * @example
     * // Get one Cans
     * const cans = await prisma.cans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cansFindUniqueOrThrowArgs>(args: SelectSubset<T, cansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cansFindFirstArgs} args - Arguments to find a Cans
     * @example
     * // Get one Cans
     * const cans = await prisma.cans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cansFindFirstArgs>(args?: SelectSubset<T, cansFindFirstArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cansFindFirstOrThrowArgs} args - Arguments to find a Cans
     * @example
     * // Get one Cans
     * const cans = await prisma.cans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cansFindFirstOrThrowArgs>(args?: SelectSubset<T, cansFindFirstOrThrowArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cans
     * const cans = await prisma.cans.findMany()
     * 
     * // Get first 10 Cans
     * const cans = await prisma.cans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cansWithIdOnly = await prisma.cans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cansFindManyArgs>(args?: SelectSubset<T, cansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cans.
     * @param {cansCreateArgs} args - Arguments to create a Cans.
     * @example
     * // Create one Cans
     * const Cans = await prisma.cans.create({
     *   data: {
     *     // ... data to create a Cans
     *   }
     * })
     * 
     */
    create<T extends cansCreateArgs>(args: SelectSubset<T, cansCreateArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cans.
     * @param {cansCreateManyArgs} args - Arguments to create many Cans.
     * @example
     * // Create many Cans
     * const cans = await prisma.cans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cansCreateManyArgs>(args?: SelectSubset<T, cansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cans and returns the data saved in the database.
     * @param {cansCreateManyAndReturnArgs} args - Arguments to create many Cans.
     * @example
     * // Create many Cans
     * const cans = await prisma.cans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cans and only return the `id`
     * const cansWithIdOnly = await prisma.cans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cansCreateManyAndReturnArgs>(args?: SelectSubset<T, cansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cans.
     * @param {cansDeleteArgs} args - Arguments to delete one Cans.
     * @example
     * // Delete one Cans
     * const Cans = await prisma.cans.delete({
     *   where: {
     *     // ... filter to delete one Cans
     *   }
     * })
     * 
     */
    delete<T extends cansDeleteArgs>(args: SelectSubset<T, cansDeleteArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cans.
     * @param {cansUpdateArgs} args - Arguments to update one Cans.
     * @example
     * // Update one Cans
     * const cans = await prisma.cans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cansUpdateArgs>(args: SelectSubset<T, cansUpdateArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cans.
     * @param {cansDeleteManyArgs} args - Arguments to filter Cans to delete.
     * @example
     * // Delete a few Cans
     * const { count } = await prisma.cans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cansDeleteManyArgs>(args?: SelectSubset<T, cansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cans
     * const cans = await prisma.cans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cansUpdateManyArgs>(args: SelectSubset<T, cansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cans and returns the data updated in the database.
     * @param {cansUpdateManyAndReturnArgs} args - Arguments to update many Cans.
     * @example
     * // Update many Cans
     * const cans = await prisma.cans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cans and only return the `id`
     * const cansWithIdOnly = await prisma.cans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cansUpdateManyAndReturnArgs>(args: SelectSubset<T, cansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cans.
     * @param {cansUpsertArgs} args - Arguments to update or create a Cans.
     * @example
     * // Update or create a Cans
     * const cans = await prisma.cans.upsert({
     *   create: {
     *     // ... data to create a Cans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cans we want to update
     *   }
     * })
     */
    upsert<T extends cansUpsertArgs>(args: SelectSubset<T, cansUpsertArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cansCountArgs} args - Arguments to filter Cans to count.
     * @example
     * // Count the number of Cans
     * const count = await prisma.cans.count({
     *   where: {
     *     // ... the filter for the Cans we want to count
     *   }
     * })
    **/
    count<T extends cansCountArgs>(
      args?: Subset<T, cansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CansAggregateArgs>(args: Subset<T, CansAggregateArgs>): Prisma.PrismaPromise<GetCansAggregateType<T>>

    /**
     * Group by Cans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cansGroupByArgs['orderBy'] }
        : { orderBy?: cansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cans model
   */
  readonly fields: cansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    records<T extends cans$recordsArgs<ExtArgs> = {}>(args?: Subset<T, cans$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cans model
   */
  interface cansFieldRefs {
    readonly id: FieldRef<"cans", 'Int'>
    readonly value: FieldRef<"cans", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cans findUnique
   */
  export type cansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * Filter, which cans to fetch.
     */
    where: cansWhereUniqueInput
  }

  /**
   * cans findUniqueOrThrow
   */
  export type cansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * Filter, which cans to fetch.
     */
    where: cansWhereUniqueInput
  }

  /**
   * cans findFirst
   */
  export type cansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * Filter, which cans to fetch.
     */
    where?: cansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cans to fetch.
     */
    orderBy?: cansOrderByWithRelationInput | cansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cans.
     */
    cursor?: cansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cans.
     */
    distinct?: CansScalarFieldEnum | CansScalarFieldEnum[]
  }

  /**
   * cans findFirstOrThrow
   */
  export type cansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * Filter, which cans to fetch.
     */
    where?: cansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cans to fetch.
     */
    orderBy?: cansOrderByWithRelationInput | cansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cans.
     */
    cursor?: cansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cans.
     */
    distinct?: CansScalarFieldEnum | CansScalarFieldEnum[]
  }

  /**
   * cans findMany
   */
  export type cansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * Filter, which cans to fetch.
     */
    where?: cansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cans to fetch.
     */
    orderBy?: cansOrderByWithRelationInput | cansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cans.
     */
    cursor?: cansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cans.
     */
    skip?: number
    distinct?: CansScalarFieldEnum | CansScalarFieldEnum[]
  }

  /**
   * cans create
   */
  export type cansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * The data needed to create a cans.
     */
    data: XOR<cansCreateInput, cansUncheckedCreateInput>
  }

  /**
   * cans createMany
   */
  export type cansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cans.
     */
    data: cansCreateManyInput | cansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cans createManyAndReturn
   */
  export type cansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * The data used to create many cans.
     */
    data: cansCreateManyInput | cansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cans update
   */
  export type cansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * The data needed to update a cans.
     */
    data: XOR<cansUpdateInput, cansUncheckedUpdateInput>
    /**
     * Choose, which cans to update.
     */
    where: cansWhereUniqueInput
  }

  /**
   * cans updateMany
   */
  export type cansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cans.
     */
    data: XOR<cansUpdateManyMutationInput, cansUncheckedUpdateManyInput>
    /**
     * Filter which cans to update
     */
    where?: cansWhereInput
    /**
     * Limit how many cans to update.
     */
    limit?: number
  }

  /**
   * cans updateManyAndReturn
   */
  export type cansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * The data used to update cans.
     */
    data: XOR<cansUpdateManyMutationInput, cansUncheckedUpdateManyInput>
    /**
     * Filter which cans to update
     */
    where?: cansWhereInput
    /**
     * Limit how many cans to update.
     */
    limit?: number
  }

  /**
   * cans upsert
   */
  export type cansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * The filter to search for the cans to update in case it exists.
     */
    where: cansWhereUniqueInput
    /**
     * In case the cans found by the `where` argument doesn't exist, create a new cans with this data.
     */
    create: XOR<cansCreateInput, cansUncheckedCreateInput>
    /**
     * In case the cans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cansUpdateInput, cansUncheckedUpdateInput>
  }

  /**
   * cans delete
   */
  export type cansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    /**
     * Filter which cans to delete.
     */
    where: cansWhereUniqueInput
  }

  /**
   * cans deleteMany
   */
  export type cansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cans to delete
     */
    where?: cansWhereInput
    /**
     * Limit how many cans to delete.
     */
    limit?: number
  }

  /**
   * cans.records
   */
  export type cans$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    cursor?: recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * cans without action
   */
  export type cansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
  }


  /**
   * Model conveyors
   */

  export type AggregateConveyors = {
    _count: ConveyorsCountAggregateOutputType | null
    _avg: ConveyorsAvgAggregateOutputType | null
    _sum: ConveyorsSumAggregateOutputType | null
    _min: ConveyorsMinAggregateOutputType | null
    _max: ConveyorsMaxAggregateOutputType | null
  }

  export type ConveyorsAvgAggregateOutputType = {
    id: number | null
  }

  export type ConveyorsSumAggregateOutputType = {
    id: number | null
  }

  export type ConveyorsMinAggregateOutputType = {
    id: number | null
    value: string | null
    barcode: string | null
  }

  export type ConveyorsMaxAggregateOutputType = {
    id: number | null
    value: string | null
    barcode: string | null
  }

  export type ConveyorsCountAggregateOutputType = {
    id: number
    value: number
    barcode: number
    _all: number
  }


  export type ConveyorsAvgAggregateInputType = {
    id?: true
  }

  export type ConveyorsSumAggregateInputType = {
    id?: true
  }

  export type ConveyorsMinAggregateInputType = {
    id?: true
    value?: true
    barcode?: true
  }

  export type ConveyorsMaxAggregateInputType = {
    id?: true
    value?: true
    barcode?: true
  }

  export type ConveyorsCountAggregateInputType = {
    id?: true
    value?: true
    barcode?: true
    _all?: true
  }

  export type ConveyorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conveyors to aggregate.
     */
    where?: conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conveyors to fetch.
     */
    orderBy?: conveyorsOrderByWithRelationInput | conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conveyors
    **/
    _count?: true | ConveyorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConveyorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConveyorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConveyorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConveyorsMaxAggregateInputType
  }

  export type GetConveyorsAggregateType<T extends ConveyorsAggregateArgs> = {
        [P in keyof T & keyof AggregateConveyors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConveyors[P]>
      : GetScalarType<T[P], AggregateConveyors[P]>
  }




  export type conveyorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conveyorsWhereInput
    orderBy?: conveyorsOrderByWithAggregationInput | conveyorsOrderByWithAggregationInput[]
    by: ConveyorsScalarFieldEnum[] | ConveyorsScalarFieldEnum
    having?: conveyorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConveyorsCountAggregateInputType | true
    _avg?: ConveyorsAvgAggregateInputType
    _sum?: ConveyorsSumAggregateInputType
    _min?: ConveyorsMinAggregateInputType
    _max?: ConveyorsMaxAggregateInputType
  }

  export type ConveyorsGroupByOutputType = {
    id: number
    value: string
    barcode: string | null
    _count: ConveyorsCountAggregateOutputType | null
    _avg: ConveyorsAvgAggregateOutputType | null
    _sum: ConveyorsSumAggregateOutputType | null
    _min: ConveyorsMinAggregateOutputType | null
    _max: ConveyorsMaxAggregateOutputType | null
  }

  type GetConveyorsGroupByPayload<T extends conveyorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConveyorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConveyorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConveyorsGroupByOutputType[P]>
            : GetScalarType<T[P], ConveyorsGroupByOutputType[P]>
        }
      >
    >


  export type conveyorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    barcode?: boolean
    records?: boolean | conveyors$recordsArgs<ExtArgs>
    _count?: boolean | ConveyorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conveyors"]>

  export type conveyorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    barcode?: boolean
  }, ExtArgs["result"]["conveyors"]>

  export type conveyorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    barcode?: boolean
  }, ExtArgs["result"]["conveyors"]>

  export type conveyorsSelectScalar = {
    id?: boolean
    value?: boolean
    barcode?: boolean
  }

  export type conveyorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "barcode", ExtArgs["result"]["conveyors"]>
  export type conveyorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | conveyors$recordsArgs<ExtArgs>
    _count?: boolean | ConveyorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type conveyorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type conveyorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $conveyorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conveyors"
    objects: {
      records: Prisma.$recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      barcode: string | null
    }, ExtArgs["result"]["conveyors"]>
    composites: {}
  }

  type conveyorsGetPayload<S extends boolean | null | undefined | conveyorsDefaultArgs> = $Result.GetResult<Prisma.$conveyorsPayload, S>

  type conveyorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conveyorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConveyorsCountAggregateInputType | true
    }

  export interface conveyorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conveyors'], meta: { name: 'conveyors' } }
    /**
     * Find zero or one Conveyors that matches the filter.
     * @param {conveyorsFindUniqueArgs} args - Arguments to find a Conveyors
     * @example
     * // Get one Conveyors
     * const conveyors = await prisma.conveyors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conveyorsFindUniqueArgs>(args: SelectSubset<T, conveyorsFindUniqueArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conveyors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conveyorsFindUniqueOrThrowArgs} args - Arguments to find a Conveyors
     * @example
     * // Get one Conveyors
     * const conveyors = await prisma.conveyors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conveyorsFindUniqueOrThrowArgs>(args: SelectSubset<T, conveyorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conveyors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conveyorsFindFirstArgs} args - Arguments to find a Conveyors
     * @example
     * // Get one Conveyors
     * const conveyors = await prisma.conveyors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conveyorsFindFirstArgs>(args?: SelectSubset<T, conveyorsFindFirstArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conveyors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conveyorsFindFirstOrThrowArgs} args - Arguments to find a Conveyors
     * @example
     * // Get one Conveyors
     * const conveyors = await prisma.conveyors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conveyorsFindFirstOrThrowArgs>(args?: SelectSubset<T, conveyorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conveyors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conveyorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conveyors
     * const conveyors = await prisma.conveyors.findMany()
     * 
     * // Get first 10 Conveyors
     * const conveyors = await prisma.conveyors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conveyorsWithIdOnly = await prisma.conveyors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conveyorsFindManyArgs>(args?: SelectSubset<T, conveyorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conveyors.
     * @param {conveyorsCreateArgs} args - Arguments to create a Conveyors.
     * @example
     * // Create one Conveyors
     * const Conveyors = await prisma.conveyors.create({
     *   data: {
     *     // ... data to create a Conveyors
     *   }
     * })
     * 
     */
    create<T extends conveyorsCreateArgs>(args: SelectSubset<T, conveyorsCreateArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conveyors.
     * @param {conveyorsCreateManyArgs} args - Arguments to create many Conveyors.
     * @example
     * // Create many Conveyors
     * const conveyors = await prisma.conveyors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conveyorsCreateManyArgs>(args?: SelectSubset<T, conveyorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conveyors and returns the data saved in the database.
     * @param {conveyorsCreateManyAndReturnArgs} args - Arguments to create many Conveyors.
     * @example
     * // Create many Conveyors
     * const conveyors = await prisma.conveyors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conveyors and only return the `id`
     * const conveyorsWithIdOnly = await prisma.conveyors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conveyorsCreateManyAndReturnArgs>(args?: SelectSubset<T, conveyorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conveyors.
     * @param {conveyorsDeleteArgs} args - Arguments to delete one Conveyors.
     * @example
     * // Delete one Conveyors
     * const Conveyors = await prisma.conveyors.delete({
     *   where: {
     *     // ... filter to delete one Conveyors
     *   }
     * })
     * 
     */
    delete<T extends conveyorsDeleteArgs>(args: SelectSubset<T, conveyorsDeleteArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conveyors.
     * @param {conveyorsUpdateArgs} args - Arguments to update one Conveyors.
     * @example
     * // Update one Conveyors
     * const conveyors = await prisma.conveyors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conveyorsUpdateArgs>(args: SelectSubset<T, conveyorsUpdateArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conveyors.
     * @param {conveyorsDeleteManyArgs} args - Arguments to filter Conveyors to delete.
     * @example
     * // Delete a few Conveyors
     * const { count } = await prisma.conveyors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conveyorsDeleteManyArgs>(args?: SelectSubset<T, conveyorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conveyorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conveyors
     * const conveyors = await prisma.conveyors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conveyorsUpdateManyArgs>(args: SelectSubset<T, conveyorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conveyors and returns the data updated in the database.
     * @param {conveyorsUpdateManyAndReturnArgs} args - Arguments to update many Conveyors.
     * @example
     * // Update many Conveyors
     * const conveyors = await prisma.conveyors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conveyors and only return the `id`
     * const conveyorsWithIdOnly = await prisma.conveyors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conveyorsUpdateManyAndReturnArgs>(args: SelectSubset<T, conveyorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conveyors.
     * @param {conveyorsUpsertArgs} args - Arguments to update or create a Conveyors.
     * @example
     * // Update or create a Conveyors
     * const conveyors = await prisma.conveyors.upsert({
     *   create: {
     *     // ... data to create a Conveyors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conveyors we want to update
     *   }
     * })
     */
    upsert<T extends conveyorsUpsertArgs>(args: SelectSubset<T, conveyorsUpsertArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conveyorsCountArgs} args - Arguments to filter Conveyors to count.
     * @example
     * // Count the number of Conveyors
     * const count = await prisma.conveyors.count({
     *   where: {
     *     // ... the filter for the Conveyors we want to count
     *   }
     * })
    **/
    count<T extends conveyorsCountArgs>(
      args?: Subset<T, conveyorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConveyorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConveyorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConveyorsAggregateArgs>(args: Subset<T, ConveyorsAggregateArgs>): Prisma.PrismaPromise<GetConveyorsAggregateType<T>>

    /**
     * Group by Conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conveyorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conveyorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conveyorsGroupByArgs['orderBy'] }
        : { orderBy?: conveyorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conveyorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConveyorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conveyors model
   */
  readonly fields: conveyorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conveyors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conveyorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    records<T extends conveyors$recordsArgs<ExtArgs> = {}>(args?: Subset<T, conveyors$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conveyors model
   */
  interface conveyorsFieldRefs {
    readonly id: FieldRef<"conveyors", 'Int'>
    readonly value: FieldRef<"conveyors", 'String'>
    readonly barcode: FieldRef<"conveyors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * conveyors findUnique
   */
  export type conveyorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which conveyors to fetch.
     */
    where: conveyorsWhereUniqueInput
  }

  /**
   * conveyors findUniqueOrThrow
   */
  export type conveyorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which conveyors to fetch.
     */
    where: conveyorsWhereUniqueInput
  }

  /**
   * conveyors findFirst
   */
  export type conveyorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which conveyors to fetch.
     */
    where?: conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conveyors to fetch.
     */
    orderBy?: conveyorsOrderByWithRelationInput | conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conveyors.
     */
    cursor?: conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conveyors.
     */
    distinct?: ConveyorsScalarFieldEnum | ConveyorsScalarFieldEnum[]
  }

  /**
   * conveyors findFirstOrThrow
   */
  export type conveyorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which conveyors to fetch.
     */
    where?: conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conveyors to fetch.
     */
    orderBy?: conveyorsOrderByWithRelationInput | conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conveyors.
     */
    cursor?: conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conveyors.
     */
    distinct?: ConveyorsScalarFieldEnum | ConveyorsScalarFieldEnum[]
  }

  /**
   * conveyors findMany
   */
  export type conveyorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which conveyors to fetch.
     */
    where?: conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conveyors to fetch.
     */
    orderBy?: conveyorsOrderByWithRelationInput | conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conveyors.
     */
    cursor?: conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conveyors.
     */
    skip?: number
    distinct?: ConveyorsScalarFieldEnum | ConveyorsScalarFieldEnum[]
  }

  /**
   * conveyors create
   */
  export type conveyorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * The data needed to create a conveyors.
     */
    data: XOR<conveyorsCreateInput, conveyorsUncheckedCreateInput>
  }

  /**
   * conveyors createMany
   */
  export type conveyorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conveyors.
     */
    data: conveyorsCreateManyInput | conveyorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conveyors createManyAndReturn
   */
  export type conveyorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * The data used to create many conveyors.
     */
    data: conveyorsCreateManyInput | conveyorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conveyors update
   */
  export type conveyorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * The data needed to update a conveyors.
     */
    data: XOR<conveyorsUpdateInput, conveyorsUncheckedUpdateInput>
    /**
     * Choose, which conveyors to update.
     */
    where: conveyorsWhereUniqueInput
  }

  /**
   * conveyors updateMany
   */
  export type conveyorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conveyors.
     */
    data: XOR<conveyorsUpdateManyMutationInput, conveyorsUncheckedUpdateManyInput>
    /**
     * Filter which conveyors to update
     */
    where?: conveyorsWhereInput
    /**
     * Limit how many conveyors to update.
     */
    limit?: number
  }

  /**
   * conveyors updateManyAndReturn
   */
  export type conveyorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * The data used to update conveyors.
     */
    data: XOR<conveyorsUpdateManyMutationInput, conveyorsUncheckedUpdateManyInput>
    /**
     * Filter which conveyors to update
     */
    where?: conveyorsWhereInput
    /**
     * Limit how many conveyors to update.
     */
    limit?: number
  }

  /**
   * conveyors upsert
   */
  export type conveyorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * The filter to search for the conveyors to update in case it exists.
     */
    where: conveyorsWhereUniqueInput
    /**
     * In case the conveyors found by the `where` argument doesn't exist, create a new conveyors with this data.
     */
    create: XOR<conveyorsCreateInput, conveyorsUncheckedCreateInput>
    /**
     * In case the conveyors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conveyorsUpdateInput, conveyorsUncheckedUpdateInput>
  }

  /**
   * conveyors delete
   */
  export type conveyorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    /**
     * Filter which conveyors to delete.
     */
    where: conveyorsWhereUniqueInput
  }

  /**
   * conveyors deleteMany
   */
  export type conveyorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conveyors to delete
     */
    where?: conveyorsWhereInput
    /**
     * Limit how many conveyors to delete.
     */
    limit?: number
  }

  /**
   * conveyors.records
   */
  export type conveyors$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    cursor?: recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * conveyors without action
   */
  export type conveyorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
  }


  /**
   * Model dbo_Batchs
   */

  export type AggregateDbo_Batchs = {
    _count: Dbo_BatchsCountAggregateOutputType | null
    _avg: Dbo_BatchsAvgAggregateOutputType | null
    _sum: Dbo_BatchsSumAggregateOutputType | null
    _min: Dbo_BatchsMinAggregateOutputType | null
    _max: Dbo_BatchsMaxAggregateOutputType | null
  }

  export type Dbo_BatchsAvgAggregateOutputType = {
    BatchPK: number | null
  }

  export type Dbo_BatchsSumAggregateOutputType = {
    BatchPK: number | null
  }

  export type Dbo_BatchsMinAggregateOutputType = {
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dbo_BatchsMaxAggregateOutputType = {
    BatchPK: number | null
    BatchName: string | null
    BatchDate: Date | null
    Plant: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Dbo_BatchsCountAggregateOutputType = {
    BatchPK: number
    BatchName: number
    BatchDate: number
    Plant: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Dbo_BatchsAvgAggregateInputType = {
    BatchPK?: true
  }

  export type Dbo_BatchsSumAggregateInputType = {
    BatchPK?: true
  }

  export type Dbo_BatchsMinAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dbo_BatchsMaxAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Dbo_BatchsCountAggregateInputType = {
    BatchPK?: true
    BatchName?: true
    BatchDate?: true
    Plant?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Dbo_BatchsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dbo_Batchs to aggregate.
     */
    where?: dbo_BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dbo_Batchs to fetch.
     */
    orderBy?: dbo_BatchsOrderByWithRelationInput | dbo_BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dbo_BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dbo_Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dbo_Batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dbo_Batchs
    **/
    _count?: true | Dbo_BatchsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Dbo_BatchsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Dbo_BatchsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Dbo_BatchsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Dbo_BatchsMaxAggregateInputType
  }

  export type GetDbo_BatchsAggregateType<T extends Dbo_BatchsAggregateArgs> = {
        [P in keyof T & keyof AggregateDbo_Batchs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDbo_Batchs[P]>
      : GetScalarType<T[P], AggregateDbo_Batchs[P]>
  }




  export type dbo_BatchsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dbo_BatchsWhereInput
    orderBy?: dbo_BatchsOrderByWithAggregationInput | dbo_BatchsOrderByWithAggregationInput[]
    by: Dbo_BatchsScalarFieldEnum[] | Dbo_BatchsScalarFieldEnum
    having?: dbo_BatchsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Dbo_BatchsCountAggregateInputType | true
    _avg?: Dbo_BatchsAvgAggregateInputType
    _sum?: Dbo_BatchsSumAggregateInputType
    _min?: Dbo_BatchsMinAggregateInputType
    _max?: Dbo_BatchsMaxAggregateInputType
  }

  export type Dbo_BatchsGroupByOutputType = {
    BatchPK: number
    BatchName: string
    BatchDate: Date | null
    Plant: string
    createdAt: Date
    updatedAt: Date
    _count: Dbo_BatchsCountAggregateOutputType | null
    _avg: Dbo_BatchsAvgAggregateOutputType | null
    _sum: Dbo_BatchsSumAggregateOutputType | null
    _min: Dbo_BatchsMinAggregateOutputType | null
    _max: Dbo_BatchsMaxAggregateOutputType | null
  }

  type GetDbo_BatchsGroupByPayload<T extends dbo_BatchsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Dbo_BatchsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Dbo_BatchsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Dbo_BatchsGroupByOutputType[P]>
            : GetScalarType<T[P], Dbo_BatchsGroupByOutputType[P]>
        }
      >
    >


  export type dbo_BatchsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dbo_Batchs"]>

  export type dbo_BatchsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dbo_Batchs"]>

  export type dbo_BatchsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dbo_Batchs"]>

  export type dbo_BatchsSelectScalar = {
    BatchPK?: boolean
    BatchName?: boolean
    BatchDate?: boolean
    Plant?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type dbo_BatchsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"BatchPK" | "BatchName" | "BatchDate" | "Plant" | "createdAt" | "updatedAt", ExtArgs["result"]["dbo_Batchs"]>

  export type $dbo_BatchsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dbo_Batchs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      BatchPK: number
      BatchName: string
      BatchDate: Date | null
      Plant: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dbo_Batchs"]>
    composites: {}
  }

  type dbo_BatchsGetPayload<S extends boolean | null | undefined | dbo_BatchsDefaultArgs> = $Result.GetResult<Prisma.$dbo_BatchsPayload, S>

  type dbo_BatchsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<dbo_BatchsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Dbo_BatchsCountAggregateInputType | true
    }

  export interface dbo_BatchsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dbo_Batchs'], meta: { name: 'dbo_Batchs' } }
    /**
     * Find zero or one Dbo_Batchs that matches the filter.
     * @param {dbo_BatchsFindUniqueArgs} args - Arguments to find a Dbo_Batchs
     * @example
     * // Get one Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dbo_BatchsFindUniqueArgs>(args: SelectSubset<T, dbo_BatchsFindUniqueArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dbo_Batchs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {dbo_BatchsFindUniqueOrThrowArgs} args - Arguments to find a Dbo_Batchs
     * @example
     * // Get one Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dbo_BatchsFindUniqueOrThrowArgs>(args: SelectSubset<T, dbo_BatchsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dbo_Batchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dbo_BatchsFindFirstArgs} args - Arguments to find a Dbo_Batchs
     * @example
     * // Get one Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dbo_BatchsFindFirstArgs>(args?: SelectSubset<T, dbo_BatchsFindFirstArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dbo_Batchs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dbo_BatchsFindFirstOrThrowArgs} args - Arguments to find a Dbo_Batchs
     * @example
     * // Get one Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dbo_BatchsFindFirstOrThrowArgs>(args?: SelectSubset<T, dbo_BatchsFindFirstOrThrowArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dbo_Batchs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dbo_BatchsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.findMany()
     * 
     * // Get first 10 Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.findMany({ take: 10 })
     * 
     * // Only select the `BatchPK`
     * const dbo_BatchsWithBatchPKOnly = await prisma.dbo_Batchs.findMany({ select: { BatchPK: true } })
     * 
     */
    findMany<T extends dbo_BatchsFindManyArgs>(args?: SelectSubset<T, dbo_BatchsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dbo_Batchs.
     * @param {dbo_BatchsCreateArgs} args - Arguments to create a Dbo_Batchs.
     * @example
     * // Create one Dbo_Batchs
     * const Dbo_Batchs = await prisma.dbo_Batchs.create({
     *   data: {
     *     // ... data to create a Dbo_Batchs
     *   }
     * })
     * 
     */
    create<T extends dbo_BatchsCreateArgs>(args: SelectSubset<T, dbo_BatchsCreateArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dbo_Batchs.
     * @param {dbo_BatchsCreateManyArgs} args - Arguments to create many Dbo_Batchs.
     * @example
     * // Create many Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dbo_BatchsCreateManyArgs>(args?: SelectSubset<T, dbo_BatchsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dbo_Batchs and returns the data saved in the database.
     * @param {dbo_BatchsCreateManyAndReturnArgs} args - Arguments to create many Dbo_Batchs.
     * @example
     * // Create many Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dbo_Batchs and only return the `BatchPK`
     * const dbo_BatchsWithBatchPKOnly = await prisma.dbo_Batchs.createManyAndReturn({
     *   select: { BatchPK: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends dbo_BatchsCreateManyAndReturnArgs>(args?: SelectSubset<T, dbo_BatchsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dbo_Batchs.
     * @param {dbo_BatchsDeleteArgs} args - Arguments to delete one Dbo_Batchs.
     * @example
     * // Delete one Dbo_Batchs
     * const Dbo_Batchs = await prisma.dbo_Batchs.delete({
     *   where: {
     *     // ... filter to delete one Dbo_Batchs
     *   }
     * })
     * 
     */
    delete<T extends dbo_BatchsDeleteArgs>(args: SelectSubset<T, dbo_BatchsDeleteArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dbo_Batchs.
     * @param {dbo_BatchsUpdateArgs} args - Arguments to update one Dbo_Batchs.
     * @example
     * // Update one Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dbo_BatchsUpdateArgs>(args: SelectSubset<T, dbo_BatchsUpdateArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dbo_Batchs.
     * @param {dbo_BatchsDeleteManyArgs} args - Arguments to filter Dbo_Batchs to delete.
     * @example
     * // Delete a few Dbo_Batchs
     * const { count } = await prisma.dbo_Batchs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dbo_BatchsDeleteManyArgs>(args?: SelectSubset<T, dbo_BatchsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dbo_Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dbo_BatchsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dbo_BatchsUpdateManyArgs>(args: SelectSubset<T, dbo_BatchsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dbo_Batchs and returns the data updated in the database.
     * @param {dbo_BatchsUpdateManyAndReturnArgs} args - Arguments to update many Dbo_Batchs.
     * @example
     * // Update many Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dbo_Batchs and only return the `BatchPK`
     * const dbo_BatchsWithBatchPKOnly = await prisma.dbo_Batchs.updateManyAndReturn({
     *   select: { BatchPK: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends dbo_BatchsUpdateManyAndReturnArgs>(args: SelectSubset<T, dbo_BatchsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dbo_Batchs.
     * @param {dbo_BatchsUpsertArgs} args - Arguments to update or create a Dbo_Batchs.
     * @example
     * // Update or create a Dbo_Batchs
     * const dbo_Batchs = await prisma.dbo_Batchs.upsert({
     *   create: {
     *     // ... data to create a Dbo_Batchs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dbo_Batchs we want to update
     *   }
     * })
     */
    upsert<T extends dbo_BatchsUpsertArgs>(args: SelectSubset<T, dbo_BatchsUpsertArgs<ExtArgs>>): Prisma__dbo_BatchsClient<$Result.GetResult<Prisma.$dbo_BatchsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dbo_Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dbo_BatchsCountArgs} args - Arguments to filter Dbo_Batchs to count.
     * @example
     * // Count the number of Dbo_Batchs
     * const count = await prisma.dbo_Batchs.count({
     *   where: {
     *     // ... the filter for the Dbo_Batchs we want to count
     *   }
     * })
    **/
    count<T extends dbo_BatchsCountArgs>(
      args?: Subset<T, dbo_BatchsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Dbo_BatchsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dbo_Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Dbo_BatchsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Dbo_BatchsAggregateArgs>(args: Subset<T, Dbo_BatchsAggregateArgs>): Prisma.PrismaPromise<GetDbo_BatchsAggregateType<T>>

    /**
     * Group by Dbo_Batchs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dbo_BatchsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dbo_BatchsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dbo_BatchsGroupByArgs['orderBy'] }
        : { orderBy?: dbo_BatchsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dbo_BatchsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDbo_BatchsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dbo_Batchs model
   */
  readonly fields: dbo_BatchsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dbo_Batchs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dbo_BatchsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dbo_Batchs model
   */
  interface dbo_BatchsFieldRefs {
    readonly BatchPK: FieldRef<"dbo_Batchs", 'Int'>
    readonly BatchName: FieldRef<"dbo_Batchs", 'String'>
    readonly BatchDate: FieldRef<"dbo_Batchs", 'DateTime'>
    readonly Plant: FieldRef<"dbo_Batchs", 'String'>
    readonly createdAt: FieldRef<"dbo_Batchs", 'DateTime'>
    readonly updatedAt: FieldRef<"dbo_Batchs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * dbo_Batchs findUnique
   */
  export type dbo_BatchsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * Filter, which dbo_Batchs to fetch.
     */
    where: dbo_BatchsWhereUniqueInput
  }

  /**
   * dbo_Batchs findUniqueOrThrow
   */
  export type dbo_BatchsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * Filter, which dbo_Batchs to fetch.
     */
    where: dbo_BatchsWhereUniqueInput
  }

  /**
   * dbo_Batchs findFirst
   */
  export type dbo_BatchsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * Filter, which dbo_Batchs to fetch.
     */
    where?: dbo_BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dbo_Batchs to fetch.
     */
    orderBy?: dbo_BatchsOrderByWithRelationInput | dbo_BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dbo_Batchs.
     */
    cursor?: dbo_BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dbo_Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dbo_Batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dbo_Batchs.
     */
    distinct?: Dbo_BatchsScalarFieldEnum | Dbo_BatchsScalarFieldEnum[]
  }

  /**
   * dbo_Batchs findFirstOrThrow
   */
  export type dbo_BatchsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * Filter, which dbo_Batchs to fetch.
     */
    where?: dbo_BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dbo_Batchs to fetch.
     */
    orderBy?: dbo_BatchsOrderByWithRelationInput | dbo_BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dbo_Batchs.
     */
    cursor?: dbo_BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dbo_Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dbo_Batchs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dbo_Batchs.
     */
    distinct?: Dbo_BatchsScalarFieldEnum | Dbo_BatchsScalarFieldEnum[]
  }

  /**
   * dbo_Batchs findMany
   */
  export type dbo_BatchsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * Filter, which dbo_Batchs to fetch.
     */
    where?: dbo_BatchsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dbo_Batchs to fetch.
     */
    orderBy?: dbo_BatchsOrderByWithRelationInput | dbo_BatchsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dbo_Batchs.
     */
    cursor?: dbo_BatchsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dbo_Batchs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dbo_Batchs.
     */
    skip?: number
    distinct?: Dbo_BatchsScalarFieldEnum | Dbo_BatchsScalarFieldEnum[]
  }

  /**
   * dbo_Batchs create
   */
  export type dbo_BatchsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * The data needed to create a dbo_Batchs.
     */
    data: XOR<dbo_BatchsCreateInput, dbo_BatchsUncheckedCreateInput>
  }

  /**
   * dbo_Batchs createMany
   */
  export type dbo_BatchsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dbo_Batchs.
     */
    data: dbo_BatchsCreateManyInput | dbo_BatchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dbo_Batchs createManyAndReturn
   */
  export type dbo_BatchsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * The data used to create many dbo_Batchs.
     */
    data: dbo_BatchsCreateManyInput | dbo_BatchsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dbo_Batchs update
   */
  export type dbo_BatchsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * The data needed to update a dbo_Batchs.
     */
    data: XOR<dbo_BatchsUpdateInput, dbo_BatchsUncheckedUpdateInput>
    /**
     * Choose, which dbo_Batchs to update.
     */
    where: dbo_BatchsWhereUniqueInput
  }

  /**
   * dbo_Batchs updateMany
   */
  export type dbo_BatchsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dbo_Batchs.
     */
    data: XOR<dbo_BatchsUpdateManyMutationInput, dbo_BatchsUncheckedUpdateManyInput>
    /**
     * Filter which dbo_Batchs to update
     */
    where?: dbo_BatchsWhereInput
    /**
     * Limit how many dbo_Batchs to update.
     */
    limit?: number
  }

  /**
   * dbo_Batchs updateManyAndReturn
   */
  export type dbo_BatchsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * The data used to update dbo_Batchs.
     */
    data: XOR<dbo_BatchsUpdateManyMutationInput, dbo_BatchsUncheckedUpdateManyInput>
    /**
     * Filter which dbo_Batchs to update
     */
    where?: dbo_BatchsWhereInput
    /**
     * Limit how many dbo_Batchs to update.
     */
    limit?: number
  }

  /**
   * dbo_Batchs upsert
   */
  export type dbo_BatchsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * The filter to search for the dbo_Batchs to update in case it exists.
     */
    where: dbo_BatchsWhereUniqueInput
    /**
     * In case the dbo_Batchs found by the `where` argument doesn't exist, create a new dbo_Batchs with this data.
     */
    create: XOR<dbo_BatchsCreateInput, dbo_BatchsUncheckedCreateInput>
    /**
     * In case the dbo_Batchs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dbo_BatchsUpdateInput, dbo_BatchsUncheckedUpdateInput>
  }

  /**
   * dbo_Batchs delete
   */
  export type dbo_BatchsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
    /**
     * Filter which dbo_Batchs to delete.
     */
    where: dbo_BatchsWhereUniqueInput
  }

  /**
   * dbo_Batchs deleteMany
   */
  export type dbo_BatchsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dbo_Batchs to delete
     */
    where?: dbo_BatchsWhereInput
    /**
     * Limit how many dbo_Batchs to delete.
     */
    limit?: number
  }

  /**
   * dbo_Batchs without action
   */
  export type dbo_BatchsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dbo_Batchs
     */
    select?: dbo_BatchsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the dbo_Batchs
     */
    omit?: dbo_BatchsOmit<ExtArgs> | null
  }


  /**
   * Model docs
   */

  export type AggregateDocs = {
    _count: DocsCountAggregateOutputType | null
    _avg: DocsAvgAggregateOutputType | null
    _sum: DocsSumAggregateOutputType | null
    _min: DocsMinAggregateOutputType | null
    _max: DocsMaxAggregateOutputType | null
  }

  export type DocsAvgAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type DocsSumAggregateOutputType = {
    id: number | null
    plantId: number | null
  }

  export type DocsMinAggregateOutputType = {
    id: number | null
    plantId: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocsMaxAggregateOutputType = {
    id: number | null
    plantId: number | null
    date: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocsCountAggregateOutputType = {
    id: number
    plantId: number
    date: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocsAvgAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type DocsSumAggregateInputType = {
    id?: true
    plantId?: true
  }

  export type DocsMinAggregateInputType = {
    id?: true
    plantId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocsMaxAggregateInputType = {
    id?: true
    plantId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocsCountAggregateInputType = {
    id?: true
    plantId?: true
    date?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which docs to aggregate.
     */
    where?: docsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docs to fetch.
     */
    orderBy?: docsOrderByWithRelationInput | docsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: docsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned docs
    **/
    _count?: true | DocsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocsMaxAggregateInputType
  }

  export type GetDocsAggregateType<T extends DocsAggregateArgs> = {
        [P in keyof T & keyof AggregateDocs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocs[P]>
      : GetScalarType<T[P], AggregateDocs[P]>
  }




  export type docsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: docsWhereInput
    orderBy?: docsOrderByWithAggregationInput | docsOrderByWithAggregationInput[]
    by: DocsScalarFieldEnum[] | DocsScalarFieldEnum
    having?: docsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocsCountAggregateInputType | true
    _avg?: DocsAvgAggregateInputType
    _sum?: DocsSumAggregateInputType
    _min?: DocsMinAggregateInputType
    _max?: DocsMaxAggregateInputType
  }

  export type DocsGroupByOutputType = {
    id: number
    plantId: number | null
    date: Date
    createdAt: Date
    updatedAt: Date
    _count: DocsCountAggregateOutputType | null
    _avg: DocsAvgAggregateOutputType | null
    _sum: DocsSumAggregateOutputType | null
    _min: DocsMinAggregateOutputType | null
    _max: DocsMaxAggregateOutputType | null
  }

  type GetDocsGroupByPayload<T extends docsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocsGroupByOutputType[P]>
            : GetScalarType<T[P], DocsGroupByOutputType[P]>
        }
      >
    >


  export type docsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plants?: boolean | docs$plantsArgs<ExtArgs>
    records?: boolean | docs$recordsArgs<ExtArgs>
    _count?: boolean | DocsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["docs"]>

  export type docsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plants?: boolean | docs$plantsArgs<ExtArgs>
  }, ExtArgs["result"]["docs"]>

  export type docsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plantId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plants?: boolean | docs$plantsArgs<ExtArgs>
  }, ExtArgs["result"]["docs"]>

  export type docsSelectScalar = {
    id?: boolean
    plantId?: boolean
    date?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type docsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plantId" | "date" | "createdAt" | "updatedAt", ExtArgs["result"]["docs"]>
  export type docsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plants?: boolean | docs$plantsArgs<ExtArgs>
    records?: boolean | docs$recordsArgs<ExtArgs>
    _count?: boolean | DocsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type docsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plants?: boolean | docs$plantsArgs<ExtArgs>
  }
  export type docsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plants?: boolean | docs$plantsArgs<ExtArgs>
  }

  export type $docsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "docs"
    objects: {
      plants: Prisma.$plantsPayload<ExtArgs> | null
      records: Prisma.$recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plantId: number | null
      date: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["docs"]>
    composites: {}
  }

  type docsGetPayload<S extends boolean | null | undefined | docsDefaultArgs> = $Result.GetResult<Prisma.$docsPayload, S>

  type docsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<docsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocsCountAggregateInputType | true
    }

  export interface docsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['docs'], meta: { name: 'docs' } }
    /**
     * Find zero or one Docs that matches the filter.
     * @param {docsFindUniqueArgs} args - Arguments to find a Docs
     * @example
     * // Get one Docs
     * const docs = await prisma.docs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends docsFindUniqueArgs>(args: SelectSubset<T, docsFindUniqueArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Docs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {docsFindUniqueOrThrowArgs} args - Arguments to find a Docs
     * @example
     * // Get one Docs
     * const docs = await prisma.docs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends docsFindUniqueOrThrowArgs>(args: SelectSubset<T, docsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Docs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docsFindFirstArgs} args - Arguments to find a Docs
     * @example
     * // Get one Docs
     * const docs = await prisma.docs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends docsFindFirstArgs>(args?: SelectSubset<T, docsFindFirstArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Docs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docsFindFirstOrThrowArgs} args - Arguments to find a Docs
     * @example
     * // Get one Docs
     * const docs = await prisma.docs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends docsFindFirstOrThrowArgs>(args?: SelectSubset<T, docsFindFirstOrThrowArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Docs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Docs
     * const docs = await prisma.docs.findMany()
     * 
     * // Get first 10 Docs
     * const docs = await prisma.docs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const docsWithIdOnly = await prisma.docs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends docsFindManyArgs>(args?: SelectSubset<T, docsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Docs.
     * @param {docsCreateArgs} args - Arguments to create a Docs.
     * @example
     * // Create one Docs
     * const Docs = await prisma.docs.create({
     *   data: {
     *     // ... data to create a Docs
     *   }
     * })
     * 
     */
    create<T extends docsCreateArgs>(args: SelectSubset<T, docsCreateArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Docs.
     * @param {docsCreateManyArgs} args - Arguments to create many Docs.
     * @example
     * // Create many Docs
     * const docs = await prisma.docs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends docsCreateManyArgs>(args?: SelectSubset<T, docsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Docs and returns the data saved in the database.
     * @param {docsCreateManyAndReturnArgs} args - Arguments to create many Docs.
     * @example
     * // Create many Docs
     * const docs = await prisma.docs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Docs and only return the `id`
     * const docsWithIdOnly = await prisma.docs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends docsCreateManyAndReturnArgs>(args?: SelectSubset<T, docsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Docs.
     * @param {docsDeleteArgs} args - Arguments to delete one Docs.
     * @example
     * // Delete one Docs
     * const Docs = await prisma.docs.delete({
     *   where: {
     *     // ... filter to delete one Docs
     *   }
     * })
     * 
     */
    delete<T extends docsDeleteArgs>(args: SelectSubset<T, docsDeleteArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Docs.
     * @param {docsUpdateArgs} args - Arguments to update one Docs.
     * @example
     * // Update one Docs
     * const docs = await prisma.docs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends docsUpdateArgs>(args: SelectSubset<T, docsUpdateArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Docs.
     * @param {docsDeleteManyArgs} args - Arguments to filter Docs to delete.
     * @example
     * // Delete a few Docs
     * const { count } = await prisma.docs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends docsDeleteManyArgs>(args?: SelectSubset<T, docsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Docs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Docs
     * const docs = await prisma.docs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends docsUpdateManyArgs>(args: SelectSubset<T, docsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Docs and returns the data updated in the database.
     * @param {docsUpdateManyAndReturnArgs} args - Arguments to update many Docs.
     * @example
     * // Update many Docs
     * const docs = await prisma.docs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Docs and only return the `id`
     * const docsWithIdOnly = await prisma.docs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends docsUpdateManyAndReturnArgs>(args: SelectSubset<T, docsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Docs.
     * @param {docsUpsertArgs} args - Arguments to update or create a Docs.
     * @example
     * // Update or create a Docs
     * const docs = await prisma.docs.upsert({
     *   create: {
     *     // ... data to create a Docs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Docs we want to update
     *   }
     * })
     */
    upsert<T extends docsUpsertArgs>(args: SelectSubset<T, docsUpsertArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Docs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docsCountArgs} args - Arguments to filter Docs to count.
     * @example
     * // Count the number of Docs
     * const count = await prisma.docs.count({
     *   where: {
     *     // ... the filter for the Docs we want to count
     *   }
     * })
    **/
    count<T extends docsCountArgs>(
      args?: Subset<T, docsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Docs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocsAggregateArgs>(args: Subset<T, DocsAggregateArgs>): Prisma.PrismaPromise<GetDocsAggregateType<T>>

    /**
     * Group by Docs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {docsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends docsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: docsGroupByArgs['orderBy'] }
        : { orderBy?: docsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, docsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the docs model
   */
  readonly fields: docsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for docs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__docsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plants<T extends docs$plantsArgs<ExtArgs> = {}>(args?: Subset<T, docs$plantsArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    records<T extends docs$recordsArgs<ExtArgs> = {}>(args?: Subset<T, docs$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the docs model
   */
  interface docsFieldRefs {
    readonly id: FieldRef<"docs", 'Int'>
    readonly plantId: FieldRef<"docs", 'Int'>
    readonly date: FieldRef<"docs", 'DateTime'>
    readonly createdAt: FieldRef<"docs", 'DateTime'>
    readonly updatedAt: FieldRef<"docs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * docs findUnique
   */
  export type docsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * Filter, which docs to fetch.
     */
    where: docsWhereUniqueInput
  }

  /**
   * docs findUniqueOrThrow
   */
  export type docsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * Filter, which docs to fetch.
     */
    where: docsWhereUniqueInput
  }

  /**
   * docs findFirst
   */
  export type docsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * Filter, which docs to fetch.
     */
    where?: docsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docs to fetch.
     */
    orderBy?: docsOrderByWithRelationInput | docsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for docs.
     */
    cursor?: docsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of docs.
     */
    distinct?: DocsScalarFieldEnum | DocsScalarFieldEnum[]
  }

  /**
   * docs findFirstOrThrow
   */
  export type docsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * Filter, which docs to fetch.
     */
    where?: docsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docs to fetch.
     */
    orderBy?: docsOrderByWithRelationInput | docsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for docs.
     */
    cursor?: docsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of docs.
     */
    distinct?: DocsScalarFieldEnum | DocsScalarFieldEnum[]
  }

  /**
   * docs findMany
   */
  export type docsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * Filter, which docs to fetch.
     */
    where?: docsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of docs to fetch.
     */
    orderBy?: docsOrderByWithRelationInput | docsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing docs.
     */
    cursor?: docsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` docs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` docs.
     */
    skip?: number
    distinct?: DocsScalarFieldEnum | DocsScalarFieldEnum[]
  }

  /**
   * docs create
   */
  export type docsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * The data needed to create a docs.
     */
    data: XOR<docsCreateInput, docsUncheckedCreateInput>
  }

  /**
   * docs createMany
   */
  export type docsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many docs.
     */
    data: docsCreateManyInput | docsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * docs createManyAndReturn
   */
  export type docsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * The data used to create many docs.
     */
    data: docsCreateManyInput | docsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * docs update
   */
  export type docsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * The data needed to update a docs.
     */
    data: XOR<docsUpdateInput, docsUncheckedUpdateInput>
    /**
     * Choose, which docs to update.
     */
    where: docsWhereUniqueInput
  }

  /**
   * docs updateMany
   */
  export type docsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update docs.
     */
    data: XOR<docsUpdateManyMutationInput, docsUncheckedUpdateManyInput>
    /**
     * Filter which docs to update
     */
    where?: docsWhereInput
    /**
     * Limit how many docs to update.
     */
    limit?: number
  }

  /**
   * docs updateManyAndReturn
   */
  export type docsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * The data used to update docs.
     */
    data: XOR<docsUpdateManyMutationInput, docsUncheckedUpdateManyInput>
    /**
     * Filter which docs to update
     */
    where?: docsWhereInput
    /**
     * Limit how many docs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * docs upsert
   */
  export type docsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * The filter to search for the docs to update in case it exists.
     */
    where: docsWhereUniqueInput
    /**
     * In case the docs found by the `where` argument doesn't exist, create a new docs with this data.
     */
    create: XOR<docsCreateInput, docsUncheckedCreateInput>
    /**
     * In case the docs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<docsUpdateInput, docsUncheckedUpdateInput>
  }

  /**
   * docs delete
   */
  export type docsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    /**
     * Filter which docs to delete.
     */
    where: docsWhereUniqueInput
  }

  /**
   * docs deleteMany
   */
  export type docsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which docs to delete
     */
    where?: docsWhereInput
    /**
     * Limit how many docs to delete.
     */
    limit?: number
  }

  /**
   * docs.plants
   */
  export type docs$plantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    where?: plantsWhereInput
  }

  /**
   * docs.records
   */
  export type docs$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    cursor?: recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * docs without action
   */
  export type docsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
  }


  /**
   * Model employees
   */

  export type AggregateEmployees = {
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  export type EmployeesAvgAggregateOutputType = {
    id: number | null
    occupationId: number | null
  }

  export type EmployeesSumAggregateOutputType = {
    id: number | null
    occupationId: number | null
  }

  export type EmployeesMinAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
    occupationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
    occupationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeesCountAggregateOutputType = {
    id: number
    name: number
    barcode: number
    occupationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeesAvgAggregateInputType = {
    id?: true
    occupationId?: true
  }

  export type EmployeesSumAggregateInputType = {
    id?: true
    occupationId?: true
  }

  export type EmployeesMinAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    occupationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeesMaxAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    occupationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeesCountAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    occupationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to aggregate.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned employees
    **/
    _count?: true | EmployeesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeesMaxAggregateInputType
  }

  export type GetEmployeesAggregateType<T extends EmployeesAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployees]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployees[P]>
      : GetScalarType<T[P], AggregateEmployees[P]>
  }




  export type employeesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: employeesWhereInput
    orderBy?: employeesOrderByWithAggregationInput | employeesOrderByWithAggregationInput[]
    by: EmployeesScalarFieldEnum[] | EmployeesScalarFieldEnum
    having?: employeesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeesCountAggregateInputType | true
    _avg?: EmployeesAvgAggregateInputType
    _sum?: EmployeesSumAggregateInputType
    _min?: EmployeesMinAggregateInputType
    _max?: EmployeesMaxAggregateInputType
  }

  export type EmployeesGroupByOutputType = {
    id: number
    name: string
    barcode: string
    occupationId: number | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeesCountAggregateOutputType | null
    _avg: EmployeesAvgAggregateOutputType | null
    _sum: EmployeesSumAggregateOutputType | null
    _min: EmployeesMinAggregateOutputType | null
    _max: EmployeesMaxAggregateOutputType | null
  }

  type GetEmployeesGroupByPayload<T extends employeesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeesGroupByOutputType[P]>
        }
      >
    >


  export type employeesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    occupationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    occupations?: boolean | employees$occupationsArgs<ExtArgs>
    histories?: boolean | employees$historiesArgs<ExtArgs>
    tube_histories?: boolean | employees$tube_historiesArgs<ExtArgs>
    tube_sessions?: boolean | employees$tube_sessionsArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type employeesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    occupationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    occupations?: boolean | employees$occupationsArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type employeesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    occupationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    occupations?: boolean | employees$occupationsArgs<ExtArgs>
  }, ExtArgs["result"]["employees"]>

  export type employeesSelectScalar = {
    id?: boolean
    name?: boolean
    barcode?: boolean
    occupationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type employeesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "barcode" | "occupationId" | "createdAt" | "updatedAt", ExtArgs["result"]["employees"]>
  export type employeesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occupations?: boolean | employees$occupationsArgs<ExtArgs>
    histories?: boolean | employees$historiesArgs<ExtArgs>
    tube_histories?: boolean | employees$tube_historiesArgs<ExtArgs>
    tube_sessions?: boolean | employees$tube_sessionsArgs<ExtArgs>
    _count?: boolean | EmployeesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type employeesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occupations?: boolean | employees$occupationsArgs<ExtArgs>
  }
  export type employeesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    occupations?: boolean | employees$occupationsArgs<ExtArgs>
  }

  export type $employeesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "employees"
    objects: {
      occupations: Prisma.$occupationsPayload<ExtArgs> | null
      histories: Prisma.$historiesPayload<ExtArgs>[]
      tube_histories: Prisma.$tube_historiesPayload<ExtArgs>[]
      tube_sessions: Prisma.$tube_sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      barcode: string
      occupationId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employees"]>
    composites: {}
  }

  type employeesGetPayload<S extends boolean | null | undefined | employeesDefaultArgs> = $Result.GetResult<Prisma.$employeesPayload, S>

  type employeesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<employeesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeesCountAggregateInputType | true
    }

  export interface employeesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['employees'], meta: { name: 'employees' } }
    /**
     * Find zero or one Employees that matches the filter.
     * @param {employeesFindUniqueArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends employeesFindUniqueArgs>(args: SelectSubset<T, employeesFindUniqueArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employees that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {employeesFindUniqueOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends employeesFindUniqueOrThrowArgs>(args: SelectSubset<T, employeesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindFirstArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends employeesFindFirstArgs>(args?: SelectSubset<T, employeesFindFirstArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employees that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindFirstOrThrowArgs} args - Arguments to find a Employees
     * @example
     * // Get one Employees
     * const employees = await prisma.employees.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends employeesFindFirstOrThrowArgs>(args?: SelectSubset<T, employeesFindFirstOrThrowArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employees.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employees.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeesWithIdOnly = await prisma.employees.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends employeesFindManyArgs>(args?: SelectSubset<T, employeesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employees.
     * @param {employeesCreateArgs} args - Arguments to create a Employees.
     * @example
     * // Create one Employees
     * const Employees = await prisma.employees.create({
     *   data: {
     *     // ... data to create a Employees
     *   }
     * })
     * 
     */
    create<T extends employeesCreateArgs>(args: SelectSubset<T, employeesCreateArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {employeesCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends employeesCreateManyArgs>(args?: SelectSubset<T, employeesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {employeesCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employees = await prisma.employees.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends employeesCreateManyAndReturnArgs>(args?: SelectSubset<T, employeesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employees.
     * @param {employeesDeleteArgs} args - Arguments to delete one Employees.
     * @example
     * // Delete one Employees
     * const Employees = await prisma.employees.delete({
     *   where: {
     *     // ... filter to delete one Employees
     *   }
     * })
     * 
     */
    delete<T extends employeesDeleteArgs>(args: SelectSubset<T, employeesDeleteArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employees.
     * @param {employeesUpdateArgs} args - Arguments to update one Employees.
     * @example
     * // Update one Employees
     * const employees = await prisma.employees.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends employeesUpdateArgs>(args: SelectSubset<T, employeesUpdateArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {employeesDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employees.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends employeesDeleteManyArgs>(args?: SelectSubset<T, employeesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends employeesUpdateManyArgs>(args: SelectSubset<T, employeesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {employeesUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employees = await prisma.employees.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeesWithIdOnly = await prisma.employees.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends employeesUpdateManyAndReturnArgs>(args: SelectSubset<T, employeesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employees.
     * @param {employeesUpsertArgs} args - Arguments to update or create a Employees.
     * @example
     * // Update or create a Employees
     * const employees = await prisma.employees.upsert({
     *   create: {
     *     // ... data to create a Employees
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employees we want to update
     *   }
     * })
     */
    upsert<T extends employeesUpsertArgs>(args: SelectSubset<T, employeesUpsertArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employees.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends employeesCountArgs>(
      args?: Subset<T, employeesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeesAggregateArgs>(args: Subset<T, EmployeesAggregateArgs>): Prisma.PrismaPromise<GetEmployeesAggregateType<T>>

    /**
     * Group by Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {employeesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends employeesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: employeesGroupByArgs['orderBy'] }
        : { orderBy?: employeesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, employeesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the employees model
   */
  readonly fields: employeesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for employees.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__employeesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    occupations<T extends employees$occupationsArgs<ExtArgs> = {}>(args?: Subset<T, employees$occupationsArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    histories<T extends employees$historiesArgs<ExtArgs> = {}>(args?: Subset<T, employees$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tube_histories<T extends employees$tube_historiesArgs<ExtArgs> = {}>(args?: Subset<T, employees$tube_historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tube_sessions<T extends employees$tube_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, employees$tube_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the employees model
   */
  interface employeesFieldRefs {
    readonly id: FieldRef<"employees", 'Int'>
    readonly name: FieldRef<"employees", 'String'>
    readonly barcode: FieldRef<"employees", 'String'>
    readonly occupationId: FieldRef<"employees", 'Int'>
    readonly createdAt: FieldRef<"employees", 'DateTime'>
    readonly updatedAt: FieldRef<"employees", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * employees findUnique
   */
  export type employeesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees findUniqueOrThrow
   */
  export type employeesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees findFirst
   */
  export type employeesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees findFirstOrThrow
   */
  export type employeesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of employees.
     */
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees findMany
   */
  export type employeesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter, which employees to fetch.
     */
    where?: employeesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of employees to fetch.
     */
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing employees.
     */
    cursor?: employeesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` employees.
     */
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * employees create
   */
  export type employeesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The data needed to create a employees.
     */
    data: XOR<employeesCreateInput, employeesUncheckedCreateInput>
  }

  /**
   * employees createMany
   */
  export type employeesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many employees.
     */
    data: employeesCreateManyInput | employeesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * employees createManyAndReturn
   */
  export type employeesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * The data used to create many employees.
     */
    data: employeesCreateManyInput | employeesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * employees update
   */
  export type employeesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The data needed to update a employees.
     */
    data: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
    /**
     * Choose, which employees to update.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees updateMany
   */
  export type employeesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update employees.
     */
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeesWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
  }

  /**
   * employees updateManyAndReturn
   */
  export type employeesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * The data used to update employees.
     */
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyInput>
    /**
     * Filter which employees to update
     */
    where?: employeesWhereInput
    /**
     * Limit how many employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * employees upsert
   */
  export type employeesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * The filter to search for the employees to update in case it exists.
     */
    where: employeesWhereUniqueInput
    /**
     * In case the employees found by the `where` argument doesn't exist, create a new employees with this data.
     */
    create: XOR<employeesCreateInput, employeesUncheckedCreateInput>
    /**
     * In case the employees was found with the provided `where` argument, update it with this data.
     */
    update: XOR<employeesUpdateInput, employeesUncheckedUpdateInput>
  }

  /**
   * employees delete
   */
  export type employeesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    /**
     * Filter which employees to delete.
     */
    where: employeesWhereUniqueInput
  }

  /**
   * employees deleteMany
   */
  export type employeesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which employees to delete
     */
    where?: employeesWhereInput
    /**
     * Limit how many employees to delete.
     */
    limit?: number
  }

  /**
   * employees.occupations
   */
  export type employees$occupationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    where?: occupationsWhereInput
  }

  /**
   * employees.histories
   */
  export type employees$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    where?: historiesWhereInput
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    cursor?: historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoriesScalarFieldEnum | HistoriesScalarFieldEnum[]
  }

  /**
   * employees.tube_histories
   */
  export type employees$tube_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    where?: tube_historiesWhereInput
    orderBy?: tube_historiesOrderByWithRelationInput | tube_historiesOrderByWithRelationInput[]
    cursor?: tube_historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_historiesScalarFieldEnum | Tube_historiesScalarFieldEnum[]
  }

  /**
   * employees.tube_sessions
   */
  export type employees$tube_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    where?: tube_sessionsWhereInput
    orderBy?: tube_sessionsOrderByWithRelationInput | tube_sessionsOrderByWithRelationInput[]
    cursor?: tube_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_sessionsScalarFieldEnum | Tube_sessionsScalarFieldEnum[]
  }

  /**
   * employees without action
   */
  export type employeesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
  }


  /**
   * Model histories
   */

  export type AggregateHistories = {
    _count: HistoriesCountAggregateOutputType | null
    _avg: HistoriesAvgAggregateOutputType | null
    _sum: HistoriesSumAggregateOutputType | null
    _min: HistoriesMinAggregateOutputType | null
    _max: HistoriesMaxAggregateOutputType | null
  }

  export type HistoriesAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
    boil_id: number | null
    historyTypeId: number | null
    userId: number | null
    employeeId: number | null
    note_id: number | null
    plant_id: number | null
  }

  export type HistoriesSumAggregateOutputType = {
    id: number | null
    record_id: number | null
    boil_id: number | null
    historyTypeId: number | null
    userId: number | null
    employeeId: number | null
    note_id: number | null
    plant_id: number | null
  }

  export type HistoriesMinAggregateOutputType = {
    id: number | null
    record_id: number | null
    boil_id: number | null
    historyTypeId: number | null
    userId: number | null
    employeeId: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    note_id: number | null
    plant_id: number | null
  }

  export type HistoriesMaxAggregateOutputType = {
    id: number | null
    record_id: number | null
    boil_id: number | null
    historyTypeId: number | null
    userId: number | null
    employeeId: number | null
    note: string | null
    createdAt: Date | null
    updatedAt: Date | null
    note_id: number | null
    plant_id: number | null
  }

  export type HistoriesCountAggregateOutputType = {
    id: number
    record_id: number
    boil_id: number
    historyTypeId: number
    userId: number
    employeeId: number
    note: number
    createdAt: number
    updatedAt: number
    note_id: number
    plant_id: number
    _all: number
  }


  export type HistoriesAvgAggregateInputType = {
    id?: true
    record_id?: true
    boil_id?: true
    historyTypeId?: true
    userId?: true
    employeeId?: true
    note_id?: true
    plant_id?: true
  }

  export type HistoriesSumAggregateInputType = {
    id?: true
    record_id?: true
    boil_id?: true
    historyTypeId?: true
    userId?: true
    employeeId?: true
    note_id?: true
    plant_id?: true
  }

  export type HistoriesMinAggregateInputType = {
    id?: true
    record_id?: true
    boil_id?: true
    historyTypeId?: true
    userId?: true
    employeeId?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    note_id?: true
    plant_id?: true
  }

  export type HistoriesMaxAggregateInputType = {
    id?: true
    record_id?: true
    boil_id?: true
    historyTypeId?: true
    userId?: true
    employeeId?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    note_id?: true
    plant_id?: true
  }

  export type HistoriesCountAggregateInputType = {
    id?: true
    record_id?: true
    boil_id?: true
    historyTypeId?: true
    userId?: true
    employeeId?: true
    note?: true
    createdAt?: true
    updatedAt?: true
    note_id?: true
    plant_id?: true
    _all?: true
  }

  export type HistoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histories to aggregate.
     */
    where?: historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned histories
    **/
    _count?: true | HistoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistoriesMaxAggregateInputType
  }

  export type GetHistoriesAggregateType<T extends HistoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateHistories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistories[P]>
      : GetScalarType<T[P], AggregateHistories[P]>
  }




  export type historiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: historiesWhereInput
    orderBy?: historiesOrderByWithAggregationInput | historiesOrderByWithAggregationInput[]
    by: HistoriesScalarFieldEnum[] | HistoriesScalarFieldEnum
    having?: historiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistoriesCountAggregateInputType | true
    _avg?: HistoriesAvgAggregateInputType
    _sum?: HistoriesSumAggregateInputType
    _min?: HistoriesMinAggregateInputType
    _max?: HistoriesMaxAggregateInputType
  }

  export type HistoriesGroupByOutputType = {
    id: number
    record_id: number | null
    boil_id: number | null
    historyTypeId: number | null
    userId: number | null
    employeeId: number | null
    note: string | null
    createdAt: Date
    updatedAt: Date
    note_id: number | null
    plant_id: number | null
    _count: HistoriesCountAggregateOutputType | null
    _avg: HistoriesAvgAggregateOutputType | null
    _sum: HistoriesSumAggregateOutputType | null
    _min: HistoriesMinAggregateOutputType | null
    _max: HistoriesMaxAggregateOutputType | null
  }

  type GetHistoriesGroupByPayload<T extends historiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistoriesGroupByOutputType[P]>
            : GetScalarType<T[P], HistoriesGroupByOutputType[P]>
        }
      >
    >


  export type historiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    boil_id?: boolean
    historyTypeId?: boolean
    userId?: boolean
    employeeId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note_id?: boolean
    plant_id?: boolean
    employees?: boolean | histories$employeesArgs<ExtArgs>
    history_types?: boolean | histories$history_typesArgs<ExtArgs>
    records?: boolean | histories$recordsArgs<ExtArgs>
    users?: boolean | histories$usersArgs<ExtArgs>
  }, ExtArgs["result"]["histories"]>

  export type historiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    boil_id?: boolean
    historyTypeId?: boolean
    userId?: boolean
    employeeId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note_id?: boolean
    plant_id?: boolean
    employees?: boolean | histories$employeesArgs<ExtArgs>
    history_types?: boolean | histories$history_typesArgs<ExtArgs>
    records?: boolean | histories$recordsArgs<ExtArgs>
    users?: boolean | histories$usersArgs<ExtArgs>
  }, ExtArgs["result"]["histories"]>

  export type historiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    boil_id?: boolean
    historyTypeId?: boolean
    userId?: boolean
    employeeId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note_id?: boolean
    plant_id?: boolean
    employees?: boolean | histories$employeesArgs<ExtArgs>
    history_types?: boolean | histories$history_typesArgs<ExtArgs>
    records?: boolean | histories$recordsArgs<ExtArgs>
    users?: boolean | histories$usersArgs<ExtArgs>
  }, ExtArgs["result"]["histories"]>

  export type historiesSelectScalar = {
    id?: boolean
    record_id?: boolean
    boil_id?: boolean
    historyTypeId?: boolean
    userId?: boolean
    employeeId?: boolean
    note?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    note_id?: boolean
    plant_id?: boolean
  }

  export type historiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "record_id" | "boil_id" | "historyTypeId" | "userId" | "employeeId" | "note" | "createdAt" | "updatedAt" | "note_id" | "plant_id", ExtArgs["result"]["histories"]>
  export type historiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | histories$employeesArgs<ExtArgs>
    history_types?: boolean | histories$history_typesArgs<ExtArgs>
    records?: boolean | histories$recordsArgs<ExtArgs>
    users?: boolean | histories$usersArgs<ExtArgs>
  }
  export type historiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | histories$employeesArgs<ExtArgs>
    history_types?: boolean | histories$history_typesArgs<ExtArgs>
    records?: boolean | histories$recordsArgs<ExtArgs>
    users?: boolean | histories$usersArgs<ExtArgs>
  }
  export type historiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | histories$employeesArgs<ExtArgs>
    history_types?: boolean | histories$history_typesArgs<ExtArgs>
    records?: boolean | histories$recordsArgs<ExtArgs>
    users?: boolean | histories$usersArgs<ExtArgs>
  }

  export type $historiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "histories"
    objects: {
      employees: Prisma.$employeesPayload<ExtArgs> | null
      history_types: Prisma.$history_typesPayload<ExtArgs> | null
      records: Prisma.$recordsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      record_id: number | null
      boil_id: number | null
      historyTypeId: number | null
      userId: number | null
      employeeId: number | null
      note: string | null
      createdAt: Date
      updatedAt: Date
      note_id: number | null
      plant_id: number | null
    }, ExtArgs["result"]["histories"]>
    composites: {}
  }

  type historiesGetPayload<S extends boolean | null | undefined | historiesDefaultArgs> = $Result.GetResult<Prisma.$historiesPayload, S>

  type historiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<historiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HistoriesCountAggregateInputType | true
    }

  export interface historiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['histories'], meta: { name: 'histories' } }
    /**
     * Find zero or one Histories that matches the filter.
     * @param {historiesFindUniqueArgs} args - Arguments to find a Histories
     * @example
     * // Get one Histories
     * const histories = await prisma.histories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends historiesFindUniqueArgs>(args: SelectSubset<T, historiesFindUniqueArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Histories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {historiesFindUniqueOrThrowArgs} args - Arguments to find a Histories
     * @example
     * // Get one Histories
     * const histories = await prisma.histories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends historiesFindUniqueOrThrowArgs>(args: SelectSubset<T, historiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historiesFindFirstArgs} args - Arguments to find a Histories
     * @example
     * // Get one Histories
     * const histories = await prisma.histories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends historiesFindFirstArgs>(args?: SelectSubset<T, historiesFindFirstArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Histories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historiesFindFirstOrThrowArgs} args - Arguments to find a Histories
     * @example
     * // Get one Histories
     * const histories = await prisma.histories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends historiesFindFirstOrThrowArgs>(args?: SelectSubset<T, historiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Histories
     * const histories = await prisma.histories.findMany()
     * 
     * // Get first 10 Histories
     * const histories = await prisma.histories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historiesWithIdOnly = await prisma.histories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends historiesFindManyArgs>(args?: SelectSubset<T, historiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Histories.
     * @param {historiesCreateArgs} args - Arguments to create a Histories.
     * @example
     * // Create one Histories
     * const Histories = await prisma.histories.create({
     *   data: {
     *     // ... data to create a Histories
     *   }
     * })
     * 
     */
    create<T extends historiesCreateArgs>(args: SelectSubset<T, historiesCreateArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Histories.
     * @param {historiesCreateManyArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const histories = await prisma.histories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends historiesCreateManyArgs>(args?: SelectSubset<T, historiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Histories and returns the data saved in the database.
     * @param {historiesCreateManyAndReturnArgs} args - Arguments to create many Histories.
     * @example
     * // Create many Histories
     * const histories = await prisma.histories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Histories and only return the `id`
     * const historiesWithIdOnly = await prisma.histories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends historiesCreateManyAndReturnArgs>(args?: SelectSubset<T, historiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Histories.
     * @param {historiesDeleteArgs} args - Arguments to delete one Histories.
     * @example
     * // Delete one Histories
     * const Histories = await prisma.histories.delete({
     *   where: {
     *     // ... filter to delete one Histories
     *   }
     * })
     * 
     */
    delete<T extends historiesDeleteArgs>(args: SelectSubset<T, historiesDeleteArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Histories.
     * @param {historiesUpdateArgs} args - Arguments to update one Histories.
     * @example
     * // Update one Histories
     * const histories = await prisma.histories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends historiesUpdateArgs>(args: SelectSubset<T, historiesUpdateArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Histories.
     * @param {historiesDeleteManyArgs} args - Arguments to filter Histories to delete.
     * @example
     * // Delete a few Histories
     * const { count } = await prisma.histories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends historiesDeleteManyArgs>(args?: SelectSubset<T, historiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Histories
     * const histories = await prisma.histories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends historiesUpdateManyArgs>(args: SelectSubset<T, historiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Histories and returns the data updated in the database.
     * @param {historiesUpdateManyAndReturnArgs} args - Arguments to update many Histories.
     * @example
     * // Update many Histories
     * const histories = await prisma.histories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Histories and only return the `id`
     * const historiesWithIdOnly = await prisma.histories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends historiesUpdateManyAndReturnArgs>(args: SelectSubset<T, historiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Histories.
     * @param {historiesUpsertArgs} args - Arguments to update or create a Histories.
     * @example
     * // Update or create a Histories
     * const histories = await prisma.histories.upsert({
     *   create: {
     *     // ... data to create a Histories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Histories we want to update
     *   }
     * })
     */
    upsert<T extends historiesUpsertArgs>(args: SelectSubset<T, historiesUpsertArgs<ExtArgs>>): Prisma__historiesClient<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historiesCountArgs} args - Arguments to filter Histories to count.
     * @example
     * // Count the number of Histories
     * const count = await prisma.histories.count({
     *   where: {
     *     // ... the filter for the Histories we want to count
     *   }
     * })
    **/
    count<T extends historiesCountArgs>(
      args?: Subset<T, historiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistoriesAggregateArgs>(args: Subset<T, HistoriesAggregateArgs>): Prisma.PrismaPromise<GetHistoriesAggregateType<T>>

    /**
     * Group by Histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {historiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends historiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: historiesGroupByArgs['orderBy'] }
        : { orderBy?: historiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, historiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the histories model
   */
  readonly fields: historiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for histories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__historiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends histories$employeesArgs<ExtArgs> = {}>(args?: Subset<T, histories$employeesArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    history_types<T extends histories$history_typesArgs<ExtArgs> = {}>(args?: Subset<T, histories$history_typesArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    records<T extends histories$recordsArgs<ExtArgs> = {}>(args?: Subset<T, histories$recordsArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends histories$usersArgs<ExtArgs> = {}>(args?: Subset<T, histories$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the histories model
   */
  interface historiesFieldRefs {
    readonly id: FieldRef<"histories", 'Int'>
    readonly record_id: FieldRef<"histories", 'Int'>
    readonly boil_id: FieldRef<"histories", 'Int'>
    readonly historyTypeId: FieldRef<"histories", 'Int'>
    readonly userId: FieldRef<"histories", 'Int'>
    readonly employeeId: FieldRef<"histories", 'Int'>
    readonly note: FieldRef<"histories", 'String'>
    readonly createdAt: FieldRef<"histories", 'DateTime'>
    readonly updatedAt: FieldRef<"histories", 'DateTime'>
    readonly note_id: FieldRef<"histories", 'Int'>
    readonly plant_id: FieldRef<"histories", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * histories findUnique
   */
  export type historiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * Filter, which histories to fetch.
     */
    where: historiesWhereUniqueInput
  }

  /**
   * histories findUniqueOrThrow
   */
  export type historiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * Filter, which histories to fetch.
     */
    where: historiesWhereUniqueInput
  }

  /**
   * histories findFirst
   */
  export type historiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * Filter, which histories to fetch.
     */
    where?: historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histories.
     */
    cursor?: historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histories.
     */
    distinct?: HistoriesScalarFieldEnum | HistoriesScalarFieldEnum[]
  }

  /**
   * histories findFirstOrThrow
   */
  export type historiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * Filter, which histories to fetch.
     */
    where?: historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for histories.
     */
    cursor?: historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of histories.
     */
    distinct?: HistoriesScalarFieldEnum | HistoriesScalarFieldEnum[]
  }

  /**
   * histories findMany
   */
  export type historiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * Filter, which histories to fetch.
     */
    where?: historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of histories to fetch.
     */
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing histories.
     */
    cursor?: historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` histories.
     */
    skip?: number
    distinct?: HistoriesScalarFieldEnum | HistoriesScalarFieldEnum[]
  }

  /**
   * histories create
   */
  export type historiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * The data needed to create a histories.
     */
    data: XOR<historiesCreateInput, historiesUncheckedCreateInput>
  }

  /**
   * histories createMany
   */
  export type historiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many histories.
     */
    data: historiesCreateManyInput | historiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * histories createManyAndReturn
   */
  export type historiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * The data used to create many histories.
     */
    data: historiesCreateManyInput | historiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * histories update
   */
  export type historiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * The data needed to update a histories.
     */
    data: XOR<historiesUpdateInput, historiesUncheckedUpdateInput>
    /**
     * Choose, which histories to update.
     */
    where: historiesWhereUniqueInput
  }

  /**
   * histories updateMany
   */
  export type historiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update histories.
     */
    data: XOR<historiesUpdateManyMutationInput, historiesUncheckedUpdateManyInput>
    /**
     * Filter which histories to update
     */
    where?: historiesWhereInput
    /**
     * Limit how many histories to update.
     */
    limit?: number
  }

  /**
   * histories updateManyAndReturn
   */
  export type historiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * The data used to update histories.
     */
    data: XOR<historiesUpdateManyMutationInput, historiesUncheckedUpdateManyInput>
    /**
     * Filter which histories to update
     */
    where?: historiesWhereInput
    /**
     * Limit how many histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * histories upsert
   */
  export type historiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * The filter to search for the histories to update in case it exists.
     */
    where: historiesWhereUniqueInput
    /**
     * In case the histories found by the `where` argument doesn't exist, create a new histories with this data.
     */
    create: XOR<historiesCreateInput, historiesUncheckedCreateInput>
    /**
     * In case the histories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<historiesUpdateInput, historiesUncheckedUpdateInput>
  }

  /**
   * histories delete
   */
  export type historiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    /**
     * Filter which histories to delete.
     */
    where: historiesWhereUniqueInput
  }

  /**
   * histories deleteMany
   */
  export type historiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which histories to delete
     */
    where?: historiesWhereInput
    /**
     * Limit how many histories to delete.
     */
    limit?: number
  }

  /**
   * histories.employees
   */
  export type histories$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    where?: employeesWhereInput
  }

  /**
   * histories.history_types
   */
  export type histories$history_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    where?: history_typesWhereInput
  }

  /**
   * histories.records
   */
  export type histories$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
  }

  /**
   * histories.users
   */
  export type histories$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * histories without action
   */
  export type historiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
  }


  /**
   * Model history_types
   */

  export type AggregateHistory_types = {
    _count: History_typesCountAggregateOutputType | null
    _avg: History_typesAvgAggregateOutputType | null
    _sum: History_typesSumAggregateOutputType | null
    _min: History_typesMinAggregateOutputType | null
    _max: History_typesMaxAggregateOutputType | null
  }

  export type History_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type History_typesSumAggregateOutputType = {
    id: number | null
  }

  export type History_typesMinAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
    for_boil: boolean | null
  }

  export type History_typesMaxAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
    for_boil: boolean | null
  }

  export type History_typesCountAggregateOutputType = {
    id: number
    value: number
    description: number
    for_boil: number
    _all: number
  }


  export type History_typesAvgAggregateInputType = {
    id?: true
  }

  export type History_typesSumAggregateInputType = {
    id?: true
  }

  export type History_typesMinAggregateInputType = {
    id?: true
    value?: true
    description?: true
    for_boil?: true
  }

  export type History_typesMaxAggregateInputType = {
    id?: true
    value?: true
    description?: true
    for_boil?: true
  }

  export type History_typesCountAggregateInputType = {
    id?: true
    value?: true
    description?: true
    for_boil?: true
    _all?: true
  }

  export type History_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which history_types to aggregate.
     */
    where?: history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of history_types to fetch.
     */
    orderBy?: history_typesOrderByWithRelationInput | history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` history_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned history_types
    **/
    _count?: true | History_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: History_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: History_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: History_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: History_typesMaxAggregateInputType
  }

  export type GetHistory_typesAggregateType<T extends History_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateHistory_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistory_types[P]>
      : GetScalarType<T[P], AggregateHistory_types[P]>
  }




  export type history_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: history_typesWhereInput
    orderBy?: history_typesOrderByWithAggregationInput | history_typesOrderByWithAggregationInput[]
    by: History_typesScalarFieldEnum[] | History_typesScalarFieldEnum
    having?: history_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: History_typesCountAggregateInputType | true
    _avg?: History_typesAvgAggregateInputType
    _sum?: History_typesSumAggregateInputType
    _min?: History_typesMinAggregateInputType
    _max?: History_typesMaxAggregateInputType
  }

  export type History_typesGroupByOutputType = {
    id: number
    value: string
    description: string
    for_boil: boolean | null
    _count: History_typesCountAggregateOutputType | null
    _avg: History_typesAvgAggregateOutputType | null
    _sum: History_typesSumAggregateOutputType | null
    _min: History_typesMinAggregateOutputType | null
    _max: History_typesMaxAggregateOutputType | null
  }

  type GetHistory_typesGroupByPayload<T extends history_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<History_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof History_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], History_typesGroupByOutputType[P]>
            : GetScalarType<T[P], History_typesGroupByOutputType[P]>
        }
      >
    >


  export type history_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
    for_boil?: boolean
    histories?: boolean | history_types$historiesArgs<ExtArgs>
    _count?: boolean | History_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["history_types"]>

  export type history_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
    for_boil?: boolean
  }, ExtArgs["result"]["history_types"]>

  export type history_typesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
    for_boil?: boolean
  }, ExtArgs["result"]["history_types"]>

  export type history_typesSelectScalar = {
    id?: boolean
    value?: boolean
    description?: boolean
    for_boil?: boolean
  }

  export type history_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "description" | "for_boil", ExtArgs["result"]["history_types"]>
  export type history_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | history_types$historiesArgs<ExtArgs>
    _count?: boolean | History_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type history_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type history_typesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $history_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "history_types"
    objects: {
      histories: Prisma.$historiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      description: string
      for_boil: boolean | null
    }, ExtArgs["result"]["history_types"]>
    composites: {}
  }

  type history_typesGetPayload<S extends boolean | null | undefined | history_typesDefaultArgs> = $Result.GetResult<Prisma.$history_typesPayload, S>

  type history_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<history_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: History_typesCountAggregateInputType | true
    }

  export interface history_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['history_types'], meta: { name: 'history_types' } }
    /**
     * Find zero or one History_types that matches the filter.
     * @param {history_typesFindUniqueArgs} args - Arguments to find a History_types
     * @example
     * // Get one History_types
     * const history_types = await prisma.history_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends history_typesFindUniqueArgs>(args: SelectSubset<T, history_typesFindUniqueArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one History_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {history_typesFindUniqueOrThrowArgs} args - Arguments to find a History_types
     * @example
     * // Get one History_types
     * const history_types = await prisma.history_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends history_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, history_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first History_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {history_typesFindFirstArgs} args - Arguments to find a History_types
     * @example
     * // Get one History_types
     * const history_types = await prisma.history_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends history_typesFindFirstArgs>(args?: SelectSubset<T, history_typesFindFirstArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first History_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {history_typesFindFirstOrThrowArgs} args - Arguments to find a History_types
     * @example
     * // Get one History_types
     * const history_types = await prisma.history_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends history_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, history_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more History_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {history_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all History_types
     * const history_types = await prisma.history_types.findMany()
     * 
     * // Get first 10 History_types
     * const history_types = await prisma.history_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const history_typesWithIdOnly = await prisma.history_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends history_typesFindManyArgs>(args?: SelectSubset<T, history_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a History_types.
     * @param {history_typesCreateArgs} args - Arguments to create a History_types.
     * @example
     * // Create one History_types
     * const History_types = await prisma.history_types.create({
     *   data: {
     *     // ... data to create a History_types
     *   }
     * })
     * 
     */
    create<T extends history_typesCreateArgs>(args: SelectSubset<T, history_typesCreateArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many History_types.
     * @param {history_typesCreateManyArgs} args - Arguments to create many History_types.
     * @example
     * // Create many History_types
     * const history_types = await prisma.history_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends history_typesCreateManyArgs>(args?: SelectSubset<T, history_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many History_types and returns the data saved in the database.
     * @param {history_typesCreateManyAndReturnArgs} args - Arguments to create many History_types.
     * @example
     * // Create many History_types
     * const history_types = await prisma.history_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many History_types and only return the `id`
     * const history_typesWithIdOnly = await prisma.history_types.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends history_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, history_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a History_types.
     * @param {history_typesDeleteArgs} args - Arguments to delete one History_types.
     * @example
     * // Delete one History_types
     * const History_types = await prisma.history_types.delete({
     *   where: {
     *     // ... filter to delete one History_types
     *   }
     * })
     * 
     */
    delete<T extends history_typesDeleteArgs>(args: SelectSubset<T, history_typesDeleteArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one History_types.
     * @param {history_typesUpdateArgs} args - Arguments to update one History_types.
     * @example
     * // Update one History_types
     * const history_types = await prisma.history_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends history_typesUpdateArgs>(args: SelectSubset<T, history_typesUpdateArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more History_types.
     * @param {history_typesDeleteManyArgs} args - Arguments to filter History_types to delete.
     * @example
     * // Delete a few History_types
     * const { count } = await prisma.history_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends history_typesDeleteManyArgs>(args?: SelectSubset<T, history_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more History_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {history_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many History_types
     * const history_types = await prisma.history_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends history_typesUpdateManyArgs>(args: SelectSubset<T, history_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more History_types and returns the data updated in the database.
     * @param {history_typesUpdateManyAndReturnArgs} args - Arguments to update many History_types.
     * @example
     * // Update many History_types
     * const history_types = await prisma.history_types.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more History_types and only return the `id`
     * const history_typesWithIdOnly = await prisma.history_types.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends history_typesUpdateManyAndReturnArgs>(args: SelectSubset<T, history_typesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one History_types.
     * @param {history_typesUpsertArgs} args - Arguments to update or create a History_types.
     * @example
     * // Update or create a History_types
     * const history_types = await prisma.history_types.upsert({
     *   create: {
     *     // ... data to create a History_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the History_types we want to update
     *   }
     * })
     */
    upsert<T extends history_typesUpsertArgs>(args: SelectSubset<T, history_typesUpsertArgs<ExtArgs>>): Prisma__history_typesClient<$Result.GetResult<Prisma.$history_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of History_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {history_typesCountArgs} args - Arguments to filter History_types to count.
     * @example
     * // Count the number of History_types
     * const count = await prisma.history_types.count({
     *   where: {
     *     // ... the filter for the History_types we want to count
     *   }
     * })
    **/
    count<T extends history_typesCountArgs>(
      args?: Subset<T, history_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], History_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a History_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {History_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends History_typesAggregateArgs>(args: Subset<T, History_typesAggregateArgs>): Prisma.PrismaPromise<GetHistory_typesAggregateType<T>>

    /**
     * Group by History_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {history_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends history_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: history_typesGroupByArgs['orderBy'] }
        : { orderBy?: history_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, history_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistory_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the history_types model
   */
  readonly fields: history_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for history_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__history_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    histories<T extends history_types$historiesArgs<ExtArgs> = {}>(args?: Subset<T, history_types$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the history_types model
   */
  interface history_typesFieldRefs {
    readonly id: FieldRef<"history_types", 'Int'>
    readonly value: FieldRef<"history_types", 'String'>
    readonly description: FieldRef<"history_types", 'String'>
    readonly for_boil: FieldRef<"history_types", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * history_types findUnique
   */
  export type history_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * Filter, which history_types to fetch.
     */
    where: history_typesWhereUniqueInput
  }

  /**
   * history_types findUniqueOrThrow
   */
  export type history_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * Filter, which history_types to fetch.
     */
    where: history_typesWhereUniqueInput
  }

  /**
   * history_types findFirst
   */
  export type history_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * Filter, which history_types to fetch.
     */
    where?: history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of history_types to fetch.
     */
    orderBy?: history_typesOrderByWithRelationInput | history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for history_types.
     */
    cursor?: history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` history_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of history_types.
     */
    distinct?: History_typesScalarFieldEnum | History_typesScalarFieldEnum[]
  }

  /**
   * history_types findFirstOrThrow
   */
  export type history_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * Filter, which history_types to fetch.
     */
    where?: history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of history_types to fetch.
     */
    orderBy?: history_typesOrderByWithRelationInput | history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for history_types.
     */
    cursor?: history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` history_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of history_types.
     */
    distinct?: History_typesScalarFieldEnum | History_typesScalarFieldEnum[]
  }

  /**
   * history_types findMany
   */
  export type history_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * Filter, which history_types to fetch.
     */
    where?: history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of history_types to fetch.
     */
    orderBy?: history_typesOrderByWithRelationInput | history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing history_types.
     */
    cursor?: history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` history_types.
     */
    skip?: number
    distinct?: History_typesScalarFieldEnum | History_typesScalarFieldEnum[]
  }

  /**
   * history_types create
   */
  export type history_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a history_types.
     */
    data: XOR<history_typesCreateInput, history_typesUncheckedCreateInput>
  }

  /**
   * history_types createMany
   */
  export type history_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many history_types.
     */
    data: history_typesCreateManyInput | history_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * history_types createManyAndReturn
   */
  export type history_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * The data used to create many history_types.
     */
    data: history_typesCreateManyInput | history_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * history_types update
   */
  export type history_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a history_types.
     */
    data: XOR<history_typesUpdateInput, history_typesUncheckedUpdateInput>
    /**
     * Choose, which history_types to update.
     */
    where: history_typesWhereUniqueInput
  }

  /**
   * history_types updateMany
   */
  export type history_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update history_types.
     */
    data: XOR<history_typesUpdateManyMutationInput, history_typesUncheckedUpdateManyInput>
    /**
     * Filter which history_types to update
     */
    where?: history_typesWhereInput
    /**
     * Limit how many history_types to update.
     */
    limit?: number
  }

  /**
   * history_types updateManyAndReturn
   */
  export type history_typesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * The data used to update history_types.
     */
    data: XOR<history_typesUpdateManyMutationInput, history_typesUncheckedUpdateManyInput>
    /**
     * Filter which history_types to update
     */
    where?: history_typesWhereInput
    /**
     * Limit how many history_types to update.
     */
    limit?: number
  }

  /**
   * history_types upsert
   */
  export type history_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the history_types to update in case it exists.
     */
    where: history_typesWhereUniqueInput
    /**
     * In case the history_types found by the `where` argument doesn't exist, create a new history_types with this data.
     */
    create: XOR<history_typesCreateInput, history_typesUncheckedCreateInput>
    /**
     * In case the history_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<history_typesUpdateInput, history_typesUncheckedUpdateInput>
  }

  /**
   * history_types delete
   */
  export type history_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
    /**
     * Filter which history_types to delete.
     */
    where: history_typesWhereUniqueInput
  }

  /**
   * history_types deleteMany
   */
  export type history_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which history_types to delete
     */
    where?: history_typesWhereInput
    /**
     * Limit how many history_types to delete.
     */
    limit?: number
  }

  /**
   * history_types.histories
   */
  export type history_types$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    where?: historiesWhereInput
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    cursor?: historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoriesScalarFieldEnum | HistoriesScalarFieldEnum[]
  }

  /**
   * history_types without action
   */
  export type history_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the history_types
     */
    select?: history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the history_types
     */
    omit?: history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: history_typesInclude<ExtArgs> | null
  }


  /**
   * Model marking_sample
   */

  export type AggregateMarking_sample = {
    _count: Marking_sampleCountAggregateOutputType | null
    _avg: Marking_sampleAvgAggregateOutputType | null
    _sum: Marking_sampleSumAggregateOutputType | null
    _min: Marking_sampleMinAggregateOutputType | null
    _max: Marking_sampleMaxAggregateOutputType | null
  }

  export type Marking_sampleAvgAggregateOutputType = {
    id: number | null
  }

  export type Marking_sampleSumAggregateOutputType = {
    id: number | null
  }

  export type Marking_sampleMinAggregateOutputType = {
    id: number | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Marking_sampleMaxAggregateOutputType = {
    id: number | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Marking_sampleCountAggregateOutputType = {
    id: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Marking_sampleAvgAggregateInputType = {
    id?: true
  }

  export type Marking_sampleSumAggregateInputType = {
    id?: true
  }

  export type Marking_sampleMinAggregateInputType = {
    id?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Marking_sampleMaxAggregateInputType = {
    id?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Marking_sampleCountAggregateInputType = {
    id?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Marking_sampleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marking_sample to aggregate.
     */
    where?: marking_sampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marking_samples to fetch.
     */
    orderBy?: marking_sampleOrderByWithRelationInput | marking_sampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: marking_sampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marking_samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marking_samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned marking_samples
    **/
    _count?: true | Marking_sampleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Marking_sampleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Marking_sampleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Marking_sampleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Marking_sampleMaxAggregateInputType
  }

  export type GetMarking_sampleAggregateType<T extends Marking_sampleAggregateArgs> = {
        [P in keyof T & keyof AggregateMarking_sample]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMarking_sample[P]>
      : GetScalarType<T[P], AggregateMarking_sample[P]>
  }




  export type marking_sampleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: marking_sampleWhereInput
    orderBy?: marking_sampleOrderByWithAggregationInput | marking_sampleOrderByWithAggregationInput[]
    by: Marking_sampleScalarFieldEnum[] | Marking_sampleScalarFieldEnum
    having?: marking_sampleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Marking_sampleCountAggregateInputType | true
    _avg?: Marking_sampleAvgAggregateInputType
    _sum?: Marking_sampleSumAggregateInputType
    _min?: Marking_sampleMinAggregateInputType
    _max?: Marking_sampleMaxAggregateInputType
  }

  export type Marking_sampleGroupByOutputType = {
    id: number
    value: string | null
    createdAt: Date
    updatedAt: Date
    _count: Marking_sampleCountAggregateOutputType | null
    _avg: Marking_sampleAvgAggregateOutputType | null
    _sum: Marking_sampleSumAggregateOutputType | null
    _min: Marking_sampleMinAggregateOutputType | null
    _max: Marking_sampleMaxAggregateOutputType | null
  }

  type GetMarking_sampleGroupByPayload<T extends marking_sampleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Marking_sampleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Marking_sampleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Marking_sampleGroupByOutputType[P]>
            : GetScalarType<T[P], Marking_sampleGroupByOutputType[P]>
        }
      >
    >


  export type marking_sampleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    record_regulations?: boolean | marking_sample$record_regulationsArgs<ExtArgs>
    regulations?: boolean | marking_sample$regulationsArgs<ExtArgs>
    _count?: boolean | Marking_sampleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["marking_sample"]>

  export type marking_sampleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marking_sample"]>

  export type marking_sampleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["marking_sample"]>

  export type marking_sampleSelectScalar = {
    id?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type marking_sampleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["marking_sample"]>
  export type marking_sampleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    record_regulations?: boolean | marking_sample$record_regulationsArgs<ExtArgs>
    regulations?: boolean | marking_sample$regulationsArgs<ExtArgs>
    _count?: boolean | Marking_sampleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type marking_sampleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type marking_sampleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $marking_samplePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "marking_sample"
    objects: {
      record_regulations: Prisma.$record_regulationsPayload<ExtArgs>[]
      regulations: Prisma.$regulationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["marking_sample"]>
    composites: {}
  }

  type marking_sampleGetPayload<S extends boolean | null | undefined | marking_sampleDefaultArgs> = $Result.GetResult<Prisma.$marking_samplePayload, S>

  type marking_sampleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<marking_sampleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Marking_sampleCountAggregateInputType | true
    }

  export interface marking_sampleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['marking_sample'], meta: { name: 'marking_sample' } }
    /**
     * Find zero or one Marking_sample that matches the filter.
     * @param {marking_sampleFindUniqueArgs} args - Arguments to find a Marking_sample
     * @example
     * // Get one Marking_sample
     * const marking_sample = await prisma.marking_sample.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends marking_sampleFindUniqueArgs>(args: SelectSubset<T, marking_sampleFindUniqueArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Marking_sample that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {marking_sampleFindUniqueOrThrowArgs} args - Arguments to find a Marking_sample
     * @example
     * // Get one Marking_sample
     * const marking_sample = await prisma.marking_sample.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends marking_sampleFindUniqueOrThrowArgs>(args: SelectSubset<T, marking_sampleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marking_sample that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marking_sampleFindFirstArgs} args - Arguments to find a Marking_sample
     * @example
     * // Get one Marking_sample
     * const marking_sample = await prisma.marking_sample.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends marking_sampleFindFirstArgs>(args?: SelectSubset<T, marking_sampleFindFirstArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Marking_sample that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marking_sampleFindFirstOrThrowArgs} args - Arguments to find a Marking_sample
     * @example
     * // Get one Marking_sample
     * const marking_sample = await prisma.marking_sample.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends marking_sampleFindFirstOrThrowArgs>(args?: SelectSubset<T, marking_sampleFindFirstOrThrowArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Marking_samples that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marking_sampleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Marking_samples
     * const marking_samples = await prisma.marking_sample.findMany()
     * 
     * // Get first 10 Marking_samples
     * const marking_samples = await prisma.marking_sample.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const marking_sampleWithIdOnly = await prisma.marking_sample.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends marking_sampleFindManyArgs>(args?: SelectSubset<T, marking_sampleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Marking_sample.
     * @param {marking_sampleCreateArgs} args - Arguments to create a Marking_sample.
     * @example
     * // Create one Marking_sample
     * const Marking_sample = await prisma.marking_sample.create({
     *   data: {
     *     // ... data to create a Marking_sample
     *   }
     * })
     * 
     */
    create<T extends marking_sampleCreateArgs>(args: SelectSubset<T, marking_sampleCreateArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Marking_samples.
     * @param {marking_sampleCreateManyArgs} args - Arguments to create many Marking_samples.
     * @example
     * // Create many Marking_samples
     * const marking_sample = await prisma.marking_sample.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends marking_sampleCreateManyArgs>(args?: SelectSubset<T, marking_sampleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Marking_samples and returns the data saved in the database.
     * @param {marking_sampleCreateManyAndReturnArgs} args - Arguments to create many Marking_samples.
     * @example
     * // Create many Marking_samples
     * const marking_sample = await prisma.marking_sample.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Marking_samples and only return the `id`
     * const marking_sampleWithIdOnly = await prisma.marking_sample.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends marking_sampleCreateManyAndReturnArgs>(args?: SelectSubset<T, marking_sampleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Marking_sample.
     * @param {marking_sampleDeleteArgs} args - Arguments to delete one Marking_sample.
     * @example
     * // Delete one Marking_sample
     * const Marking_sample = await prisma.marking_sample.delete({
     *   where: {
     *     // ... filter to delete one Marking_sample
     *   }
     * })
     * 
     */
    delete<T extends marking_sampleDeleteArgs>(args: SelectSubset<T, marking_sampleDeleteArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Marking_sample.
     * @param {marking_sampleUpdateArgs} args - Arguments to update one Marking_sample.
     * @example
     * // Update one Marking_sample
     * const marking_sample = await prisma.marking_sample.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends marking_sampleUpdateArgs>(args: SelectSubset<T, marking_sampleUpdateArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Marking_samples.
     * @param {marking_sampleDeleteManyArgs} args - Arguments to filter Marking_samples to delete.
     * @example
     * // Delete a few Marking_samples
     * const { count } = await prisma.marking_sample.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends marking_sampleDeleteManyArgs>(args?: SelectSubset<T, marking_sampleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marking_samples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marking_sampleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Marking_samples
     * const marking_sample = await prisma.marking_sample.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends marking_sampleUpdateManyArgs>(args: SelectSubset<T, marking_sampleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Marking_samples and returns the data updated in the database.
     * @param {marking_sampleUpdateManyAndReturnArgs} args - Arguments to update many Marking_samples.
     * @example
     * // Update many Marking_samples
     * const marking_sample = await prisma.marking_sample.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Marking_samples and only return the `id`
     * const marking_sampleWithIdOnly = await prisma.marking_sample.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends marking_sampleUpdateManyAndReturnArgs>(args: SelectSubset<T, marking_sampleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Marking_sample.
     * @param {marking_sampleUpsertArgs} args - Arguments to update or create a Marking_sample.
     * @example
     * // Update or create a Marking_sample
     * const marking_sample = await prisma.marking_sample.upsert({
     *   create: {
     *     // ... data to create a Marking_sample
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Marking_sample we want to update
     *   }
     * })
     */
    upsert<T extends marking_sampleUpsertArgs>(args: SelectSubset<T, marking_sampleUpsertArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Marking_samples.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marking_sampleCountArgs} args - Arguments to filter Marking_samples to count.
     * @example
     * // Count the number of Marking_samples
     * const count = await prisma.marking_sample.count({
     *   where: {
     *     // ... the filter for the Marking_samples we want to count
     *   }
     * })
    **/
    count<T extends marking_sampleCountArgs>(
      args?: Subset<T, marking_sampleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Marking_sampleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Marking_sample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Marking_sampleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Marking_sampleAggregateArgs>(args: Subset<T, Marking_sampleAggregateArgs>): Prisma.PrismaPromise<GetMarking_sampleAggregateType<T>>

    /**
     * Group by Marking_sample.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {marking_sampleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends marking_sampleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: marking_sampleGroupByArgs['orderBy'] }
        : { orderBy?: marking_sampleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, marking_sampleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarking_sampleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the marking_sample model
   */
  readonly fields: marking_sampleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for marking_sample.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__marking_sampleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    record_regulations<T extends marking_sample$record_regulationsArgs<ExtArgs> = {}>(args?: Subset<T, marking_sample$record_regulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regulations<T extends marking_sample$regulationsArgs<ExtArgs> = {}>(args?: Subset<T, marking_sample$regulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the marking_sample model
   */
  interface marking_sampleFieldRefs {
    readonly id: FieldRef<"marking_sample", 'Int'>
    readonly value: FieldRef<"marking_sample", 'String'>
    readonly createdAt: FieldRef<"marking_sample", 'DateTime'>
    readonly updatedAt: FieldRef<"marking_sample", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * marking_sample findUnique
   */
  export type marking_sampleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * Filter, which marking_sample to fetch.
     */
    where: marking_sampleWhereUniqueInput
  }

  /**
   * marking_sample findUniqueOrThrow
   */
  export type marking_sampleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * Filter, which marking_sample to fetch.
     */
    where: marking_sampleWhereUniqueInput
  }

  /**
   * marking_sample findFirst
   */
  export type marking_sampleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * Filter, which marking_sample to fetch.
     */
    where?: marking_sampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marking_samples to fetch.
     */
    orderBy?: marking_sampleOrderByWithRelationInput | marking_sampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marking_samples.
     */
    cursor?: marking_sampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marking_samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marking_samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marking_samples.
     */
    distinct?: Marking_sampleScalarFieldEnum | Marking_sampleScalarFieldEnum[]
  }

  /**
   * marking_sample findFirstOrThrow
   */
  export type marking_sampleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * Filter, which marking_sample to fetch.
     */
    where?: marking_sampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marking_samples to fetch.
     */
    orderBy?: marking_sampleOrderByWithRelationInput | marking_sampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for marking_samples.
     */
    cursor?: marking_sampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marking_samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marking_samples.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of marking_samples.
     */
    distinct?: Marking_sampleScalarFieldEnum | Marking_sampleScalarFieldEnum[]
  }

  /**
   * marking_sample findMany
   */
  export type marking_sampleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * Filter, which marking_samples to fetch.
     */
    where?: marking_sampleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of marking_samples to fetch.
     */
    orderBy?: marking_sampleOrderByWithRelationInput | marking_sampleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing marking_samples.
     */
    cursor?: marking_sampleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` marking_samples from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` marking_samples.
     */
    skip?: number
    distinct?: Marking_sampleScalarFieldEnum | Marking_sampleScalarFieldEnum[]
  }

  /**
   * marking_sample create
   */
  export type marking_sampleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * The data needed to create a marking_sample.
     */
    data: XOR<marking_sampleCreateInput, marking_sampleUncheckedCreateInput>
  }

  /**
   * marking_sample createMany
   */
  export type marking_sampleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many marking_samples.
     */
    data: marking_sampleCreateManyInput | marking_sampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marking_sample createManyAndReturn
   */
  export type marking_sampleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * The data used to create many marking_samples.
     */
    data: marking_sampleCreateManyInput | marking_sampleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * marking_sample update
   */
  export type marking_sampleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * The data needed to update a marking_sample.
     */
    data: XOR<marking_sampleUpdateInput, marking_sampleUncheckedUpdateInput>
    /**
     * Choose, which marking_sample to update.
     */
    where: marking_sampleWhereUniqueInput
  }

  /**
   * marking_sample updateMany
   */
  export type marking_sampleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update marking_samples.
     */
    data: XOR<marking_sampleUpdateManyMutationInput, marking_sampleUncheckedUpdateManyInput>
    /**
     * Filter which marking_samples to update
     */
    where?: marking_sampleWhereInput
    /**
     * Limit how many marking_samples to update.
     */
    limit?: number
  }

  /**
   * marking_sample updateManyAndReturn
   */
  export type marking_sampleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * The data used to update marking_samples.
     */
    data: XOR<marking_sampleUpdateManyMutationInput, marking_sampleUncheckedUpdateManyInput>
    /**
     * Filter which marking_samples to update
     */
    where?: marking_sampleWhereInput
    /**
     * Limit how many marking_samples to update.
     */
    limit?: number
  }

  /**
   * marking_sample upsert
   */
  export type marking_sampleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * The filter to search for the marking_sample to update in case it exists.
     */
    where: marking_sampleWhereUniqueInput
    /**
     * In case the marking_sample found by the `where` argument doesn't exist, create a new marking_sample with this data.
     */
    create: XOR<marking_sampleCreateInput, marking_sampleUncheckedCreateInput>
    /**
     * In case the marking_sample was found with the provided `where` argument, update it with this data.
     */
    update: XOR<marking_sampleUpdateInput, marking_sampleUncheckedUpdateInput>
  }

  /**
   * marking_sample delete
   */
  export type marking_sampleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    /**
     * Filter which marking_sample to delete.
     */
    where: marking_sampleWhereUniqueInput
  }

  /**
   * marking_sample deleteMany
   */
  export type marking_sampleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which marking_samples to delete
     */
    where?: marking_sampleWhereInput
    /**
     * Limit how many marking_samples to delete.
     */
    limit?: number
  }

  /**
   * marking_sample.record_regulations
   */
  export type marking_sample$record_regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    where?: record_regulationsWhereInput
    orderBy?: record_regulationsOrderByWithRelationInput | record_regulationsOrderByWithRelationInput[]
    cursor?: record_regulationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Record_regulationsScalarFieldEnum | Record_regulationsScalarFieldEnum[]
  }

  /**
   * marking_sample.regulations
   */
  export type marking_sample$regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    where?: regulationsWhereInput
    orderBy?: regulationsOrderByWithRelationInput | regulationsOrderByWithRelationInput[]
    cursor?: regulationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegulationsScalarFieldEnum | RegulationsScalarFieldEnum[]
  }

  /**
   * marking_sample without action
   */
  export type marking_sampleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
  }


  /**
   * Model notes
   */

  export type AggregateNotes = {
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  export type NotesAvgAggregateOutputType = {
    id: number | null
  }

  export type NotesSumAggregateOutputType = {
    id: number | null
  }

  export type NotesMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type NotesMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type NotesCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type NotesAvgAggregateInputType = {
    id?: true
  }

  export type NotesSumAggregateInputType = {
    id?: true
  }

  export type NotesMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type NotesMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type NotesCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type NotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to aggregate.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notes
    **/
    _count?: true | NotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotesMaxAggregateInputType
  }

  export type GetNotesAggregateType<T extends NotesAggregateArgs> = {
        [P in keyof T & keyof AggregateNotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotes[P]>
      : GetScalarType<T[P], AggregateNotes[P]>
  }




  export type notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: notesWhereInput
    orderBy?: notesOrderByWithAggregationInput | notesOrderByWithAggregationInput[]
    by: NotesScalarFieldEnum[] | NotesScalarFieldEnum
    having?: notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotesCountAggregateInputType | true
    _avg?: NotesAvgAggregateInputType
    _sum?: NotesSumAggregateInputType
    _min?: NotesMinAggregateInputType
    _max?: NotesMaxAggregateInputType
  }

  export type NotesGroupByOutputType = {
    id: number
    value: string | null
    _count: NotesCountAggregateOutputType | null
    _avg: NotesAvgAggregateOutputType | null
    _sum: NotesSumAggregateOutputType | null
    _min: NotesMinAggregateOutputType | null
    _max: NotesMaxAggregateOutputType | null
  }

  type GetNotesGroupByPayload<T extends notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotesGroupByOutputType[P]>
            : GetScalarType<T[P], NotesGroupByOutputType[P]>
        }
      >
    >


  export type notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["notes"]>

  export type notesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["notes"]>

  export type notesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["notes"]>

  export type notesSelectScalar = {
    id?: boolean
    value?: boolean
  }

  export type notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value", ExtArgs["result"]["notes"]>

  export type $notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "notes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string | null
    }, ExtArgs["result"]["notes"]>
    composites: {}
  }

  type notesGetPayload<S extends boolean | null | undefined | notesDefaultArgs> = $Result.GetResult<Prisma.$notesPayload, S>

  type notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotesCountAggregateInputType | true
    }

  export interface notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['notes'], meta: { name: 'notes' } }
    /**
     * Find zero or one Notes that matches the filter.
     * @param {notesFindUniqueArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends notesFindUniqueArgs>(args: SelectSubset<T, notesFindUniqueArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {notesFindUniqueOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends notesFindUniqueOrThrowArgs>(args: SelectSubset<T, notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends notesFindFirstArgs>(args?: SelectSubset<T, notesFindFirstArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindFirstOrThrowArgs} args - Arguments to find a Notes
     * @example
     * // Get one Notes
     * const notes = await prisma.notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends notesFindFirstOrThrowArgs>(args?: SelectSubset<T, notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.notes.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notesWithIdOnly = await prisma.notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends notesFindManyArgs>(args?: SelectSubset<T, notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notes.
     * @param {notesCreateArgs} args - Arguments to create a Notes.
     * @example
     * // Create one Notes
     * const Notes = await prisma.notes.create({
     *   data: {
     *     // ... data to create a Notes
     *   }
     * })
     * 
     */
    create<T extends notesCreateArgs>(args: SelectSubset<T, notesCreateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {notesCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends notesCreateManyArgs>(args?: SelectSubset<T, notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notes and returns the data saved in the database.
     * @param {notesCreateManyAndReturnArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const notes = await prisma.notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends notesCreateManyAndReturnArgs>(args?: SelectSubset<T, notesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notes.
     * @param {notesDeleteArgs} args - Arguments to delete one Notes.
     * @example
     * // Delete one Notes
     * const Notes = await prisma.notes.delete({
     *   where: {
     *     // ... filter to delete one Notes
     *   }
     * })
     * 
     */
    delete<T extends notesDeleteArgs>(args: SelectSubset<T, notesDeleteArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notes.
     * @param {notesUpdateArgs} args - Arguments to update one Notes.
     * @example
     * // Update one Notes
     * const notes = await prisma.notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends notesUpdateArgs>(args: SelectSubset<T, notesUpdateArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {notesDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends notesDeleteManyArgs>(args?: SelectSubset<T, notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends notesUpdateManyArgs>(args: SelectSubset<T, notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes and returns the data updated in the database.
     * @param {notesUpdateManyAndReturnArgs} args - Arguments to update many Notes.
     * @example
     * // Update many Notes
     * const notes = await prisma.notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notes and only return the `id`
     * const notesWithIdOnly = await prisma.notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends notesUpdateManyAndReturnArgs>(args: SelectSubset<T, notesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notes.
     * @param {notesUpsertArgs} args - Arguments to update or create a Notes.
     * @example
     * // Update or create a Notes
     * const notes = await prisma.notes.upsert({
     *   create: {
     *     // ... data to create a Notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notes we want to update
     *   }
     * })
     */
    upsert<T extends notesUpsertArgs>(args: SelectSubset<T, notesUpsertArgs<ExtArgs>>): Prisma__notesClient<$Result.GetResult<Prisma.$notesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.notes.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends notesCountArgs>(
      args?: Subset<T, notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotesAggregateArgs>(args: Subset<T, NotesAggregateArgs>): Prisma.PrismaPromise<GetNotesAggregateType<T>>

    /**
     * Group by Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: notesGroupByArgs['orderBy'] }
        : { orderBy?: notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the notes model
   */
  readonly fields: notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the notes model
   */
  interface notesFieldRefs {
    readonly id: FieldRef<"notes", 'Int'>
    readonly value: FieldRef<"notes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * notes findUnique
   */
  export type notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findUniqueOrThrow
   */
  export type notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes findFirst
   */
  export type notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findFirstOrThrow
   */
  export type notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes findMany
   */
  export type notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: notesOrderByWithRelationInput | notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notes.
     */
    cursor?: notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    distinct?: NotesScalarFieldEnum | NotesScalarFieldEnum[]
  }

  /**
   * notes create
   */
  export type notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data needed to create a notes.
     */
    data?: XOR<notesCreateInput, notesUncheckedCreateInput>
  }

  /**
   * notes createMany
   */
  export type notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notes createManyAndReturn
   */
  export type notesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to create many notes.
     */
    data: notesCreateManyInput | notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * notes update
   */
  export type notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data needed to update a notes.
     */
    data: XOR<notesUpdateInput, notesUncheckedUpdateInput>
    /**
     * Choose, which notes to update.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes updateMany
   */
  export type notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
  }

  /**
   * notes updateManyAndReturn
   */
  export type notesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The data used to update notes.
     */
    data: XOR<notesUpdateManyMutationInput, notesUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
  }

  /**
   * notes upsert
   */
  export type notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * The filter to search for the notes to update in case it exists.
     */
    where: notesWhereUniqueInput
    /**
     * In case the notes found by the `where` argument doesn't exist, create a new notes with this data.
     */
    create: XOR<notesCreateInput, notesUncheckedCreateInput>
    /**
     * In case the notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notesUpdateInput, notesUncheckedUpdateInput>
  }

  /**
   * notes delete
   */
  export type notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
    /**
     * Filter which notes to delete.
     */
    where: notesWhereUniqueInput
  }

  /**
   * notes deleteMany
   */
  export type notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to delete
     */
    where?: notesWhereInput
    /**
     * Limit how many notes to delete.
     */
    limit?: number
  }

  /**
   * notes without action
   */
  export type notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the notes
     */
    select?: notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the notes
     */
    omit?: notesOmit<ExtArgs> | null
  }


  /**
   * Model occupations
   */

  export type AggregateOccupations = {
    _count: OccupationsCountAggregateOutputType | null
    _avg: OccupationsAvgAggregateOutputType | null
    _sum: OccupationsSumAggregateOutputType | null
    _min: OccupationsMinAggregateOutputType | null
    _max: OccupationsMaxAggregateOutputType | null
  }

  export type OccupationsAvgAggregateOutputType = {
    id: number | null
  }

  export type OccupationsSumAggregateOutputType = {
    id: number | null
  }

  export type OccupationsMinAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type OccupationsMaxAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type OccupationsCountAggregateOutputType = {
    id: number
    value: number
    description: number
    _all: number
  }


  export type OccupationsAvgAggregateInputType = {
    id?: true
  }

  export type OccupationsSumAggregateInputType = {
    id?: true
  }

  export type OccupationsMinAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type OccupationsMaxAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type OccupationsCountAggregateInputType = {
    id?: true
    value?: true
    description?: true
    _all?: true
  }

  export type OccupationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which occupations to aggregate.
     */
    where?: occupationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of occupations to fetch.
     */
    orderBy?: occupationsOrderByWithRelationInput | occupationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: occupationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned occupations
    **/
    _count?: true | OccupationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OccupationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OccupationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OccupationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OccupationsMaxAggregateInputType
  }

  export type GetOccupationsAggregateType<T extends OccupationsAggregateArgs> = {
        [P in keyof T & keyof AggregateOccupations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOccupations[P]>
      : GetScalarType<T[P], AggregateOccupations[P]>
  }




  export type occupationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: occupationsWhereInput
    orderBy?: occupationsOrderByWithAggregationInput | occupationsOrderByWithAggregationInput[]
    by: OccupationsScalarFieldEnum[] | OccupationsScalarFieldEnum
    having?: occupationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OccupationsCountAggregateInputType | true
    _avg?: OccupationsAvgAggregateInputType
    _sum?: OccupationsSumAggregateInputType
    _min?: OccupationsMinAggregateInputType
    _max?: OccupationsMaxAggregateInputType
  }

  export type OccupationsGroupByOutputType = {
    id: number
    value: string
    description: string
    _count: OccupationsCountAggregateOutputType | null
    _avg: OccupationsAvgAggregateOutputType | null
    _sum: OccupationsSumAggregateOutputType | null
    _min: OccupationsMinAggregateOutputType | null
    _max: OccupationsMaxAggregateOutputType | null
  }

  type GetOccupationsGroupByPayload<T extends occupationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OccupationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OccupationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OccupationsGroupByOutputType[P]>
            : GetScalarType<T[P], OccupationsGroupByOutputType[P]>
        }
      >
    >


  export type occupationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
    employees?: boolean | occupations$employeesArgs<ExtArgs>
    _count?: boolean | OccupationsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["occupations"]>

  export type occupationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["occupations"]>

  export type occupationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["occupations"]>

  export type occupationsSelectScalar = {
    id?: boolean
    value?: boolean
    description?: boolean
  }

  export type occupationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "description", ExtArgs["result"]["occupations"]>
  export type occupationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | occupations$employeesArgs<ExtArgs>
    _count?: boolean | OccupationsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type occupationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type occupationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $occupationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "occupations"
    objects: {
      employees: Prisma.$employeesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      description: string
    }, ExtArgs["result"]["occupations"]>
    composites: {}
  }

  type occupationsGetPayload<S extends boolean | null | undefined | occupationsDefaultArgs> = $Result.GetResult<Prisma.$occupationsPayload, S>

  type occupationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<occupationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OccupationsCountAggregateInputType | true
    }

  export interface occupationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['occupations'], meta: { name: 'occupations' } }
    /**
     * Find zero or one Occupations that matches the filter.
     * @param {occupationsFindUniqueArgs} args - Arguments to find a Occupations
     * @example
     * // Get one Occupations
     * const occupations = await prisma.occupations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends occupationsFindUniqueArgs>(args: SelectSubset<T, occupationsFindUniqueArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Occupations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {occupationsFindUniqueOrThrowArgs} args - Arguments to find a Occupations
     * @example
     * // Get one Occupations
     * const occupations = await prisma.occupations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends occupationsFindUniqueOrThrowArgs>(args: SelectSubset<T, occupationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Occupations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {occupationsFindFirstArgs} args - Arguments to find a Occupations
     * @example
     * // Get one Occupations
     * const occupations = await prisma.occupations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends occupationsFindFirstArgs>(args?: SelectSubset<T, occupationsFindFirstArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Occupations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {occupationsFindFirstOrThrowArgs} args - Arguments to find a Occupations
     * @example
     * // Get one Occupations
     * const occupations = await prisma.occupations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends occupationsFindFirstOrThrowArgs>(args?: SelectSubset<T, occupationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Occupations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {occupationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Occupations
     * const occupations = await prisma.occupations.findMany()
     * 
     * // Get first 10 Occupations
     * const occupations = await prisma.occupations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const occupationsWithIdOnly = await prisma.occupations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends occupationsFindManyArgs>(args?: SelectSubset<T, occupationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Occupations.
     * @param {occupationsCreateArgs} args - Arguments to create a Occupations.
     * @example
     * // Create one Occupations
     * const Occupations = await prisma.occupations.create({
     *   data: {
     *     // ... data to create a Occupations
     *   }
     * })
     * 
     */
    create<T extends occupationsCreateArgs>(args: SelectSubset<T, occupationsCreateArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Occupations.
     * @param {occupationsCreateManyArgs} args - Arguments to create many Occupations.
     * @example
     * // Create many Occupations
     * const occupations = await prisma.occupations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends occupationsCreateManyArgs>(args?: SelectSubset<T, occupationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Occupations and returns the data saved in the database.
     * @param {occupationsCreateManyAndReturnArgs} args - Arguments to create many Occupations.
     * @example
     * // Create many Occupations
     * const occupations = await prisma.occupations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Occupations and only return the `id`
     * const occupationsWithIdOnly = await prisma.occupations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends occupationsCreateManyAndReturnArgs>(args?: SelectSubset<T, occupationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Occupations.
     * @param {occupationsDeleteArgs} args - Arguments to delete one Occupations.
     * @example
     * // Delete one Occupations
     * const Occupations = await prisma.occupations.delete({
     *   where: {
     *     // ... filter to delete one Occupations
     *   }
     * })
     * 
     */
    delete<T extends occupationsDeleteArgs>(args: SelectSubset<T, occupationsDeleteArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Occupations.
     * @param {occupationsUpdateArgs} args - Arguments to update one Occupations.
     * @example
     * // Update one Occupations
     * const occupations = await prisma.occupations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends occupationsUpdateArgs>(args: SelectSubset<T, occupationsUpdateArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Occupations.
     * @param {occupationsDeleteManyArgs} args - Arguments to filter Occupations to delete.
     * @example
     * // Delete a few Occupations
     * const { count } = await prisma.occupations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends occupationsDeleteManyArgs>(args?: SelectSubset<T, occupationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {occupationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Occupations
     * const occupations = await prisma.occupations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends occupationsUpdateManyArgs>(args: SelectSubset<T, occupationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Occupations and returns the data updated in the database.
     * @param {occupationsUpdateManyAndReturnArgs} args - Arguments to update many Occupations.
     * @example
     * // Update many Occupations
     * const occupations = await prisma.occupations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Occupations and only return the `id`
     * const occupationsWithIdOnly = await prisma.occupations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends occupationsUpdateManyAndReturnArgs>(args: SelectSubset<T, occupationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Occupations.
     * @param {occupationsUpsertArgs} args - Arguments to update or create a Occupations.
     * @example
     * // Update or create a Occupations
     * const occupations = await prisma.occupations.upsert({
     *   create: {
     *     // ... data to create a Occupations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Occupations we want to update
     *   }
     * })
     */
    upsert<T extends occupationsUpsertArgs>(args: SelectSubset<T, occupationsUpsertArgs<ExtArgs>>): Prisma__occupationsClient<$Result.GetResult<Prisma.$occupationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {occupationsCountArgs} args - Arguments to filter Occupations to count.
     * @example
     * // Count the number of Occupations
     * const count = await prisma.occupations.count({
     *   where: {
     *     // ... the filter for the Occupations we want to count
     *   }
     * })
    **/
    count<T extends occupationsCountArgs>(
      args?: Subset<T, occupationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OccupationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccupationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OccupationsAggregateArgs>(args: Subset<T, OccupationsAggregateArgs>): Prisma.PrismaPromise<GetOccupationsAggregateType<T>>

    /**
     * Group by Occupations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {occupationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends occupationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: occupationsGroupByArgs['orderBy'] }
        : { orderBy?: occupationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, occupationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOccupationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the occupations model
   */
  readonly fields: occupationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for occupations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__occupationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends occupations$employeesArgs<ExtArgs> = {}>(args?: Subset<T, occupations$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the occupations model
   */
  interface occupationsFieldRefs {
    readonly id: FieldRef<"occupations", 'Int'>
    readonly value: FieldRef<"occupations", 'String'>
    readonly description: FieldRef<"occupations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * occupations findUnique
   */
  export type occupationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * Filter, which occupations to fetch.
     */
    where: occupationsWhereUniqueInput
  }

  /**
   * occupations findUniqueOrThrow
   */
  export type occupationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * Filter, which occupations to fetch.
     */
    where: occupationsWhereUniqueInput
  }

  /**
   * occupations findFirst
   */
  export type occupationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * Filter, which occupations to fetch.
     */
    where?: occupationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of occupations to fetch.
     */
    orderBy?: occupationsOrderByWithRelationInput | occupationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for occupations.
     */
    cursor?: occupationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of occupations.
     */
    distinct?: OccupationsScalarFieldEnum | OccupationsScalarFieldEnum[]
  }

  /**
   * occupations findFirstOrThrow
   */
  export type occupationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * Filter, which occupations to fetch.
     */
    where?: occupationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of occupations to fetch.
     */
    orderBy?: occupationsOrderByWithRelationInput | occupationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for occupations.
     */
    cursor?: occupationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` occupations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of occupations.
     */
    distinct?: OccupationsScalarFieldEnum | OccupationsScalarFieldEnum[]
  }

  /**
   * occupations findMany
   */
  export type occupationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * Filter, which occupations to fetch.
     */
    where?: occupationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of occupations to fetch.
     */
    orderBy?: occupationsOrderByWithRelationInput | occupationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing occupations.
     */
    cursor?: occupationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` occupations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` occupations.
     */
    skip?: number
    distinct?: OccupationsScalarFieldEnum | OccupationsScalarFieldEnum[]
  }

  /**
   * occupations create
   */
  export type occupationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * The data needed to create a occupations.
     */
    data: XOR<occupationsCreateInput, occupationsUncheckedCreateInput>
  }

  /**
   * occupations createMany
   */
  export type occupationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many occupations.
     */
    data: occupationsCreateManyInput | occupationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * occupations createManyAndReturn
   */
  export type occupationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * The data used to create many occupations.
     */
    data: occupationsCreateManyInput | occupationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * occupations update
   */
  export type occupationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * The data needed to update a occupations.
     */
    data: XOR<occupationsUpdateInput, occupationsUncheckedUpdateInput>
    /**
     * Choose, which occupations to update.
     */
    where: occupationsWhereUniqueInput
  }

  /**
   * occupations updateMany
   */
  export type occupationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update occupations.
     */
    data: XOR<occupationsUpdateManyMutationInput, occupationsUncheckedUpdateManyInput>
    /**
     * Filter which occupations to update
     */
    where?: occupationsWhereInput
    /**
     * Limit how many occupations to update.
     */
    limit?: number
  }

  /**
   * occupations updateManyAndReturn
   */
  export type occupationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * The data used to update occupations.
     */
    data: XOR<occupationsUpdateManyMutationInput, occupationsUncheckedUpdateManyInput>
    /**
     * Filter which occupations to update
     */
    where?: occupationsWhereInput
    /**
     * Limit how many occupations to update.
     */
    limit?: number
  }

  /**
   * occupations upsert
   */
  export type occupationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * The filter to search for the occupations to update in case it exists.
     */
    where: occupationsWhereUniqueInput
    /**
     * In case the occupations found by the `where` argument doesn't exist, create a new occupations with this data.
     */
    create: XOR<occupationsCreateInput, occupationsUncheckedCreateInput>
    /**
     * In case the occupations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<occupationsUpdateInput, occupationsUncheckedUpdateInput>
  }

  /**
   * occupations delete
   */
  export type occupationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
    /**
     * Filter which occupations to delete.
     */
    where: occupationsWhereUniqueInput
  }

  /**
   * occupations deleteMany
   */
  export type occupationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which occupations to delete
     */
    where?: occupationsWhereInput
    /**
     * Limit how many occupations to delete.
     */
    limit?: number
  }

  /**
   * occupations.employees
   */
  export type occupations$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    where?: employeesWhereInput
    orderBy?: employeesOrderByWithRelationInput | employeesOrderByWithRelationInput[]
    cursor?: employeesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeesScalarFieldEnum | EmployeesScalarFieldEnum[]
  }

  /**
   * occupations without action
   */
  export type occupationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the occupations
     */
    select?: occupationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the occupations
     */
    omit?: occupationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: occupationsInclude<ExtArgs> | null
  }


  /**
   * Model plants
   */

  export type AggregatePlants = {
    _count: PlantsCountAggregateOutputType | null
    _avg: PlantsAvgAggregateOutputType | null
    _sum: PlantsSumAggregateOutputType | null
    _min: PlantsMinAggregateOutputType | null
    _max: PlantsMaxAggregateOutputType | null
  }

  export type PlantsAvgAggregateOutputType = {
    id: number | null
  }

  export type PlantsSumAggregateOutputType = {
    id: number | null
  }

  export type PlantsMinAggregateOutputType = {
    id: number | null
    value: string | null
    abb: string | null
  }

  export type PlantsMaxAggregateOutputType = {
    id: number | null
    value: string | null
    abb: string | null
  }

  export type PlantsCountAggregateOutputType = {
    id: number
    value: number
    abb: number
    _all: number
  }


  export type PlantsAvgAggregateInputType = {
    id?: true
  }

  export type PlantsSumAggregateInputType = {
    id?: true
  }

  export type PlantsMinAggregateInputType = {
    id?: true
    value?: true
    abb?: true
  }

  export type PlantsMaxAggregateInputType = {
    id?: true
    value?: true
    abb?: true
  }

  export type PlantsCountAggregateInputType = {
    id?: true
    value?: true
    abb?: true
    _all?: true
  }

  export type PlantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plants to aggregate.
     */
    where?: plantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plants to fetch.
     */
    orderBy?: plantsOrderByWithRelationInput | plantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: plantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned plants
    **/
    _count?: true | PlantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlantsMaxAggregateInputType
  }

  export type GetPlantsAggregateType<T extends PlantsAggregateArgs> = {
        [P in keyof T & keyof AggregatePlants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlants[P]>
      : GetScalarType<T[P], AggregatePlants[P]>
  }




  export type plantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: plantsWhereInput
    orderBy?: plantsOrderByWithAggregationInput | plantsOrderByWithAggregationInput[]
    by: PlantsScalarFieldEnum[] | PlantsScalarFieldEnum
    having?: plantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlantsCountAggregateInputType | true
    _avg?: PlantsAvgAggregateInputType
    _sum?: PlantsSumAggregateInputType
    _min?: PlantsMinAggregateInputType
    _max?: PlantsMaxAggregateInputType
  }

  export type PlantsGroupByOutputType = {
    id: number
    value: string
    abb: string | null
    _count: PlantsCountAggregateOutputType | null
    _avg: PlantsAvgAggregateOutputType | null
    _sum: PlantsSumAggregateOutputType | null
    _min: PlantsMinAggregateOutputType | null
    _max: PlantsMaxAggregateOutputType | null
  }

  type GetPlantsGroupByPayload<T extends plantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlantsGroupByOutputType[P]>
            : GetScalarType<T[P], PlantsGroupByOutputType[P]>
        }
      >
    >


  export type plantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    abb?: boolean
    docs?: boolean | plants$docsArgs<ExtArgs>
    _count?: boolean | PlantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plants"]>

  export type plantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    abb?: boolean
  }, ExtArgs["result"]["plants"]>

  export type plantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    abb?: boolean
  }, ExtArgs["result"]["plants"]>

  export type plantsSelectScalar = {
    id?: boolean
    value?: boolean
    abb?: boolean
  }

  export type plantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "abb", ExtArgs["result"]["plants"]>
  export type plantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    docs?: boolean | plants$docsArgs<ExtArgs>
    _count?: boolean | PlantsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type plantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type plantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $plantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "plants"
    objects: {
      docs: Prisma.$docsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      abb: string | null
    }, ExtArgs["result"]["plants"]>
    composites: {}
  }

  type plantsGetPayload<S extends boolean | null | undefined | plantsDefaultArgs> = $Result.GetResult<Prisma.$plantsPayload, S>

  type plantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<plantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlantsCountAggregateInputType | true
    }

  export interface plantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['plants'], meta: { name: 'plants' } }
    /**
     * Find zero or one Plants that matches the filter.
     * @param {plantsFindUniqueArgs} args - Arguments to find a Plants
     * @example
     * // Get one Plants
     * const plants = await prisma.plants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends plantsFindUniqueArgs>(args: SelectSubset<T, plantsFindUniqueArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {plantsFindUniqueOrThrowArgs} args - Arguments to find a Plants
     * @example
     * // Get one Plants
     * const plants = await prisma.plants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends plantsFindUniqueOrThrowArgs>(args: SelectSubset<T, plantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantsFindFirstArgs} args - Arguments to find a Plants
     * @example
     * // Get one Plants
     * const plants = await prisma.plants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends plantsFindFirstArgs>(args?: SelectSubset<T, plantsFindFirstArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantsFindFirstOrThrowArgs} args - Arguments to find a Plants
     * @example
     * // Get one Plants
     * const plants = await prisma.plants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends plantsFindFirstOrThrowArgs>(args?: SelectSubset<T, plantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plants
     * const plants = await prisma.plants.findMany()
     * 
     * // Get first 10 Plants
     * const plants = await prisma.plants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const plantsWithIdOnly = await prisma.plants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends plantsFindManyArgs>(args?: SelectSubset<T, plantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plants.
     * @param {plantsCreateArgs} args - Arguments to create a Plants.
     * @example
     * // Create one Plants
     * const Plants = await prisma.plants.create({
     *   data: {
     *     // ... data to create a Plants
     *   }
     * })
     * 
     */
    create<T extends plantsCreateArgs>(args: SelectSubset<T, plantsCreateArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plants.
     * @param {plantsCreateManyArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plants = await prisma.plants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends plantsCreateManyArgs>(args?: SelectSubset<T, plantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plants and returns the data saved in the database.
     * @param {plantsCreateManyAndReturnArgs} args - Arguments to create many Plants.
     * @example
     * // Create many Plants
     * const plants = await prisma.plants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plants and only return the `id`
     * const plantsWithIdOnly = await prisma.plants.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends plantsCreateManyAndReturnArgs>(args?: SelectSubset<T, plantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plants.
     * @param {plantsDeleteArgs} args - Arguments to delete one Plants.
     * @example
     * // Delete one Plants
     * const Plants = await prisma.plants.delete({
     *   where: {
     *     // ... filter to delete one Plants
     *   }
     * })
     * 
     */
    delete<T extends plantsDeleteArgs>(args: SelectSubset<T, plantsDeleteArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plants.
     * @param {plantsUpdateArgs} args - Arguments to update one Plants.
     * @example
     * // Update one Plants
     * const plants = await prisma.plants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends plantsUpdateArgs>(args: SelectSubset<T, plantsUpdateArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plants.
     * @param {plantsDeleteManyArgs} args - Arguments to filter Plants to delete.
     * @example
     * // Delete a few Plants
     * const { count } = await prisma.plants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends plantsDeleteManyArgs>(args?: SelectSubset<T, plantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plants
     * const plants = await prisma.plants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends plantsUpdateManyArgs>(args: SelectSubset<T, plantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plants and returns the data updated in the database.
     * @param {plantsUpdateManyAndReturnArgs} args - Arguments to update many Plants.
     * @example
     * // Update many Plants
     * const plants = await prisma.plants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plants and only return the `id`
     * const plantsWithIdOnly = await prisma.plants.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends plantsUpdateManyAndReturnArgs>(args: SelectSubset<T, plantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plants.
     * @param {plantsUpsertArgs} args - Arguments to update or create a Plants.
     * @example
     * // Update or create a Plants
     * const plants = await prisma.plants.upsert({
     *   create: {
     *     // ... data to create a Plants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plants we want to update
     *   }
     * })
     */
    upsert<T extends plantsUpsertArgs>(args: SelectSubset<T, plantsUpsertArgs<ExtArgs>>): Prisma__plantsClient<$Result.GetResult<Prisma.$plantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantsCountArgs} args - Arguments to filter Plants to count.
     * @example
     * // Count the number of Plants
     * const count = await prisma.plants.count({
     *   where: {
     *     // ... the filter for the Plants we want to count
     *   }
     * })
    **/
    count<T extends plantsCountArgs>(
      args?: Subset<T, plantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlantsAggregateArgs>(args: Subset<T, PlantsAggregateArgs>): Prisma.PrismaPromise<GetPlantsAggregateType<T>>

    /**
     * Group by Plants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {plantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends plantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: plantsGroupByArgs['orderBy'] }
        : { orderBy?: plantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, plantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the plants model
   */
  readonly fields: plantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for plants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__plantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    docs<T extends plants$docsArgs<ExtArgs> = {}>(args?: Subset<T, plants$docsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the plants model
   */
  interface plantsFieldRefs {
    readonly id: FieldRef<"plants", 'Int'>
    readonly value: FieldRef<"plants", 'String'>
    readonly abb: FieldRef<"plants", 'String'>
  }
    

  // Custom InputTypes
  /**
   * plants findUnique
   */
  export type plantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * Filter, which plants to fetch.
     */
    where: plantsWhereUniqueInput
  }

  /**
   * plants findUniqueOrThrow
   */
  export type plantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * Filter, which plants to fetch.
     */
    where: plantsWhereUniqueInput
  }

  /**
   * plants findFirst
   */
  export type plantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * Filter, which plants to fetch.
     */
    where?: plantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plants to fetch.
     */
    orderBy?: plantsOrderByWithRelationInput | plantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plants.
     */
    cursor?: plantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plants.
     */
    distinct?: PlantsScalarFieldEnum | PlantsScalarFieldEnum[]
  }

  /**
   * plants findFirstOrThrow
   */
  export type plantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * Filter, which plants to fetch.
     */
    where?: plantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plants to fetch.
     */
    orderBy?: plantsOrderByWithRelationInput | plantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for plants.
     */
    cursor?: plantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of plants.
     */
    distinct?: PlantsScalarFieldEnum | PlantsScalarFieldEnum[]
  }

  /**
   * plants findMany
   */
  export type plantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * Filter, which plants to fetch.
     */
    where?: plantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of plants to fetch.
     */
    orderBy?: plantsOrderByWithRelationInput | plantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing plants.
     */
    cursor?: plantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` plants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` plants.
     */
    skip?: number
    distinct?: PlantsScalarFieldEnum | PlantsScalarFieldEnum[]
  }

  /**
   * plants create
   */
  export type plantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * The data needed to create a plants.
     */
    data: XOR<plantsCreateInput, plantsUncheckedCreateInput>
  }

  /**
   * plants createMany
   */
  export type plantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many plants.
     */
    data: plantsCreateManyInput | plantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plants createManyAndReturn
   */
  export type plantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * The data used to create many plants.
     */
    data: plantsCreateManyInput | plantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * plants update
   */
  export type plantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * The data needed to update a plants.
     */
    data: XOR<plantsUpdateInput, plantsUncheckedUpdateInput>
    /**
     * Choose, which plants to update.
     */
    where: plantsWhereUniqueInput
  }

  /**
   * plants updateMany
   */
  export type plantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update plants.
     */
    data: XOR<plantsUpdateManyMutationInput, plantsUncheckedUpdateManyInput>
    /**
     * Filter which plants to update
     */
    where?: plantsWhereInput
    /**
     * Limit how many plants to update.
     */
    limit?: number
  }

  /**
   * plants updateManyAndReturn
   */
  export type plantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * The data used to update plants.
     */
    data: XOR<plantsUpdateManyMutationInput, plantsUncheckedUpdateManyInput>
    /**
     * Filter which plants to update
     */
    where?: plantsWhereInput
    /**
     * Limit how many plants to update.
     */
    limit?: number
  }

  /**
   * plants upsert
   */
  export type plantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * The filter to search for the plants to update in case it exists.
     */
    where: plantsWhereUniqueInput
    /**
     * In case the plants found by the `where` argument doesn't exist, create a new plants with this data.
     */
    create: XOR<plantsCreateInput, plantsUncheckedCreateInput>
    /**
     * In case the plants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<plantsUpdateInput, plantsUncheckedUpdateInput>
  }

  /**
   * plants delete
   */
  export type plantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
    /**
     * Filter which plants to delete.
     */
    where: plantsWhereUniqueInput
  }

  /**
   * plants deleteMany
   */
  export type plantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which plants to delete
     */
    where?: plantsWhereInput
    /**
     * Limit how many plants to delete.
     */
    limit?: number
  }

  /**
   * plants.docs
   */
  export type plants$docsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    where?: docsWhereInput
    orderBy?: docsOrderByWithRelationInput | docsOrderByWithRelationInput[]
    cursor?: docsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocsScalarFieldEnum | DocsScalarFieldEnum[]
  }

  /**
   * plants without action
   */
  export type plantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the plants
     */
    select?: plantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the plants
     */
    omit?: plantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: plantsInclude<ExtArgs> | null
  }


  /**
   * Model products
   */

  export type AggregateProducts = {
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  export type ProductsAvgAggregateOutputType = {
    id: number | null
    serieId: number | null
  }

  export type ProductsSumAggregateOutputType = {
    id: number | null
    serieId: number | null
  }

  export type ProductsMinAggregateOutputType = {
    id: number | null
    code1C: string | null
    marking: string | null
    name: string | null
    serieId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductsMaxAggregateOutputType = {
    id: number | null
    code1C: string | null
    marking: string | null
    name: string | null
    serieId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductsCountAggregateOutputType = {
    id: number
    code1C: number
    marking: number
    name: number
    serieId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductsAvgAggregateInputType = {
    id?: true
    serieId?: true
  }

  export type ProductsSumAggregateInputType = {
    id?: true
    serieId?: true
  }

  export type ProductsMinAggregateInputType = {
    id?: true
    code1C?: true
    marking?: true
    name?: true
    serieId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductsMaxAggregateInputType = {
    id?: true
    code1C?: true
    marking?: true
    name?: true
    serieId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductsCountAggregateInputType = {
    id?: true
    code1C?: true
    marking?: true
    name?: true
    serieId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to aggregate.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned products
    **/
    _count?: true | ProductsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductsMaxAggregateInputType
  }

  export type GetProductsAggregateType<T extends ProductsAggregateArgs> = {
        [P in keyof T & keyof AggregateProducts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProducts[P]>
      : GetScalarType<T[P], AggregateProducts[P]>
  }




  export type productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: productsWhereInput
    orderBy?: productsOrderByWithAggregationInput | productsOrderByWithAggregationInput[]
    by: ProductsScalarFieldEnum[] | ProductsScalarFieldEnum
    having?: productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductsCountAggregateInputType | true
    _avg?: ProductsAvgAggregateInputType
    _sum?: ProductsSumAggregateInputType
    _min?: ProductsMinAggregateInputType
    _max?: ProductsMaxAggregateInputType
  }

  export type ProductsGroupByOutputType = {
    id: number
    code1C: string
    marking: string
    name: string | null
    serieId: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProductsCountAggregateOutputType | null
    _avg: ProductsAvgAggregateOutputType | null
    _sum: ProductsSumAggregateOutputType | null
    _min: ProductsMinAggregateOutputType | null
    _max: ProductsMaxAggregateOutputType | null
  }

  type GetProductsGroupByPayload<T extends productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductsGroupByOutputType[P]>
            : GetScalarType<T[P], ProductsGroupByOutputType[P]>
        }
      >
    >


  export type productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code1C?: boolean
    marking?: boolean
    name?: boolean
    serieId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | products$seriesArgs<ExtArgs>
    records?: boolean | products$recordsArgs<ExtArgs>
    regulations?: boolean | products$regulationsArgs<ExtArgs>
    semi_products?: boolean | products$semi_productsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code1C?: boolean
    marking?: boolean
    name?: boolean
    serieId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | products$seriesArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code1C?: boolean
    marking?: boolean
    name?: boolean
    serieId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    series?: boolean | products$seriesArgs<ExtArgs>
  }, ExtArgs["result"]["products"]>

  export type productsSelectScalar = {
    id?: boolean
    code1C?: boolean
    marking?: boolean
    name?: boolean
    serieId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code1C" | "marking" | "name" | "serieId" | "createdAt" | "updatedAt", ExtArgs["result"]["products"]>
  export type productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | products$seriesArgs<ExtArgs>
    records?: boolean | products$recordsArgs<ExtArgs>
    regulations?: boolean | products$regulationsArgs<ExtArgs>
    semi_products?: boolean | products$semi_productsArgs<ExtArgs>
    _count?: boolean | ProductsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | products$seriesArgs<ExtArgs>
  }
  export type productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    series?: boolean | products$seriesArgs<ExtArgs>
  }

  export type $productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "products"
    objects: {
      series: Prisma.$seriesPayload<ExtArgs> | null
      records: Prisma.$recordsPayload<ExtArgs>[]
      regulations: Prisma.$regulationsPayload<ExtArgs>[]
      semi_products: Prisma.$semi_productsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code1C: string
      marking: string
      name: string | null
      serieId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["products"]>
    composites: {}
  }

  type productsGetPayload<S extends boolean | null | undefined | productsDefaultArgs> = $Result.GetResult<Prisma.$productsPayload, S>

  type productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductsCountAggregateInputType | true
    }

  export interface productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['products'], meta: { name: 'products' } }
    /**
     * Find zero or one Products that matches the filter.
     * @param {productsFindUniqueArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends productsFindUniqueArgs>(args: SelectSubset<T, productsFindUniqueArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {productsFindUniqueOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends productsFindUniqueOrThrowArgs>(args: SelectSubset<T, productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends productsFindFirstArgs>(args?: SelectSubset<T, productsFindFirstArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindFirstOrThrowArgs} args - Arguments to find a Products
     * @example
     * // Get one Products
     * const products = await prisma.products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends productsFindFirstOrThrowArgs>(args?: SelectSubset<T, productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.products.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends productsFindManyArgs>(args?: SelectSubset<T, productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Products.
     * @param {productsCreateArgs} args - Arguments to create a Products.
     * @example
     * // Create one Products
     * const Products = await prisma.products.create({
     *   data: {
     *     // ... data to create a Products
     *   }
     * })
     * 
     */
    create<T extends productsCreateArgs>(args: SelectSubset<T, productsCreateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {productsCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends productsCreateManyArgs>(args?: SelectSubset<T, productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {productsCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const products = await prisma.products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends productsCreateManyAndReturnArgs>(args?: SelectSubset<T, productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Products.
     * @param {productsDeleteArgs} args - Arguments to delete one Products.
     * @example
     * // Delete one Products
     * const Products = await prisma.products.delete({
     *   where: {
     *     // ... filter to delete one Products
     *   }
     * })
     * 
     */
    delete<T extends productsDeleteArgs>(args: SelectSubset<T, productsDeleteArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Products.
     * @param {productsUpdateArgs} args - Arguments to update one Products.
     * @example
     * // Update one Products
     * const products = await prisma.products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends productsUpdateArgs>(args: SelectSubset<T, productsUpdateArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends productsDeleteManyArgs>(args?: SelectSubset<T, productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends productsUpdateManyArgs>(args: SelectSubset<T, productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {productsUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const products = await prisma.products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productsWithIdOnly = await prisma.products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends productsUpdateManyAndReturnArgs>(args: SelectSubset<T, productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Products.
     * @param {productsUpsertArgs} args - Arguments to update or create a Products.
     * @example
     * // Update or create a Products
     * const products = await prisma.products.upsert({
     *   create: {
     *     // ... data to create a Products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Products we want to update
     *   }
     * })
     */
    upsert<T extends productsUpsertArgs>(args: SelectSubset<T, productsUpsertArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.products.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends productsCountArgs>(
      args?: Subset<T, productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductsAggregateArgs>(args: Subset<T, ProductsAggregateArgs>): Prisma.PrismaPromise<GetProductsAggregateType<T>>

    /**
     * Group by Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: productsGroupByArgs['orderBy'] }
        : { orderBy?: productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the products model
   */
  readonly fields: productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    series<T extends products$seriesArgs<ExtArgs> = {}>(args?: Subset<T, products$seriesArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    records<T extends products$recordsArgs<ExtArgs> = {}>(args?: Subset<T, products$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    regulations<T extends products$regulationsArgs<ExtArgs> = {}>(args?: Subset<T, products$regulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    semi_products<T extends products$semi_productsArgs<ExtArgs> = {}>(args?: Subset<T, products$semi_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the products model
   */
  interface productsFieldRefs {
    readonly id: FieldRef<"products", 'Int'>
    readonly code1C: FieldRef<"products", 'String'>
    readonly marking: FieldRef<"products", 'String'>
    readonly name: FieldRef<"products", 'String'>
    readonly serieId: FieldRef<"products", 'Int'>
    readonly createdAt: FieldRef<"products", 'DateTime'>
    readonly updatedAt: FieldRef<"products", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * products findUnique
   */
  export type productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findUniqueOrThrow
   */
  export type productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products findFirst
   */
  export type productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findFirstOrThrow
   */
  export type productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of products.
     */
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products findMany
   */
  export type productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter, which products to fetch.
     */
    where?: productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of products to fetch.
     */
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing products.
     */
    cursor?: productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` products.
     */
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * products create
   */
  export type productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to create a products.
     */
    data: XOR<productsCreateInput, productsUncheckedCreateInput>
  }

  /**
   * products createMany
   */
  export type productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * products createManyAndReturn
   */
  export type productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to create many products.
     */
    data: productsCreateManyInput | productsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * products update
   */
  export type productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The data needed to update a products.
     */
    data: XOR<productsUpdateInput, productsUncheckedUpdateInput>
    /**
     * Choose, which products to update.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products updateMany
   */
  export type productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
  }

  /**
   * products updateManyAndReturn
   */
  export type productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * The data used to update products.
     */
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyInput>
    /**
     * Filter which products to update
     */
    where?: productsWhereInput
    /**
     * Limit how many products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * products upsert
   */
  export type productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * The filter to search for the products to update in case it exists.
     */
    where: productsWhereUniqueInput
    /**
     * In case the products found by the `where` argument doesn't exist, create a new products with this data.
     */
    create: XOR<productsCreateInput, productsUncheckedCreateInput>
    /**
     * In case the products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<productsUpdateInput, productsUncheckedUpdateInput>
  }

  /**
   * products delete
   */
  export type productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    /**
     * Filter which products to delete.
     */
    where: productsWhereUniqueInput
  }

  /**
   * products deleteMany
   */
  export type productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which products to delete
     */
    where?: productsWhereInput
    /**
     * Limit how many products to delete.
     */
    limit?: number
  }

  /**
   * products.series
   */
  export type products$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    where?: seriesWhereInput
  }

  /**
   * products.records
   */
  export type products$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    cursor?: recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * products.regulations
   */
  export type products$regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    where?: regulationsWhereInput
    orderBy?: regulationsOrderByWithRelationInput | regulationsOrderByWithRelationInput[]
    cursor?: regulationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegulationsScalarFieldEnum | RegulationsScalarFieldEnum[]
  }

  /**
   * products.semi_products
   */
  export type products$semi_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    where?: semi_productsWhereInput
    orderBy?: semi_productsOrderByWithRelationInput | semi_productsOrderByWithRelationInput[]
    cursor?: semi_productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Semi_productsScalarFieldEnum | Semi_productsScalarFieldEnum[]
  }

  /**
   * products without action
   */
  export type productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
  }


  /**
   * Model record_regulations
   */

  export type AggregateRecord_regulations = {
    _count: Record_regulationsCountAggregateOutputType | null
    _avg: Record_regulationsAvgAggregateOutputType | null
    _sum: Record_regulationsSumAggregateOutputType | null
    _min: Record_regulationsMinAggregateOutputType | null
    _max: Record_regulationsMaxAggregateOutputType | null
  }

  export type Record_regulationsAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
    org_base_min_weight: Decimal | null
    org_base_max_weight: Decimal | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    marking_sample_id: number | null
  }

  export type Record_regulationsSumAggregateOutputType = {
    id: number | null
    record_id: number | null
    org_base_min_weight: Decimal | null
    org_base_max_weight: Decimal | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    marking_sample_id: number | null
  }

  export type Record_regulationsMinAggregateOutputType = {
    id: number | null
    record_id: number | null
    org_base_min_weight: Decimal | null
    org_base_max_weight: Decimal | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    gasket: string | null
    seal: boolean | null
    technician_note: string | null
    packaging_note: string | null
    marking_sample_id: number | null
    inc_color: string | null
    marking_feature: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Record_regulationsMaxAggregateOutputType = {
    id: number | null
    record_id: number | null
    org_base_min_weight: Decimal | null
    org_base_max_weight: Decimal | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    gasket: string | null
    seal: boolean | null
    technician_note: string | null
    packaging_note: string | null
    marking_sample_id: number | null
    inc_color: string | null
    marking_feature: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Record_regulationsCountAggregateOutputType = {
    id: number
    record_id: number
    org_base_min_weight: number
    org_base_max_weight: number
    water_base_min_weight: number
    water_base_max_weight: number
    per_box: number
    box_per_row: number
    row_on_pallet: number
    gasket: number
    seal: number
    technician_note: number
    packaging_note: number
    marking_sample_id: number
    inc_color: number
    marking_feature: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Record_regulationsAvgAggregateInputType = {
    id?: true
    record_id?: true
    org_base_min_weight?: true
    org_base_max_weight?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    marking_sample_id?: true
  }

  export type Record_regulationsSumAggregateInputType = {
    id?: true
    record_id?: true
    org_base_min_weight?: true
    org_base_max_weight?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    marking_sample_id?: true
  }

  export type Record_regulationsMinAggregateInputType = {
    id?: true
    record_id?: true
    org_base_min_weight?: true
    org_base_max_weight?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    gasket?: true
    seal?: true
    technician_note?: true
    packaging_note?: true
    marking_sample_id?: true
    inc_color?: true
    marking_feature?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Record_regulationsMaxAggregateInputType = {
    id?: true
    record_id?: true
    org_base_min_weight?: true
    org_base_max_weight?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    gasket?: true
    seal?: true
    technician_note?: true
    packaging_note?: true
    marking_sample_id?: true
    inc_color?: true
    marking_feature?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Record_regulationsCountAggregateInputType = {
    id?: true
    record_id?: true
    org_base_min_weight?: true
    org_base_max_weight?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    gasket?: true
    seal?: true
    technician_note?: true
    packaging_note?: true
    marking_sample_id?: true
    inc_color?: true
    marking_feature?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Record_regulationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which record_regulations to aggregate.
     */
    where?: record_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of record_regulations to fetch.
     */
    orderBy?: record_regulationsOrderByWithRelationInput | record_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: record_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` record_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` record_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned record_regulations
    **/
    _count?: true | Record_regulationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Record_regulationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Record_regulationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Record_regulationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Record_regulationsMaxAggregateInputType
  }

  export type GetRecord_regulationsAggregateType<T extends Record_regulationsAggregateArgs> = {
        [P in keyof T & keyof AggregateRecord_regulations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecord_regulations[P]>
      : GetScalarType<T[P], AggregateRecord_regulations[P]>
  }




  export type record_regulationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: record_regulationsWhereInput
    orderBy?: record_regulationsOrderByWithAggregationInput | record_regulationsOrderByWithAggregationInput[]
    by: Record_regulationsScalarFieldEnum[] | Record_regulationsScalarFieldEnum
    having?: record_regulationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Record_regulationsCountAggregateInputType | true
    _avg?: Record_regulationsAvgAggregateInputType
    _sum?: Record_regulationsSumAggregateInputType
    _min?: Record_regulationsMinAggregateInputType
    _max?: Record_regulationsMaxAggregateInputType
  }

  export type Record_regulationsGroupByOutputType = {
    id: number
    record_id: number | null
    org_base_min_weight: Decimal | null
    org_base_max_weight: Decimal | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    gasket: string | null
    seal: boolean | null
    technician_note: string | null
    packaging_note: string | null
    marking_sample_id: number | null
    inc_color: string | null
    marking_feature: string | null
    createdAt: Date
    updatedAt: Date
    _count: Record_regulationsCountAggregateOutputType | null
    _avg: Record_regulationsAvgAggregateOutputType | null
    _sum: Record_regulationsSumAggregateOutputType | null
    _min: Record_regulationsMinAggregateOutputType | null
    _max: Record_regulationsMaxAggregateOutputType | null
  }

  type GetRecord_regulationsGroupByPayload<T extends record_regulationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Record_regulationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Record_regulationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Record_regulationsGroupByOutputType[P]>
            : GetScalarType<T[P], Record_regulationsGroupByOutputType[P]>
        }
      >
    >


  export type record_regulationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    org_base_min_weight?: boolean
    org_base_max_weight?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    inc_color?: boolean
    marking_feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marking_sample?: boolean | record_regulations$marking_sampleArgs<ExtArgs>
    records?: boolean | record_regulations$recordsArgs<ExtArgs>
  }, ExtArgs["result"]["record_regulations"]>

  export type record_regulationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    org_base_min_weight?: boolean
    org_base_max_weight?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    inc_color?: boolean
    marking_feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marking_sample?: boolean | record_regulations$marking_sampleArgs<ExtArgs>
    records?: boolean | record_regulations$recordsArgs<ExtArgs>
  }, ExtArgs["result"]["record_regulations"]>

  export type record_regulationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    org_base_min_weight?: boolean
    org_base_max_weight?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    inc_color?: boolean
    marking_feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marking_sample?: boolean | record_regulations$marking_sampleArgs<ExtArgs>
    records?: boolean | record_regulations$recordsArgs<ExtArgs>
  }, ExtArgs["result"]["record_regulations"]>

  export type record_regulationsSelectScalar = {
    id?: boolean
    record_id?: boolean
    org_base_min_weight?: boolean
    org_base_max_weight?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    inc_color?: boolean
    marking_feature?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type record_regulationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "record_id" | "org_base_min_weight" | "org_base_max_weight" | "water_base_min_weight" | "water_base_max_weight" | "per_box" | "box_per_row" | "row_on_pallet" | "gasket" | "seal" | "technician_note" | "packaging_note" | "marking_sample_id" | "inc_color" | "marking_feature" | "createdAt" | "updatedAt", ExtArgs["result"]["record_regulations"]>
  export type record_regulationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marking_sample?: boolean | record_regulations$marking_sampleArgs<ExtArgs>
    records?: boolean | record_regulations$recordsArgs<ExtArgs>
  }
  export type record_regulationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marking_sample?: boolean | record_regulations$marking_sampleArgs<ExtArgs>
    records?: boolean | record_regulations$recordsArgs<ExtArgs>
  }
  export type record_regulationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marking_sample?: boolean | record_regulations$marking_sampleArgs<ExtArgs>
    records?: boolean | record_regulations$recordsArgs<ExtArgs>
  }

  export type $record_regulationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "record_regulations"
    objects: {
      marking_sample: Prisma.$marking_samplePayload<ExtArgs> | null
      records: Prisma.$recordsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      record_id: number | null
      org_base_min_weight: Prisma.Decimal | null
      org_base_max_weight: Prisma.Decimal | null
      water_base_min_weight: Prisma.Decimal | null
      water_base_max_weight: Prisma.Decimal | null
      per_box: number | null
      box_per_row: number | null
      row_on_pallet: number | null
      gasket: string | null
      seal: boolean | null
      technician_note: string | null
      packaging_note: string | null
      marking_sample_id: number | null
      inc_color: string | null
      marking_feature: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["record_regulations"]>
    composites: {}
  }

  type record_regulationsGetPayload<S extends boolean | null | undefined | record_regulationsDefaultArgs> = $Result.GetResult<Prisma.$record_regulationsPayload, S>

  type record_regulationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<record_regulationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Record_regulationsCountAggregateInputType | true
    }

  export interface record_regulationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['record_regulations'], meta: { name: 'record_regulations' } }
    /**
     * Find zero or one Record_regulations that matches the filter.
     * @param {record_regulationsFindUniqueArgs} args - Arguments to find a Record_regulations
     * @example
     * // Get one Record_regulations
     * const record_regulations = await prisma.record_regulations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends record_regulationsFindUniqueArgs>(args: SelectSubset<T, record_regulationsFindUniqueArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Record_regulations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {record_regulationsFindUniqueOrThrowArgs} args - Arguments to find a Record_regulations
     * @example
     * // Get one Record_regulations
     * const record_regulations = await prisma.record_regulations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends record_regulationsFindUniqueOrThrowArgs>(args: SelectSubset<T, record_regulationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Record_regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {record_regulationsFindFirstArgs} args - Arguments to find a Record_regulations
     * @example
     * // Get one Record_regulations
     * const record_regulations = await prisma.record_regulations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends record_regulationsFindFirstArgs>(args?: SelectSubset<T, record_regulationsFindFirstArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Record_regulations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {record_regulationsFindFirstOrThrowArgs} args - Arguments to find a Record_regulations
     * @example
     * // Get one Record_regulations
     * const record_regulations = await prisma.record_regulations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends record_regulationsFindFirstOrThrowArgs>(args?: SelectSubset<T, record_regulationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Record_regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {record_regulationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Record_regulations
     * const record_regulations = await prisma.record_regulations.findMany()
     * 
     * // Get first 10 Record_regulations
     * const record_regulations = await prisma.record_regulations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const record_regulationsWithIdOnly = await prisma.record_regulations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends record_regulationsFindManyArgs>(args?: SelectSubset<T, record_regulationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Record_regulations.
     * @param {record_regulationsCreateArgs} args - Arguments to create a Record_regulations.
     * @example
     * // Create one Record_regulations
     * const Record_regulations = await prisma.record_regulations.create({
     *   data: {
     *     // ... data to create a Record_regulations
     *   }
     * })
     * 
     */
    create<T extends record_regulationsCreateArgs>(args: SelectSubset<T, record_regulationsCreateArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Record_regulations.
     * @param {record_regulationsCreateManyArgs} args - Arguments to create many Record_regulations.
     * @example
     * // Create many Record_regulations
     * const record_regulations = await prisma.record_regulations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends record_regulationsCreateManyArgs>(args?: SelectSubset<T, record_regulationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Record_regulations and returns the data saved in the database.
     * @param {record_regulationsCreateManyAndReturnArgs} args - Arguments to create many Record_regulations.
     * @example
     * // Create many Record_regulations
     * const record_regulations = await prisma.record_regulations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Record_regulations and only return the `id`
     * const record_regulationsWithIdOnly = await prisma.record_regulations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends record_regulationsCreateManyAndReturnArgs>(args?: SelectSubset<T, record_regulationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Record_regulations.
     * @param {record_regulationsDeleteArgs} args - Arguments to delete one Record_regulations.
     * @example
     * // Delete one Record_regulations
     * const Record_regulations = await prisma.record_regulations.delete({
     *   where: {
     *     // ... filter to delete one Record_regulations
     *   }
     * })
     * 
     */
    delete<T extends record_regulationsDeleteArgs>(args: SelectSubset<T, record_regulationsDeleteArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Record_regulations.
     * @param {record_regulationsUpdateArgs} args - Arguments to update one Record_regulations.
     * @example
     * // Update one Record_regulations
     * const record_regulations = await prisma.record_regulations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends record_regulationsUpdateArgs>(args: SelectSubset<T, record_regulationsUpdateArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Record_regulations.
     * @param {record_regulationsDeleteManyArgs} args - Arguments to filter Record_regulations to delete.
     * @example
     * // Delete a few Record_regulations
     * const { count } = await prisma.record_regulations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends record_regulationsDeleteManyArgs>(args?: SelectSubset<T, record_regulationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Record_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {record_regulationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Record_regulations
     * const record_regulations = await prisma.record_regulations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends record_regulationsUpdateManyArgs>(args: SelectSubset<T, record_regulationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Record_regulations and returns the data updated in the database.
     * @param {record_regulationsUpdateManyAndReturnArgs} args - Arguments to update many Record_regulations.
     * @example
     * // Update many Record_regulations
     * const record_regulations = await prisma.record_regulations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Record_regulations and only return the `id`
     * const record_regulationsWithIdOnly = await prisma.record_regulations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends record_regulationsUpdateManyAndReturnArgs>(args: SelectSubset<T, record_regulationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Record_regulations.
     * @param {record_regulationsUpsertArgs} args - Arguments to update or create a Record_regulations.
     * @example
     * // Update or create a Record_regulations
     * const record_regulations = await prisma.record_regulations.upsert({
     *   create: {
     *     // ... data to create a Record_regulations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Record_regulations we want to update
     *   }
     * })
     */
    upsert<T extends record_regulationsUpsertArgs>(args: SelectSubset<T, record_regulationsUpsertArgs<ExtArgs>>): Prisma__record_regulationsClient<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Record_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {record_regulationsCountArgs} args - Arguments to filter Record_regulations to count.
     * @example
     * // Count the number of Record_regulations
     * const count = await prisma.record_regulations.count({
     *   where: {
     *     // ... the filter for the Record_regulations we want to count
     *   }
     * })
    **/
    count<T extends record_regulationsCountArgs>(
      args?: Subset<T, record_regulationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Record_regulationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Record_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Record_regulationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Record_regulationsAggregateArgs>(args: Subset<T, Record_regulationsAggregateArgs>): Prisma.PrismaPromise<GetRecord_regulationsAggregateType<T>>

    /**
     * Group by Record_regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {record_regulationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends record_regulationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: record_regulationsGroupByArgs['orderBy'] }
        : { orderBy?: record_regulationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, record_regulationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecord_regulationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the record_regulations model
   */
  readonly fields: record_regulationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for record_regulations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__record_regulationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marking_sample<T extends record_regulations$marking_sampleArgs<ExtArgs> = {}>(args?: Subset<T, record_regulations$marking_sampleArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    records<T extends record_regulations$recordsArgs<ExtArgs> = {}>(args?: Subset<T, record_regulations$recordsArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the record_regulations model
   */
  interface record_regulationsFieldRefs {
    readonly id: FieldRef<"record_regulations", 'Int'>
    readonly record_id: FieldRef<"record_regulations", 'Int'>
    readonly org_base_min_weight: FieldRef<"record_regulations", 'Decimal'>
    readonly org_base_max_weight: FieldRef<"record_regulations", 'Decimal'>
    readonly water_base_min_weight: FieldRef<"record_regulations", 'Decimal'>
    readonly water_base_max_weight: FieldRef<"record_regulations", 'Decimal'>
    readonly per_box: FieldRef<"record_regulations", 'Int'>
    readonly box_per_row: FieldRef<"record_regulations", 'Int'>
    readonly row_on_pallet: FieldRef<"record_regulations", 'Int'>
    readonly gasket: FieldRef<"record_regulations", 'String'>
    readonly seal: FieldRef<"record_regulations", 'Boolean'>
    readonly technician_note: FieldRef<"record_regulations", 'String'>
    readonly packaging_note: FieldRef<"record_regulations", 'String'>
    readonly marking_sample_id: FieldRef<"record_regulations", 'Int'>
    readonly inc_color: FieldRef<"record_regulations", 'String'>
    readonly marking_feature: FieldRef<"record_regulations", 'String'>
    readonly createdAt: FieldRef<"record_regulations", 'DateTime'>
    readonly updatedAt: FieldRef<"record_regulations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * record_regulations findUnique
   */
  export type record_regulationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * Filter, which record_regulations to fetch.
     */
    where: record_regulationsWhereUniqueInput
  }

  /**
   * record_regulations findUniqueOrThrow
   */
  export type record_regulationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * Filter, which record_regulations to fetch.
     */
    where: record_regulationsWhereUniqueInput
  }

  /**
   * record_regulations findFirst
   */
  export type record_regulationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * Filter, which record_regulations to fetch.
     */
    where?: record_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of record_regulations to fetch.
     */
    orderBy?: record_regulationsOrderByWithRelationInput | record_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for record_regulations.
     */
    cursor?: record_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` record_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` record_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of record_regulations.
     */
    distinct?: Record_regulationsScalarFieldEnum | Record_regulationsScalarFieldEnum[]
  }

  /**
   * record_regulations findFirstOrThrow
   */
  export type record_regulationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * Filter, which record_regulations to fetch.
     */
    where?: record_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of record_regulations to fetch.
     */
    orderBy?: record_regulationsOrderByWithRelationInput | record_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for record_regulations.
     */
    cursor?: record_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` record_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` record_regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of record_regulations.
     */
    distinct?: Record_regulationsScalarFieldEnum | Record_regulationsScalarFieldEnum[]
  }

  /**
   * record_regulations findMany
   */
  export type record_regulationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * Filter, which record_regulations to fetch.
     */
    where?: record_regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of record_regulations to fetch.
     */
    orderBy?: record_regulationsOrderByWithRelationInput | record_regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing record_regulations.
     */
    cursor?: record_regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` record_regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` record_regulations.
     */
    skip?: number
    distinct?: Record_regulationsScalarFieldEnum | Record_regulationsScalarFieldEnum[]
  }

  /**
   * record_regulations create
   */
  export type record_regulationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * The data needed to create a record_regulations.
     */
    data: XOR<record_regulationsCreateInput, record_regulationsUncheckedCreateInput>
  }

  /**
   * record_regulations createMany
   */
  export type record_regulationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many record_regulations.
     */
    data: record_regulationsCreateManyInput | record_regulationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * record_regulations createManyAndReturn
   */
  export type record_regulationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * The data used to create many record_regulations.
     */
    data: record_regulationsCreateManyInput | record_regulationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * record_regulations update
   */
  export type record_regulationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * The data needed to update a record_regulations.
     */
    data: XOR<record_regulationsUpdateInput, record_regulationsUncheckedUpdateInput>
    /**
     * Choose, which record_regulations to update.
     */
    where: record_regulationsWhereUniqueInput
  }

  /**
   * record_regulations updateMany
   */
  export type record_regulationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update record_regulations.
     */
    data: XOR<record_regulationsUpdateManyMutationInput, record_regulationsUncheckedUpdateManyInput>
    /**
     * Filter which record_regulations to update
     */
    where?: record_regulationsWhereInput
    /**
     * Limit how many record_regulations to update.
     */
    limit?: number
  }

  /**
   * record_regulations updateManyAndReturn
   */
  export type record_regulationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * The data used to update record_regulations.
     */
    data: XOR<record_regulationsUpdateManyMutationInput, record_regulationsUncheckedUpdateManyInput>
    /**
     * Filter which record_regulations to update
     */
    where?: record_regulationsWhereInput
    /**
     * Limit how many record_regulations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * record_regulations upsert
   */
  export type record_regulationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * The filter to search for the record_regulations to update in case it exists.
     */
    where: record_regulationsWhereUniqueInput
    /**
     * In case the record_regulations found by the `where` argument doesn't exist, create a new record_regulations with this data.
     */
    create: XOR<record_regulationsCreateInput, record_regulationsUncheckedCreateInput>
    /**
     * In case the record_regulations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<record_regulationsUpdateInput, record_regulationsUncheckedUpdateInput>
  }

  /**
   * record_regulations delete
   */
  export type record_regulationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    /**
     * Filter which record_regulations to delete.
     */
    where: record_regulationsWhereUniqueInput
  }

  /**
   * record_regulations deleteMany
   */
  export type record_regulationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which record_regulations to delete
     */
    where?: record_regulationsWhereInput
    /**
     * Limit how many record_regulations to delete.
     */
    limit?: number
  }

  /**
   * record_regulations.marking_sample
   */
  export type record_regulations$marking_sampleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    where?: marking_sampleWhereInput
  }

  /**
   * record_regulations.records
   */
  export type record_regulations$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
  }

  /**
   * record_regulations without action
   */
  export type record_regulationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
  }


  /**
   * Model records
   */

  export type AggregateRecords = {
    _count: RecordsCountAggregateOutputType | null
    _avg: RecordsAvgAggregateOutputType | null
    _sum: RecordsSumAggregateOutputType | null
    _min: RecordsMinAggregateOutputType | null
    _max: RecordsMaxAggregateOutputType | null
  }

  export type RecordsAvgAggregateOutputType = {
    id: number | null
    doc_id: number | null
    productId: number | null
    boilId: number | null
    apparatusId: number | null
    canId: number | null
    conveyorId: number | null
    plan: number | null
    workshopId: number | null
    organic_base_id: number | null
    water_base_id: number | null
  }

  export type RecordsSumAggregateOutputType = {
    id: number | null
    doc_id: number | null
    productId: number | null
    boilId: number | null
    apparatusId: number | null
    canId: number | null
    conveyorId: number | null
    plan: number | null
    workshopId: number | null
    organic_base_id: number | null
    water_base_id: number | null
  }

  export type RecordsMinAggregateOutputType = {
    id: number | null
    doc_id: number | null
    productId: number | null
    boilId: number | null
    apparatusId: number | null
    canId: number | null
    conveyorId: number | null
    plan: number | null
    bbf: string | null
    note: string | null
    workshopId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isSet: boolean | null
    organic_base_id: number | null
    water_base_id: number | null
    dm: string | null
  }

  export type RecordsMaxAggregateOutputType = {
    id: number | null
    doc_id: number | null
    productId: number | null
    boilId: number | null
    apparatusId: number | null
    canId: number | null
    conveyorId: number | null
    plan: number | null
    bbf: string | null
    note: string | null
    workshopId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isSet: boolean | null
    organic_base_id: number | null
    water_base_id: number | null
    dm: string | null
  }

  export type RecordsCountAggregateOutputType = {
    id: number
    doc_id: number
    productId: number
    boilId: number
    apparatusId: number
    canId: number
    conveyorId: number
    plan: number
    bbf: number
    note: number
    workshopId: number
    createdAt: number
    updatedAt: number
    isSet: number
    organic_base_id: number
    water_base_id: number
    dm: number
    _all: number
  }


  export type RecordsAvgAggregateInputType = {
    id?: true
    doc_id?: true
    productId?: true
    boilId?: true
    apparatusId?: true
    canId?: true
    conveyorId?: true
    plan?: true
    workshopId?: true
    organic_base_id?: true
    water_base_id?: true
  }

  export type RecordsSumAggregateInputType = {
    id?: true
    doc_id?: true
    productId?: true
    boilId?: true
    apparatusId?: true
    canId?: true
    conveyorId?: true
    plan?: true
    workshopId?: true
    organic_base_id?: true
    water_base_id?: true
  }

  export type RecordsMinAggregateInputType = {
    id?: true
    doc_id?: true
    productId?: true
    boilId?: true
    apparatusId?: true
    canId?: true
    conveyorId?: true
    plan?: true
    bbf?: true
    note?: true
    workshopId?: true
    createdAt?: true
    updatedAt?: true
    isSet?: true
    organic_base_id?: true
    water_base_id?: true
    dm?: true
  }

  export type RecordsMaxAggregateInputType = {
    id?: true
    doc_id?: true
    productId?: true
    boilId?: true
    apparatusId?: true
    canId?: true
    conveyorId?: true
    plan?: true
    bbf?: true
    note?: true
    workshopId?: true
    createdAt?: true
    updatedAt?: true
    isSet?: true
    organic_base_id?: true
    water_base_id?: true
    dm?: true
  }

  export type RecordsCountAggregateInputType = {
    id?: true
    doc_id?: true
    productId?: true
    boilId?: true
    apparatusId?: true
    canId?: true
    conveyorId?: true
    plan?: true
    bbf?: true
    note?: true
    workshopId?: true
    createdAt?: true
    updatedAt?: true
    isSet?: true
    organic_base_id?: true
    water_base_id?: true
    dm?: true
    _all?: true
  }

  export type RecordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which records to aggregate.
     */
    where?: recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of records to fetch.
     */
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned records
    **/
    _count?: true | RecordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RecordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RecordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RecordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RecordsMaxAggregateInputType
  }

  export type GetRecordsAggregateType<T extends RecordsAggregateArgs> = {
        [P in keyof T & keyof AggregateRecords]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRecords[P]>
      : GetScalarType<T[P], AggregateRecords[P]>
  }




  export type recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithAggregationInput | recordsOrderByWithAggregationInput[]
    by: RecordsScalarFieldEnum[] | RecordsScalarFieldEnum
    having?: recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RecordsCountAggregateInputType | true
    _avg?: RecordsAvgAggregateInputType
    _sum?: RecordsSumAggregateInputType
    _min?: RecordsMinAggregateInputType
    _max?: RecordsMaxAggregateInputType
  }

  export type RecordsGroupByOutputType = {
    id: number
    doc_id: number | null
    productId: number | null
    boilId: number | null
    apparatusId: number | null
    canId: number | null
    conveyorId: number | null
    plan: number
    bbf: string
    note: string
    workshopId: number | null
    createdAt: Date
    updatedAt: Date
    isSet: boolean | null
    organic_base_id: number | null
    water_base_id: number | null
    dm: string
    _count: RecordsCountAggregateOutputType | null
    _avg: RecordsAvgAggregateOutputType | null
    _sum: RecordsSumAggregateOutputType | null
    _min: RecordsMinAggregateOutputType | null
    _max: RecordsMaxAggregateOutputType | null
  }

  type GetRecordsGroupByPayload<T extends recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RecordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RecordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RecordsGroupByOutputType[P]>
            : GetScalarType<T[P], RecordsGroupByOutputType[P]>
        }
      >
    >


  export type recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc_id?: boolean
    productId?: boolean
    boilId?: boolean
    apparatusId?: boolean
    canId?: boolean
    conveyorId?: boolean
    plan?: boolean
    bbf?: boolean
    note?: boolean
    workshopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSet?: boolean
    organic_base_id?: boolean
    water_base_id?: boolean
    dm?: boolean
    histories?: boolean | records$historiesArgs<ExtArgs>
    record_regulations?: boolean | records$record_regulationsArgs<ExtArgs>
    apparatuses?: boolean | records$apparatusesArgs<ExtArgs>
    cans?: boolean | records$cansArgs<ExtArgs>
    conveyors?: boolean | records$conveyorsArgs<ExtArgs>
    docs?: boolean | records$docsArgs<ExtArgs>
    products?: boolean | records$productsArgs<ExtArgs>
    workshops?: boolean | records$workshopsArgs<ExtArgs>
    boils?: boolean | records$boilsArgs<ExtArgs>
    semi_products?: boolean | records$semi_productsArgs<ExtArgs>
    _count?: boolean | RecordsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["records"]>

  export type recordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc_id?: boolean
    productId?: boolean
    boilId?: boolean
    apparatusId?: boolean
    canId?: boolean
    conveyorId?: boolean
    plan?: boolean
    bbf?: boolean
    note?: boolean
    workshopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSet?: boolean
    organic_base_id?: boolean
    water_base_id?: boolean
    dm?: boolean
    apparatuses?: boolean | records$apparatusesArgs<ExtArgs>
    cans?: boolean | records$cansArgs<ExtArgs>
    conveyors?: boolean | records$conveyorsArgs<ExtArgs>
    docs?: boolean | records$docsArgs<ExtArgs>
    products?: boolean | records$productsArgs<ExtArgs>
    workshops?: boolean | records$workshopsArgs<ExtArgs>
    boils?: boolean | records$boilsArgs<ExtArgs>
  }, ExtArgs["result"]["records"]>

  export type recordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    doc_id?: boolean
    productId?: boolean
    boilId?: boolean
    apparatusId?: boolean
    canId?: boolean
    conveyorId?: boolean
    plan?: boolean
    bbf?: boolean
    note?: boolean
    workshopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSet?: boolean
    organic_base_id?: boolean
    water_base_id?: boolean
    dm?: boolean
    apparatuses?: boolean | records$apparatusesArgs<ExtArgs>
    cans?: boolean | records$cansArgs<ExtArgs>
    conveyors?: boolean | records$conveyorsArgs<ExtArgs>
    docs?: boolean | records$docsArgs<ExtArgs>
    products?: boolean | records$productsArgs<ExtArgs>
    workshops?: boolean | records$workshopsArgs<ExtArgs>
    boils?: boolean | records$boilsArgs<ExtArgs>
  }, ExtArgs["result"]["records"]>

  export type recordsSelectScalar = {
    id?: boolean
    doc_id?: boolean
    productId?: boolean
    boilId?: boolean
    apparatusId?: boolean
    canId?: boolean
    conveyorId?: boolean
    plan?: boolean
    bbf?: boolean
    note?: boolean
    workshopId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isSet?: boolean
    organic_base_id?: boolean
    water_base_id?: boolean
    dm?: boolean
  }

  export type recordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "doc_id" | "productId" | "boilId" | "apparatusId" | "canId" | "conveyorId" | "plan" | "bbf" | "note" | "workshopId" | "createdAt" | "updatedAt" | "isSet" | "organic_base_id" | "water_base_id" | "dm", ExtArgs["result"]["records"]>
  export type recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | records$historiesArgs<ExtArgs>
    record_regulations?: boolean | records$record_regulationsArgs<ExtArgs>
    apparatuses?: boolean | records$apparatusesArgs<ExtArgs>
    cans?: boolean | records$cansArgs<ExtArgs>
    conveyors?: boolean | records$conveyorsArgs<ExtArgs>
    docs?: boolean | records$docsArgs<ExtArgs>
    products?: boolean | records$productsArgs<ExtArgs>
    workshops?: boolean | records$workshopsArgs<ExtArgs>
    boils?: boolean | records$boilsArgs<ExtArgs>
    semi_products?: boolean | records$semi_productsArgs<ExtArgs>
    _count?: boolean | RecordsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type recordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apparatuses?: boolean | records$apparatusesArgs<ExtArgs>
    cans?: boolean | records$cansArgs<ExtArgs>
    conveyors?: boolean | records$conveyorsArgs<ExtArgs>
    docs?: boolean | records$docsArgs<ExtArgs>
    products?: boolean | records$productsArgs<ExtArgs>
    workshops?: boolean | records$workshopsArgs<ExtArgs>
    boils?: boolean | records$boilsArgs<ExtArgs>
  }
  export type recordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apparatuses?: boolean | records$apparatusesArgs<ExtArgs>
    cans?: boolean | records$cansArgs<ExtArgs>
    conveyors?: boolean | records$conveyorsArgs<ExtArgs>
    docs?: boolean | records$docsArgs<ExtArgs>
    products?: boolean | records$productsArgs<ExtArgs>
    workshops?: boolean | records$workshopsArgs<ExtArgs>
    boils?: boolean | records$boilsArgs<ExtArgs>
  }

  export type $recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "records"
    objects: {
      histories: Prisma.$historiesPayload<ExtArgs>[]
      record_regulations: Prisma.$record_regulationsPayload<ExtArgs>[]
      apparatuses: Prisma.$apparatusesPayload<ExtArgs> | null
      cans: Prisma.$cansPayload<ExtArgs> | null
      conveyors: Prisma.$conveyorsPayload<ExtArgs> | null
      docs: Prisma.$docsPayload<ExtArgs> | null
      products: Prisma.$productsPayload<ExtArgs> | null
      workshops: Prisma.$workshopsPayload<ExtArgs> | null
      boils: Prisma.$boilsPayload<ExtArgs> | null
      semi_products: Prisma.$semi_productsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      doc_id: number | null
      productId: number | null
      boilId: number | null
      apparatusId: number | null
      canId: number | null
      conveyorId: number | null
      plan: number
      bbf: string
      note: string
      workshopId: number | null
      createdAt: Date
      updatedAt: Date
      isSet: boolean | null
      organic_base_id: number | null
      water_base_id: number | null
      dm: string
    }, ExtArgs["result"]["records"]>
    composites: {}
  }

  type recordsGetPayload<S extends boolean | null | undefined | recordsDefaultArgs> = $Result.GetResult<Prisma.$recordsPayload, S>

  type recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<recordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RecordsCountAggregateInputType | true
    }

  export interface recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['records'], meta: { name: 'records' } }
    /**
     * Find zero or one Records that matches the filter.
     * @param {recordsFindUniqueArgs} args - Arguments to find a Records
     * @example
     * // Get one Records
     * const records = await prisma.records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends recordsFindUniqueArgs>(args: SelectSubset<T, recordsFindUniqueArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Records that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {recordsFindUniqueOrThrowArgs} args - Arguments to find a Records
     * @example
     * // Get one Records
     * const records = await prisma.records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordsFindFirstArgs} args - Arguments to find a Records
     * @example
     * // Get one Records
     * const records = await prisma.records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends recordsFindFirstArgs>(args?: SelectSubset<T, recordsFindFirstArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordsFindFirstOrThrowArgs} args - Arguments to find a Records
     * @example
     * // Get one Records
     * const records = await prisma.records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Records
     * const records = await prisma.records.findMany()
     * 
     * // Get first 10 Records
     * const records = await prisma.records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const recordsWithIdOnly = await prisma.records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends recordsFindManyArgs>(args?: SelectSubset<T, recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Records.
     * @param {recordsCreateArgs} args - Arguments to create a Records.
     * @example
     * // Create one Records
     * const Records = await prisma.records.create({
     *   data: {
     *     // ... data to create a Records
     *   }
     * })
     * 
     */
    create<T extends recordsCreateArgs>(args: SelectSubset<T, recordsCreateArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Records.
     * @param {recordsCreateManyArgs} args - Arguments to create many Records.
     * @example
     * // Create many Records
     * const records = await prisma.records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends recordsCreateManyArgs>(args?: SelectSubset<T, recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Records and returns the data saved in the database.
     * @param {recordsCreateManyAndReturnArgs} args - Arguments to create many Records.
     * @example
     * // Create many Records
     * const records = await prisma.records.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Records and only return the `id`
     * const recordsWithIdOnly = await prisma.records.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends recordsCreateManyAndReturnArgs>(args?: SelectSubset<T, recordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Records.
     * @param {recordsDeleteArgs} args - Arguments to delete one Records.
     * @example
     * // Delete one Records
     * const Records = await prisma.records.delete({
     *   where: {
     *     // ... filter to delete one Records
     *   }
     * })
     * 
     */
    delete<T extends recordsDeleteArgs>(args: SelectSubset<T, recordsDeleteArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Records.
     * @param {recordsUpdateArgs} args - Arguments to update one Records.
     * @example
     * // Update one Records
     * const records = await prisma.records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends recordsUpdateArgs>(args: SelectSubset<T, recordsUpdateArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Records.
     * @param {recordsDeleteManyArgs} args - Arguments to filter Records to delete.
     * @example
     * // Delete a few Records
     * const { count } = await prisma.records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends recordsDeleteManyArgs>(args?: SelectSubset<T, recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Records
     * const records = await prisma.records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends recordsUpdateManyArgs>(args: SelectSubset<T, recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Records and returns the data updated in the database.
     * @param {recordsUpdateManyAndReturnArgs} args - Arguments to update many Records.
     * @example
     * // Update many Records
     * const records = await prisma.records.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Records and only return the `id`
     * const recordsWithIdOnly = await prisma.records.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends recordsUpdateManyAndReturnArgs>(args: SelectSubset<T, recordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Records.
     * @param {recordsUpsertArgs} args - Arguments to update or create a Records.
     * @example
     * // Update or create a Records
     * const records = await prisma.records.upsert({
     *   create: {
     *     // ... data to create a Records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Records we want to update
     *   }
     * })
     */
    upsert<T extends recordsUpsertArgs>(args: SelectSubset<T, recordsUpsertArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordsCountArgs} args - Arguments to filter Records to count.
     * @example
     * // Count the number of Records
     * const count = await prisma.records.count({
     *   where: {
     *     // ... the filter for the Records we want to count
     *   }
     * })
    **/
    count<T extends recordsCountArgs>(
      args?: Subset<T, recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RecordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RecordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RecordsAggregateArgs>(args: Subset<T, RecordsAggregateArgs>): Prisma.PrismaPromise<GetRecordsAggregateType<T>>

    /**
     * Group by Records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: recordsGroupByArgs['orderBy'] }
        : { orderBy?: recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRecordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the records model
   */
  readonly fields: recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    histories<T extends records$historiesArgs<ExtArgs> = {}>(args?: Subset<T, records$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    record_regulations<T extends records$record_regulationsArgs<ExtArgs> = {}>(args?: Subset<T, records$record_regulationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$record_regulationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apparatuses<T extends records$apparatusesArgs<ExtArgs> = {}>(args?: Subset<T, records$apparatusesArgs<ExtArgs>>): Prisma__apparatusesClient<$Result.GetResult<Prisma.$apparatusesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cans<T extends records$cansArgs<ExtArgs> = {}>(args?: Subset<T, records$cansArgs<ExtArgs>>): Prisma__cansClient<$Result.GetResult<Prisma.$cansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    conveyors<T extends records$conveyorsArgs<ExtArgs> = {}>(args?: Subset<T, records$conveyorsArgs<ExtArgs>>): Prisma__conveyorsClient<$Result.GetResult<Prisma.$conveyorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    docs<T extends records$docsArgs<ExtArgs> = {}>(args?: Subset<T, records$docsArgs<ExtArgs>>): Prisma__docsClient<$Result.GetResult<Prisma.$docsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends records$productsArgs<ExtArgs> = {}>(args?: Subset<T, records$productsArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workshops<T extends records$workshopsArgs<ExtArgs> = {}>(args?: Subset<T, records$workshopsArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    boils<T extends records$boilsArgs<ExtArgs> = {}>(args?: Subset<T, records$boilsArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    semi_products<T extends records$semi_productsArgs<ExtArgs> = {}>(args?: Subset<T, records$semi_productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the records model
   */
  interface recordsFieldRefs {
    readonly id: FieldRef<"records", 'Int'>
    readonly doc_id: FieldRef<"records", 'Int'>
    readonly productId: FieldRef<"records", 'Int'>
    readonly boilId: FieldRef<"records", 'Int'>
    readonly apparatusId: FieldRef<"records", 'Int'>
    readonly canId: FieldRef<"records", 'Int'>
    readonly conveyorId: FieldRef<"records", 'Int'>
    readonly plan: FieldRef<"records", 'Int'>
    readonly bbf: FieldRef<"records", 'String'>
    readonly note: FieldRef<"records", 'String'>
    readonly workshopId: FieldRef<"records", 'Int'>
    readonly createdAt: FieldRef<"records", 'DateTime'>
    readonly updatedAt: FieldRef<"records", 'DateTime'>
    readonly isSet: FieldRef<"records", 'Boolean'>
    readonly organic_base_id: FieldRef<"records", 'Int'>
    readonly water_base_id: FieldRef<"records", 'Int'>
    readonly dm: FieldRef<"records", 'String'>
  }
    

  // Custom InputTypes
  /**
   * records findUnique
   */
  export type recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * Filter, which records to fetch.
     */
    where: recordsWhereUniqueInput
  }

  /**
   * records findUniqueOrThrow
   */
  export type recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * Filter, which records to fetch.
     */
    where: recordsWhereUniqueInput
  }

  /**
   * records findFirst
   */
  export type recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * Filter, which records to fetch.
     */
    where?: recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of records to fetch.
     */
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for records.
     */
    cursor?: recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of records.
     */
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * records findFirstOrThrow
   */
  export type recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * Filter, which records to fetch.
     */
    where?: recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of records to fetch.
     */
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for records.
     */
    cursor?: recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of records.
     */
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * records findMany
   */
  export type recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * Filter, which records to fetch.
     */
    where?: recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of records to fetch.
     */
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing records.
     */
    cursor?: recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` records.
     */
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * records create
   */
  export type recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * The data needed to create a records.
     */
    data: XOR<recordsCreateInput, recordsUncheckedCreateInput>
  }

  /**
   * records createMany
   */
  export type recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many records.
     */
    data: recordsCreateManyInput | recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * records createManyAndReturn
   */
  export type recordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * The data used to create many records.
     */
    data: recordsCreateManyInput | recordsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * records update
   */
  export type recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * The data needed to update a records.
     */
    data: XOR<recordsUpdateInput, recordsUncheckedUpdateInput>
    /**
     * Choose, which records to update.
     */
    where: recordsWhereUniqueInput
  }

  /**
   * records updateMany
   */
  export type recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update records.
     */
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyInput>
    /**
     * Filter which records to update
     */
    where?: recordsWhereInput
    /**
     * Limit how many records to update.
     */
    limit?: number
  }

  /**
   * records updateManyAndReturn
   */
  export type recordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * The data used to update records.
     */
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyInput>
    /**
     * Filter which records to update
     */
    where?: recordsWhereInput
    /**
     * Limit how many records to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * records upsert
   */
  export type recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * The filter to search for the records to update in case it exists.
     */
    where: recordsWhereUniqueInput
    /**
     * In case the records found by the `where` argument doesn't exist, create a new records with this data.
     */
    create: XOR<recordsCreateInput, recordsUncheckedCreateInput>
    /**
     * In case the records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<recordsUpdateInput, recordsUncheckedUpdateInput>
  }

  /**
   * records delete
   */
  export type recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    /**
     * Filter which records to delete.
     */
    where: recordsWhereUniqueInput
  }

  /**
   * records deleteMany
   */
  export type recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which records to delete
     */
    where?: recordsWhereInput
    /**
     * Limit how many records to delete.
     */
    limit?: number
  }

  /**
   * records.histories
   */
  export type records$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    where?: historiesWhereInput
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    cursor?: historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoriesScalarFieldEnum | HistoriesScalarFieldEnum[]
  }

  /**
   * records.record_regulations
   */
  export type records$record_regulationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the record_regulations
     */
    select?: record_regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the record_regulations
     */
    omit?: record_regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: record_regulationsInclude<ExtArgs> | null
    where?: record_regulationsWhereInput
    orderBy?: record_regulationsOrderByWithRelationInput | record_regulationsOrderByWithRelationInput[]
    cursor?: record_regulationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Record_regulationsScalarFieldEnum | Record_regulationsScalarFieldEnum[]
  }

  /**
   * records.apparatuses
   */
  export type records$apparatusesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the apparatuses
     */
    select?: apparatusesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the apparatuses
     */
    omit?: apparatusesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: apparatusesInclude<ExtArgs> | null
    where?: apparatusesWhereInput
  }

  /**
   * records.cans
   */
  export type records$cansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cans
     */
    select?: cansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cans
     */
    omit?: cansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cansInclude<ExtArgs> | null
    where?: cansWhereInput
  }

  /**
   * records.conveyors
   */
  export type records$conveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conveyors
     */
    select?: conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conveyors
     */
    omit?: conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: conveyorsInclude<ExtArgs> | null
    where?: conveyorsWhereInput
  }

  /**
   * records.docs
   */
  export type records$docsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the docs
     */
    select?: docsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the docs
     */
    omit?: docsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: docsInclude<ExtArgs> | null
    where?: docsWhereInput
  }

  /**
   * records.products
   */
  export type records$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * records.workshops
   */
  export type records$workshopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    where?: workshopsWhereInput
  }

  /**
   * records.boils
   */
  export type records$boilsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    where?: boilsWhereInput
  }

  /**
   * records.semi_products
   */
  export type records$semi_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    where?: semi_productsWhereInput
    orderBy?: semi_productsOrderByWithRelationInput | semi_productsOrderByWithRelationInput[]
    cursor?: semi_productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Semi_productsScalarFieldEnum | Semi_productsScalarFieldEnum[]
  }

  /**
   * records without action
   */
  export type recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
  }


  /**
   * Model regulations
   */

  export type AggregateRegulations = {
    _count: RegulationsCountAggregateOutputType | null
    _avg: RegulationsAvgAggregateOutputType | null
    _sum: RegulationsSumAggregateOutputType | null
    _min: RegulationsMinAggregateOutputType | null
    _max: RegulationsMaxAggregateOutputType | null
  }

  export type RegulationsAvgAggregateOutputType = {
    id: number | null
    product_id: number | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    marking_sample_id: number | null
  }

  export type RegulationsSumAggregateOutputType = {
    id: number | null
    product_id: number | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    marking_sample_id: number | null
  }

  export type RegulationsMinAggregateOutputType = {
    id: number | null
    product_id: number | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    gasket: string | null
    seal: boolean | null
    technician_note: string | null
    packaging_note: string | null
    marking_sample_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegulationsMaxAggregateOutputType = {
    id: number | null
    product_id: number | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    gasket: string | null
    seal: boolean | null
    technician_note: string | null
    packaging_note: string | null
    marking_sample_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RegulationsCountAggregateOutputType = {
    id: number
    product_id: number
    water_base_min_weight: number
    water_base_max_weight: number
    per_box: number
    box_per_row: number
    row_on_pallet: number
    gasket: number
    seal: number
    technician_note: number
    packaging_note: number
    marking_sample_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RegulationsAvgAggregateInputType = {
    id?: true
    product_id?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    marking_sample_id?: true
  }

  export type RegulationsSumAggregateInputType = {
    id?: true
    product_id?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    marking_sample_id?: true
  }

  export type RegulationsMinAggregateInputType = {
    id?: true
    product_id?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    gasket?: true
    seal?: true
    technician_note?: true
    packaging_note?: true
    marking_sample_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegulationsMaxAggregateInputType = {
    id?: true
    product_id?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    gasket?: true
    seal?: true
    technician_note?: true
    packaging_note?: true
    marking_sample_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RegulationsCountAggregateInputType = {
    id?: true
    product_id?: true
    water_base_min_weight?: true
    water_base_max_weight?: true
    per_box?: true
    box_per_row?: true
    row_on_pallet?: true
    gasket?: true
    seal?: true
    technician_note?: true
    packaging_note?: true
    marking_sample_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RegulationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which regulations to aggregate.
     */
    where?: regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regulations to fetch.
     */
    orderBy?: regulationsOrderByWithRelationInput | regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned regulations
    **/
    _count?: true | RegulationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegulationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegulationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegulationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegulationsMaxAggregateInputType
  }

  export type GetRegulationsAggregateType<T extends RegulationsAggregateArgs> = {
        [P in keyof T & keyof AggregateRegulations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegulations[P]>
      : GetScalarType<T[P], AggregateRegulations[P]>
  }




  export type regulationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: regulationsWhereInput
    orderBy?: regulationsOrderByWithAggregationInput | regulationsOrderByWithAggregationInput[]
    by: RegulationsScalarFieldEnum[] | RegulationsScalarFieldEnum
    having?: regulationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegulationsCountAggregateInputType | true
    _avg?: RegulationsAvgAggregateInputType
    _sum?: RegulationsSumAggregateInputType
    _min?: RegulationsMinAggregateInputType
    _max?: RegulationsMaxAggregateInputType
  }

  export type RegulationsGroupByOutputType = {
    id: number
    product_id: number | null
    water_base_min_weight: Decimal | null
    water_base_max_weight: Decimal | null
    per_box: number | null
    box_per_row: number | null
    row_on_pallet: number | null
    gasket: string | null
    seal: boolean | null
    technician_note: string | null
    packaging_note: string | null
    marking_sample_id: number | null
    createdAt: Date
    updatedAt: Date
    _count: RegulationsCountAggregateOutputType | null
    _avg: RegulationsAvgAggregateOutputType | null
    _sum: RegulationsSumAggregateOutputType | null
    _min: RegulationsMinAggregateOutputType | null
    _max: RegulationsMaxAggregateOutputType | null
  }

  type GetRegulationsGroupByPayload<T extends regulationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegulationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegulationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegulationsGroupByOutputType[P]>
            : GetScalarType<T[P], RegulationsGroupByOutputType[P]>
        }
      >
    >


  export type regulationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_id?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marking_sample?: boolean | regulations$marking_sampleArgs<ExtArgs>
    products?: boolean | regulations$productsArgs<ExtArgs>
  }, ExtArgs["result"]["regulations"]>

  export type regulationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_id?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marking_sample?: boolean | regulations$marking_sampleArgs<ExtArgs>
    products?: boolean | regulations$productsArgs<ExtArgs>
  }, ExtArgs["result"]["regulations"]>

  export type regulationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    product_id?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    marking_sample?: boolean | regulations$marking_sampleArgs<ExtArgs>
    products?: boolean | regulations$productsArgs<ExtArgs>
  }, ExtArgs["result"]["regulations"]>

  export type regulationsSelectScalar = {
    id?: boolean
    product_id?: boolean
    water_base_min_weight?: boolean
    water_base_max_weight?: boolean
    per_box?: boolean
    box_per_row?: boolean
    row_on_pallet?: boolean
    gasket?: boolean
    seal?: boolean
    technician_note?: boolean
    packaging_note?: boolean
    marking_sample_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type regulationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "product_id" | "water_base_min_weight" | "water_base_max_weight" | "per_box" | "box_per_row" | "row_on_pallet" | "gasket" | "seal" | "technician_note" | "packaging_note" | "marking_sample_id" | "createdAt" | "updatedAt", ExtArgs["result"]["regulations"]>
  export type regulationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marking_sample?: boolean | regulations$marking_sampleArgs<ExtArgs>
    products?: boolean | regulations$productsArgs<ExtArgs>
  }
  export type regulationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marking_sample?: boolean | regulations$marking_sampleArgs<ExtArgs>
    products?: boolean | regulations$productsArgs<ExtArgs>
  }
  export type regulationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    marking_sample?: boolean | regulations$marking_sampleArgs<ExtArgs>
    products?: boolean | regulations$productsArgs<ExtArgs>
  }

  export type $regulationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "regulations"
    objects: {
      marking_sample: Prisma.$marking_samplePayload<ExtArgs> | null
      products: Prisma.$productsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      product_id: number | null
      water_base_min_weight: Prisma.Decimal | null
      water_base_max_weight: Prisma.Decimal | null
      per_box: number | null
      box_per_row: number | null
      row_on_pallet: number | null
      gasket: string | null
      seal: boolean | null
      technician_note: string | null
      packaging_note: string | null
      marking_sample_id: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["regulations"]>
    composites: {}
  }

  type regulationsGetPayload<S extends boolean | null | undefined | regulationsDefaultArgs> = $Result.GetResult<Prisma.$regulationsPayload, S>

  type regulationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<regulationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RegulationsCountAggregateInputType | true
    }

  export interface regulationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['regulations'], meta: { name: 'regulations' } }
    /**
     * Find zero or one Regulations that matches the filter.
     * @param {regulationsFindUniqueArgs} args - Arguments to find a Regulations
     * @example
     * // Get one Regulations
     * const regulations = await prisma.regulations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends regulationsFindUniqueArgs>(args: SelectSubset<T, regulationsFindUniqueArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Regulations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {regulationsFindUniqueOrThrowArgs} args - Arguments to find a Regulations
     * @example
     * // Get one Regulations
     * const regulations = await prisma.regulations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends regulationsFindUniqueOrThrowArgs>(args: SelectSubset<T, regulationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regulationsFindFirstArgs} args - Arguments to find a Regulations
     * @example
     * // Get one Regulations
     * const regulations = await prisma.regulations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends regulationsFindFirstArgs>(args?: SelectSubset<T, regulationsFindFirstArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Regulations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regulationsFindFirstOrThrowArgs} args - Arguments to find a Regulations
     * @example
     * // Get one Regulations
     * const regulations = await prisma.regulations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends regulationsFindFirstOrThrowArgs>(args?: SelectSubset<T, regulationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Regulations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regulationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regulations
     * const regulations = await prisma.regulations.findMany()
     * 
     * // Get first 10 Regulations
     * const regulations = await prisma.regulations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regulationsWithIdOnly = await prisma.regulations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends regulationsFindManyArgs>(args?: SelectSubset<T, regulationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Regulations.
     * @param {regulationsCreateArgs} args - Arguments to create a Regulations.
     * @example
     * // Create one Regulations
     * const Regulations = await prisma.regulations.create({
     *   data: {
     *     // ... data to create a Regulations
     *   }
     * })
     * 
     */
    create<T extends regulationsCreateArgs>(args: SelectSubset<T, regulationsCreateArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Regulations.
     * @param {regulationsCreateManyArgs} args - Arguments to create many Regulations.
     * @example
     * // Create many Regulations
     * const regulations = await prisma.regulations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends regulationsCreateManyArgs>(args?: SelectSubset<T, regulationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Regulations and returns the data saved in the database.
     * @param {regulationsCreateManyAndReturnArgs} args - Arguments to create many Regulations.
     * @example
     * // Create many Regulations
     * const regulations = await prisma.regulations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Regulations and only return the `id`
     * const regulationsWithIdOnly = await prisma.regulations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends regulationsCreateManyAndReturnArgs>(args?: SelectSubset<T, regulationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Regulations.
     * @param {regulationsDeleteArgs} args - Arguments to delete one Regulations.
     * @example
     * // Delete one Regulations
     * const Regulations = await prisma.regulations.delete({
     *   where: {
     *     // ... filter to delete one Regulations
     *   }
     * })
     * 
     */
    delete<T extends regulationsDeleteArgs>(args: SelectSubset<T, regulationsDeleteArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Regulations.
     * @param {regulationsUpdateArgs} args - Arguments to update one Regulations.
     * @example
     * // Update one Regulations
     * const regulations = await prisma.regulations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends regulationsUpdateArgs>(args: SelectSubset<T, regulationsUpdateArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Regulations.
     * @param {regulationsDeleteManyArgs} args - Arguments to filter Regulations to delete.
     * @example
     * // Delete a few Regulations
     * const { count } = await prisma.regulations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends regulationsDeleteManyArgs>(args?: SelectSubset<T, regulationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regulationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regulations
     * const regulations = await prisma.regulations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends regulationsUpdateManyArgs>(args: SelectSubset<T, regulationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regulations and returns the data updated in the database.
     * @param {regulationsUpdateManyAndReturnArgs} args - Arguments to update many Regulations.
     * @example
     * // Update many Regulations
     * const regulations = await prisma.regulations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Regulations and only return the `id`
     * const regulationsWithIdOnly = await prisma.regulations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends regulationsUpdateManyAndReturnArgs>(args: SelectSubset<T, regulationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Regulations.
     * @param {regulationsUpsertArgs} args - Arguments to update or create a Regulations.
     * @example
     * // Update or create a Regulations
     * const regulations = await prisma.regulations.upsert({
     *   create: {
     *     // ... data to create a Regulations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regulations we want to update
     *   }
     * })
     */
    upsert<T extends regulationsUpsertArgs>(args: SelectSubset<T, regulationsUpsertArgs<ExtArgs>>): Prisma__regulationsClient<$Result.GetResult<Prisma.$regulationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regulationsCountArgs} args - Arguments to filter Regulations to count.
     * @example
     * // Count the number of Regulations
     * const count = await prisma.regulations.count({
     *   where: {
     *     // ... the filter for the Regulations we want to count
     *   }
     * })
    **/
    count<T extends regulationsCountArgs>(
      args?: Subset<T, regulationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegulationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegulationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegulationsAggregateArgs>(args: Subset<T, RegulationsAggregateArgs>): Prisma.PrismaPromise<GetRegulationsAggregateType<T>>

    /**
     * Group by Regulations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {regulationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends regulationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: regulationsGroupByArgs['orderBy'] }
        : { orderBy?: regulationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, regulationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegulationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the regulations model
   */
  readonly fields: regulationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for regulations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__regulationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    marking_sample<T extends regulations$marking_sampleArgs<ExtArgs> = {}>(args?: Subset<T, regulations$marking_sampleArgs<ExtArgs>>): Prisma__marking_sampleClient<$Result.GetResult<Prisma.$marking_samplePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends regulations$productsArgs<ExtArgs> = {}>(args?: Subset<T, regulations$productsArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the regulations model
   */
  interface regulationsFieldRefs {
    readonly id: FieldRef<"regulations", 'Int'>
    readonly product_id: FieldRef<"regulations", 'Int'>
    readonly water_base_min_weight: FieldRef<"regulations", 'Decimal'>
    readonly water_base_max_weight: FieldRef<"regulations", 'Decimal'>
    readonly per_box: FieldRef<"regulations", 'Int'>
    readonly box_per_row: FieldRef<"regulations", 'Int'>
    readonly row_on_pallet: FieldRef<"regulations", 'Int'>
    readonly gasket: FieldRef<"regulations", 'String'>
    readonly seal: FieldRef<"regulations", 'Boolean'>
    readonly technician_note: FieldRef<"regulations", 'String'>
    readonly packaging_note: FieldRef<"regulations", 'String'>
    readonly marking_sample_id: FieldRef<"regulations", 'Int'>
    readonly createdAt: FieldRef<"regulations", 'DateTime'>
    readonly updatedAt: FieldRef<"regulations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * regulations findUnique
   */
  export type regulationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * Filter, which regulations to fetch.
     */
    where: regulationsWhereUniqueInput
  }

  /**
   * regulations findUniqueOrThrow
   */
  export type regulationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * Filter, which regulations to fetch.
     */
    where: regulationsWhereUniqueInput
  }

  /**
   * regulations findFirst
   */
  export type regulationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * Filter, which regulations to fetch.
     */
    where?: regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regulations to fetch.
     */
    orderBy?: regulationsOrderByWithRelationInput | regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regulations.
     */
    cursor?: regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regulations.
     */
    distinct?: RegulationsScalarFieldEnum | RegulationsScalarFieldEnum[]
  }

  /**
   * regulations findFirstOrThrow
   */
  export type regulationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * Filter, which regulations to fetch.
     */
    where?: regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regulations to fetch.
     */
    orderBy?: regulationsOrderByWithRelationInput | regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for regulations.
     */
    cursor?: regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regulations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of regulations.
     */
    distinct?: RegulationsScalarFieldEnum | RegulationsScalarFieldEnum[]
  }

  /**
   * regulations findMany
   */
  export type regulationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * Filter, which regulations to fetch.
     */
    where?: regulationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of regulations to fetch.
     */
    orderBy?: regulationsOrderByWithRelationInput | regulationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing regulations.
     */
    cursor?: regulationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` regulations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` regulations.
     */
    skip?: number
    distinct?: RegulationsScalarFieldEnum | RegulationsScalarFieldEnum[]
  }

  /**
   * regulations create
   */
  export type regulationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * The data needed to create a regulations.
     */
    data: XOR<regulationsCreateInput, regulationsUncheckedCreateInput>
  }

  /**
   * regulations createMany
   */
  export type regulationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many regulations.
     */
    data: regulationsCreateManyInput | regulationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * regulations createManyAndReturn
   */
  export type regulationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * The data used to create many regulations.
     */
    data: regulationsCreateManyInput | regulationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * regulations update
   */
  export type regulationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * The data needed to update a regulations.
     */
    data: XOR<regulationsUpdateInput, regulationsUncheckedUpdateInput>
    /**
     * Choose, which regulations to update.
     */
    where: regulationsWhereUniqueInput
  }

  /**
   * regulations updateMany
   */
  export type regulationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update regulations.
     */
    data: XOR<regulationsUpdateManyMutationInput, regulationsUncheckedUpdateManyInput>
    /**
     * Filter which regulations to update
     */
    where?: regulationsWhereInput
    /**
     * Limit how many regulations to update.
     */
    limit?: number
  }

  /**
   * regulations updateManyAndReturn
   */
  export type regulationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * The data used to update regulations.
     */
    data: XOR<regulationsUpdateManyMutationInput, regulationsUncheckedUpdateManyInput>
    /**
     * Filter which regulations to update
     */
    where?: regulationsWhereInput
    /**
     * Limit how many regulations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * regulations upsert
   */
  export type regulationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * The filter to search for the regulations to update in case it exists.
     */
    where: regulationsWhereUniqueInput
    /**
     * In case the regulations found by the `where` argument doesn't exist, create a new regulations with this data.
     */
    create: XOR<regulationsCreateInput, regulationsUncheckedCreateInput>
    /**
     * In case the regulations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<regulationsUpdateInput, regulationsUncheckedUpdateInput>
  }

  /**
   * regulations delete
   */
  export type regulationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
    /**
     * Filter which regulations to delete.
     */
    where: regulationsWhereUniqueInput
  }

  /**
   * regulations deleteMany
   */
  export type regulationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which regulations to delete
     */
    where?: regulationsWhereInput
    /**
     * Limit how many regulations to delete.
     */
    limit?: number
  }

  /**
   * regulations.marking_sample
   */
  export type regulations$marking_sampleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the marking_sample
     */
    select?: marking_sampleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the marking_sample
     */
    omit?: marking_sampleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: marking_sampleInclude<ExtArgs> | null
    where?: marking_sampleWhereInput
  }

  /**
   * regulations.products
   */
  export type regulations$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * regulations without action
   */
  export type regulationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the regulations
     */
    select?: regulationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the regulations
     */
    omit?: regulationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: regulationsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    value: number
    description: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    value?: true
    description?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    value: string
    description: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    value?: boolean
    description?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "description", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user_roles?: boolean | roles$user_rolesArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      description: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {rolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user_roles<T extends roles$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly value: FieldRef<"roles", 'String'>
    readonly description: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles updateManyAndReturn
   */
  export type rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.user_roles
   */
  export type roles$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model semi_products
   */

  export type AggregateSemi_products = {
    _count: Semi_productsCountAggregateOutputType | null
    _avg: Semi_productsAvgAggregateOutputType | null
    _sum: Semi_productsSumAggregateOutputType | null
    _min: Semi_productsMinAggregateOutputType | null
    _max: Semi_productsMaxAggregateOutputType | null
  }

  export type Semi_productsAvgAggregateOutputType = {
    id: number | null
    record_id: number | null
    product_id: number | null
    boil_id: number | null
  }

  export type Semi_productsSumAggregateOutputType = {
    id: number | null
    record_id: number | null
    product_id: number | null
    boil_id: number | null
  }

  export type Semi_productsMinAggregateOutputType = {
    id: number | null
    record_id: number | null
    product_id: number | null
    boil_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Semi_productsMaxAggregateOutputType = {
    id: number | null
    record_id: number | null
    product_id: number | null
    boil_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Semi_productsCountAggregateOutputType = {
    id: number
    record_id: number
    product_id: number
    boil_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Semi_productsAvgAggregateInputType = {
    id?: true
    record_id?: true
    product_id?: true
    boil_id?: true
  }

  export type Semi_productsSumAggregateInputType = {
    id?: true
    record_id?: true
    product_id?: true
    boil_id?: true
  }

  export type Semi_productsMinAggregateInputType = {
    id?: true
    record_id?: true
    product_id?: true
    boil_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Semi_productsMaxAggregateInputType = {
    id?: true
    record_id?: true
    product_id?: true
    boil_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Semi_productsCountAggregateInputType = {
    id?: true
    record_id?: true
    product_id?: true
    boil_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Semi_productsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which semi_products to aggregate.
     */
    where?: semi_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semi_products to fetch.
     */
    orderBy?: semi_productsOrderByWithRelationInput | semi_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: semi_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semi_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semi_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned semi_products
    **/
    _count?: true | Semi_productsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Semi_productsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Semi_productsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Semi_productsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Semi_productsMaxAggregateInputType
  }

  export type GetSemi_productsAggregateType<T extends Semi_productsAggregateArgs> = {
        [P in keyof T & keyof AggregateSemi_products]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSemi_products[P]>
      : GetScalarType<T[P], AggregateSemi_products[P]>
  }




  export type semi_productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: semi_productsWhereInput
    orderBy?: semi_productsOrderByWithAggregationInput | semi_productsOrderByWithAggregationInput[]
    by: Semi_productsScalarFieldEnum[] | Semi_productsScalarFieldEnum
    having?: semi_productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Semi_productsCountAggregateInputType | true
    _avg?: Semi_productsAvgAggregateInputType
    _sum?: Semi_productsSumAggregateInputType
    _min?: Semi_productsMinAggregateInputType
    _max?: Semi_productsMaxAggregateInputType
  }

  export type Semi_productsGroupByOutputType = {
    id: number
    record_id: number | null
    product_id: number | null
    boil_id: number | null
    createdAt: Date
    updatedAt: Date
    _count: Semi_productsCountAggregateOutputType | null
    _avg: Semi_productsAvgAggregateOutputType | null
    _sum: Semi_productsSumAggregateOutputType | null
    _min: Semi_productsMinAggregateOutputType | null
    _max: Semi_productsMaxAggregateOutputType | null
  }

  type GetSemi_productsGroupByPayload<T extends semi_productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Semi_productsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Semi_productsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Semi_productsGroupByOutputType[P]>
            : GetScalarType<T[P], Semi_productsGroupByOutputType[P]>
        }
      >
    >


  export type semi_productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    product_id?: boolean
    boil_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boils?: boolean | semi_products$boilsArgs<ExtArgs>
    products?: boolean | semi_products$productsArgs<ExtArgs>
    records?: boolean | semi_products$recordsArgs<ExtArgs>
  }, ExtArgs["result"]["semi_products"]>

  export type semi_productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    product_id?: boolean
    boil_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boils?: boolean | semi_products$boilsArgs<ExtArgs>
    products?: boolean | semi_products$productsArgs<ExtArgs>
    records?: boolean | semi_products$recordsArgs<ExtArgs>
  }, ExtArgs["result"]["semi_products"]>

  export type semi_productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    record_id?: boolean
    product_id?: boolean
    boil_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boils?: boolean | semi_products$boilsArgs<ExtArgs>
    products?: boolean | semi_products$productsArgs<ExtArgs>
    records?: boolean | semi_products$recordsArgs<ExtArgs>
  }, ExtArgs["result"]["semi_products"]>

  export type semi_productsSelectScalar = {
    id?: boolean
    record_id?: boolean
    product_id?: boolean
    boil_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type semi_productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "record_id" | "product_id" | "boil_id" | "createdAt" | "updatedAt", ExtArgs["result"]["semi_products"]>
  export type semi_productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | semi_products$boilsArgs<ExtArgs>
    products?: boolean | semi_products$productsArgs<ExtArgs>
    records?: boolean | semi_products$recordsArgs<ExtArgs>
  }
  export type semi_productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | semi_products$boilsArgs<ExtArgs>
    products?: boolean | semi_products$productsArgs<ExtArgs>
    records?: boolean | semi_products$recordsArgs<ExtArgs>
  }
  export type semi_productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | semi_products$boilsArgs<ExtArgs>
    products?: boolean | semi_products$productsArgs<ExtArgs>
    records?: boolean | semi_products$recordsArgs<ExtArgs>
  }

  export type $semi_productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "semi_products"
    objects: {
      boils: Prisma.$boilsPayload<ExtArgs> | null
      products: Prisma.$productsPayload<ExtArgs> | null
      records: Prisma.$recordsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      record_id: number | null
      product_id: number | null
      boil_id: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["semi_products"]>
    composites: {}
  }

  type semi_productsGetPayload<S extends boolean | null | undefined | semi_productsDefaultArgs> = $Result.GetResult<Prisma.$semi_productsPayload, S>

  type semi_productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<semi_productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Semi_productsCountAggregateInputType | true
    }

  export interface semi_productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['semi_products'], meta: { name: 'semi_products' } }
    /**
     * Find zero or one Semi_products that matches the filter.
     * @param {semi_productsFindUniqueArgs} args - Arguments to find a Semi_products
     * @example
     * // Get one Semi_products
     * const semi_products = await prisma.semi_products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends semi_productsFindUniqueArgs>(args: SelectSubset<T, semi_productsFindUniqueArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Semi_products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {semi_productsFindUniqueOrThrowArgs} args - Arguments to find a Semi_products
     * @example
     * // Get one Semi_products
     * const semi_products = await prisma.semi_products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends semi_productsFindUniqueOrThrowArgs>(args: SelectSubset<T, semi_productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semi_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semi_productsFindFirstArgs} args - Arguments to find a Semi_products
     * @example
     * // Get one Semi_products
     * const semi_products = await prisma.semi_products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends semi_productsFindFirstArgs>(args?: SelectSubset<T, semi_productsFindFirstArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Semi_products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semi_productsFindFirstOrThrowArgs} args - Arguments to find a Semi_products
     * @example
     * // Get one Semi_products
     * const semi_products = await prisma.semi_products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends semi_productsFindFirstOrThrowArgs>(args?: SelectSubset<T, semi_productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Semi_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semi_productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Semi_products
     * const semi_products = await prisma.semi_products.findMany()
     * 
     * // Get first 10 Semi_products
     * const semi_products = await prisma.semi_products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const semi_productsWithIdOnly = await prisma.semi_products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends semi_productsFindManyArgs>(args?: SelectSubset<T, semi_productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Semi_products.
     * @param {semi_productsCreateArgs} args - Arguments to create a Semi_products.
     * @example
     * // Create one Semi_products
     * const Semi_products = await prisma.semi_products.create({
     *   data: {
     *     // ... data to create a Semi_products
     *   }
     * })
     * 
     */
    create<T extends semi_productsCreateArgs>(args: SelectSubset<T, semi_productsCreateArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Semi_products.
     * @param {semi_productsCreateManyArgs} args - Arguments to create many Semi_products.
     * @example
     * // Create many Semi_products
     * const semi_products = await prisma.semi_products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends semi_productsCreateManyArgs>(args?: SelectSubset<T, semi_productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Semi_products and returns the data saved in the database.
     * @param {semi_productsCreateManyAndReturnArgs} args - Arguments to create many Semi_products.
     * @example
     * // Create many Semi_products
     * const semi_products = await prisma.semi_products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Semi_products and only return the `id`
     * const semi_productsWithIdOnly = await prisma.semi_products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends semi_productsCreateManyAndReturnArgs>(args?: SelectSubset<T, semi_productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Semi_products.
     * @param {semi_productsDeleteArgs} args - Arguments to delete one Semi_products.
     * @example
     * // Delete one Semi_products
     * const Semi_products = await prisma.semi_products.delete({
     *   where: {
     *     // ... filter to delete one Semi_products
     *   }
     * })
     * 
     */
    delete<T extends semi_productsDeleteArgs>(args: SelectSubset<T, semi_productsDeleteArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Semi_products.
     * @param {semi_productsUpdateArgs} args - Arguments to update one Semi_products.
     * @example
     * // Update one Semi_products
     * const semi_products = await prisma.semi_products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends semi_productsUpdateArgs>(args: SelectSubset<T, semi_productsUpdateArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Semi_products.
     * @param {semi_productsDeleteManyArgs} args - Arguments to filter Semi_products to delete.
     * @example
     * // Delete a few Semi_products
     * const { count } = await prisma.semi_products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends semi_productsDeleteManyArgs>(args?: SelectSubset<T, semi_productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semi_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semi_productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Semi_products
     * const semi_products = await prisma.semi_products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends semi_productsUpdateManyArgs>(args: SelectSubset<T, semi_productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Semi_products and returns the data updated in the database.
     * @param {semi_productsUpdateManyAndReturnArgs} args - Arguments to update many Semi_products.
     * @example
     * // Update many Semi_products
     * const semi_products = await prisma.semi_products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Semi_products and only return the `id`
     * const semi_productsWithIdOnly = await prisma.semi_products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends semi_productsUpdateManyAndReturnArgs>(args: SelectSubset<T, semi_productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Semi_products.
     * @param {semi_productsUpsertArgs} args - Arguments to update or create a Semi_products.
     * @example
     * // Update or create a Semi_products
     * const semi_products = await prisma.semi_products.upsert({
     *   create: {
     *     // ... data to create a Semi_products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Semi_products we want to update
     *   }
     * })
     */
    upsert<T extends semi_productsUpsertArgs>(args: SelectSubset<T, semi_productsUpsertArgs<ExtArgs>>): Prisma__semi_productsClient<$Result.GetResult<Prisma.$semi_productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Semi_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semi_productsCountArgs} args - Arguments to filter Semi_products to count.
     * @example
     * // Count the number of Semi_products
     * const count = await prisma.semi_products.count({
     *   where: {
     *     // ... the filter for the Semi_products we want to count
     *   }
     * })
    **/
    count<T extends semi_productsCountArgs>(
      args?: Subset<T, semi_productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Semi_productsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Semi_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Semi_productsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Semi_productsAggregateArgs>(args: Subset<T, Semi_productsAggregateArgs>): Prisma.PrismaPromise<GetSemi_productsAggregateType<T>>

    /**
     * Group by Semi_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {semi_productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends semi_productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: semi_productsGroupByArgs['orderBy'] }
        : { orderBy?: semi_productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, semi_productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSemi_productsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the semi_products model
   */
  readonly fields: semi_productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for semi_products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__semi_productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boils<T extends semi_products$boilsArgs<ExtArgs> = {}>(args?: Subset<T, semi_products$boilsArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    products<T extends semi_products$productsArgs<ExtArgs> = {}>(args?: Subset<T, semi_products$productsArgs<ExtArgs>>): Prisma__productsClient<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    records<T extends semi_products$recordsArgs<ExtArgs> = {}>(args?: Subset<T, semi_products$recordsArgs<ExtArgs>>): Prisma__recordsClient<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the semi_products model
   */
  interface semi_productsFieldRefs {
    readonly id: FieldRef<"semi_products", 'Int'>
    readonly record_id: FieldRef<"semi_products", 'Int'>
    readonly product_id: FieldRef<"semi_products", 'Int'>
    readonly boil_id: FieldRef<"semi_products", 'Int'>
    readonly createdAt: FieldRef<"semi_products", 'DateTime'>
    readonly updatedAt: FieldRef<"semi_products", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * semi_products findUnique
   */
  export type semi_productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * Filter, which semi_products to fetch.
     */
    where: semi_productsWhereUniqueInput
  }

  /**
   * semi_products findUniqueOrThrow
   */
  export type semi_productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * Filter, which semi_products to fetch.
     */
    where: semi_productsWhereUniqueInput
  }

  /**
   * semi_products findFirst
   */
  export type semi_productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * Filter, which semi_products to fetch.
     */
    where?: semi_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semi_products to fetch.
     */
    orderBy?: semi_productsOrderByWithRelationInput | semi_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for semi_products.
     */
    cursor?: semi_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semi_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semi_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of semi_products.
     */
    distinct?: Semi_productsScalarFieldEnum | Semi_productsScalarFieldEnum[]
  }

  /**
   * semi_products findFirstOrThrow
   */
  export type semi_productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * Filter, which semi_products to fetch.
     */
    where?: semi_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semi_products to fetch.
     */
    orderBy?: semi_productsOrderByWithRelationInput | semi_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for semi_products.
     */
    cursor?: semi_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semi_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semi_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of semi_products.
     */
    distinct?: Semi_productsScalarFieldEnum | Semi_productsScalarFieldEnum[]
  }

  /**
   * semi_products findMany
   */
  export type semi_productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * Filter, which semi_products to fetch.
     */
    where?: semi_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of semi_products to fetch.
     */
    orderBy?: semi_productsOrderByWithRelationInput | semi_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing semi_products.
     */
    cursor?: semi_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` semi_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` semi_products.
     */
    skip?: number
    distinct?: Semi_productsScalarFieldEnum | Semi_productsScalarFieldEnum[]
  }

  /**
   * semi_products create
   */
  export type semi_productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * The data needed to create a semi_products.
     */
    data: XOR<semi_productsCreateInput, semi_productsUncheckedCreateInput>
  }

  /**
   * semi_products createMany
   */
  export type semi_productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many semi_products.
     */
    data: semi_productsCreateManyInput | semi_productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * semi_products createManyAndReturn
   */
  export type semi_productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * The data used to create many semi_products.
     */
    data: semi_productsCreateManyInput | semi_productsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * semi_products update
   */
  export type semi_productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * The data needed to update a semi_products.
     */
    data: XOR<semi_productsUpdateInput, semi_productsUncheckedUpdateInput>
    /**
     * Choose, which semi_products to update.
     */
    where: semi_productsWhereUniqueInput
  }

  /**
   * semi_products updateMany
   */
  export type semi_productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update semi_products.
     */
    data: XOR<semi_productsUpdateManyMutationInput, semi_productsUncheckedUpdateManyInput>
    /**
     * Filter which semi_products to update
     */
    where?: semi_productsWhereInput
    /**
     * Limit how many semi_products to update.
     */
    limit?: number
  }

  /**
   * semi_products updateManyAndReturn
   */
  export type semi_productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * The data used to update semi_products.
     */
    data: XOR<semi_productsUpdateManyMutationInput, semi_productsUncheckedUpdateManyInput>
    /**
     * Filter which semi_products to update
     */
    where?: semi_productsWhereInput
    /**
     * Limit how many semi_products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * semi_products upsert
   */
  export type semi_productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * The filter to search for the semi_products to update in case it exists.
     */
    where: semi_productsWhereUniqueInput
    /**
     * In case the semi_products found by the `where` argument doesn't exist, create a new semi_products with this data.
     */
    create: XOR<semi_productsCreateInput, semi_productsUncheckedCreateInput>
    /**
     * In case the semi_products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<semi_productsUpdateInput, semi_productsUncheckedUpdateInput>
  }

  /**
   * semi_products delete
   */
  export type semi_productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
    /**
     * Filter which semi_products to delete.
     */
    where: semi_productsWhereUniqueInput
  }

  /**
   * semi_products deleteMany
   */
  export type semi_productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which semi_products to delete
     */
    where?: semi_productsWhereInput
    /**
     * Limit how many semi_products to delete.
     */
    limit?: number
  }

  /**
   * semi_products.boils
   */
  export type semi_products$boilsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    where?: boilsWhereInput
  }

  /**
   * semi_products.products
   */
  export type semi_products$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
  }

  /**
   * semi_products.records
   */
  export type semi_products$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
  }

  /**
   * semi_products without action
   */
  export type semi_productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the semi_products
     */
    select?: semi_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the semi_products
     */
    omit?: semi_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: semi_productsInclude<ExtArgs> | null
  }


  /**
   * Model series
   */

  export type AggregateSeries = {
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  export type SeriesAvgAggregateOutputType = {
    id: number | null
  }

  export type SeriesSumAggregateOutputType = {
    id: number | null
  }

  export type SeriesMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type SeriesMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type SeriesCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type SeriesAvgAggregateInputType = {
    id?: true
  }

  export type SeriesSumAggregateInputType = {
    id?: true
  }

  export type SeriesMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type SeriesMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type SeriesCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type SeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which series to aggregate.
     */
    where?: seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of series to fetch.
     */
    orderBy?: seriesOrderByWithRelationInput | seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned series
    **/
    _count?: true | SeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesMaxAggregateInputType
  }

  export type GetSeriesAggregateType<T extends SeriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeries[P]>
      : GetScalarType<T[P], AggregateSeries[P]>
  }




  export type seriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: seriesWhereInput
    orderBy?: seriesOrderByWithAggregationInput | seriesOrderByWithAggregationInput[]
    by: SeriesScalarFieldEnum[] | SeriesScalarFieldEnum
    having?: seriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesCountAggregateInputType | true
    _avg?: SeriesAvgAggregateInputType
    _sum?: SeriesSumAggregateInputType
    _min?: SeriesMinAggregateInputType
    _max?: SeriesMaxAggregateInputType
  }

  export type SeriesGroupByOutputType = {
    id: number
    value: string
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  type GetSeriesGroupByPayload<T extends seriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesGroupByOutputType[P]>
        }
      >
    >


  export type seriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    products?: boolean | series$productsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type seriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["series"]>

  export type seriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["series"]>

  export type seriesSelectScalar = {
    id?: boolean
    value?: boolean
  }

  export type seriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value", ExtArgs["result"]["series"]>
  export type seriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | series$productsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type seriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type seriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $seriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "series"
    objects: {
      products: Prisma.$productsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
    }, ExtArgs["result"]["series"]>
    composites: {}
  }

  type seriesGetPayload<S extends boolean | null | undefined | seriesDefaultArgs> = $Result.GetResult<Prisma.$seriesPayload, S>

  type seriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<seriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesCountAggregateInputType | true
    }

  export interface seriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['series'], meta: { name: 'series' } }
    /**
     * Find zero or one Series that matches the filter.
     * @param {seriesFindUniqueArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends seriesFindUniqueArgs>(args: SelectSubset<T, seriesFindUniqueArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {seriesFindUniqueOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends seriesFindUniqueOrThrowArgs>(args: SelectSubset<T, seriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seriesFindFirstArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends seriesFindFirstArgs>(args?: SelectSubset<T, seriesFindFirstArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seriesFindFirstOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends seriesFindFirstOrThrowArgs>(args?: SelectSubset<T, seriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Series
     * const series = await prisma.series.findMany()
     * 
     * // Get first 10 Series
     * const series = await prisma.series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seriesWithIdOnly = await prisma.series.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends seriesFindManyArgs>(args?: SelectSubset<T, seriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Series.
     * @param {seriesCreateArgs} args - Arguments to create a Series.
     * @example
     * // Create one Series
     * const Series = await prisma.series.create({
     *   data: {
     *     // ... data to create a Series
     *   }
     * })
     * 
     */
    create<T extends seriesCreateArgs>(args: SelectSubset<T, seriesCreateArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Series.
     * @param {seriesCreateManyArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends seriesCreateManyArgs>(args?: SelectSubset<T, seriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Series and returns the data saved in the database.
     * @param {seriesCreateManyAndReturnArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends seriesCreateManyAndReturnArgs>(args?: SelectSubset<T, seriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Series.
     * @param {seriesDeleteArgs} args - Arguments to delete one Series.
     * @example
     * // Delete one Series
     * const Series = await prisma.series.delete({
     *   where: {
     *     // ... filter to delete one Series
     *   }
     * })
     * 
     */
    delete<T extends seriesDeleteArgs>(args: SelectSubset<T, seriesDeleteArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Series.
     * @param {seriesUpdateArgs} args - Arguments to update one Series.
     * @example
     * // Update one Series
     * const series = await prisma.series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends seriesUpdateArgs>(args: SelectSubset<T, seriesUpdateArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Series.
     * @param {seriesDeleteManyArgs} args - Arguments to filter Series to delete.
     * @example
     * // Delete a few Series
     * const { count } = await prisma.series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends seriesDeleteManyArgs>(args?: SelectSubset<T, seriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends seriesUpdateManyArgs>(args: SelectSubset<T, seriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series and returns the data updated in the database.
     * @param {seriesUpdateManyAndReturnArgs} args - Arguments to update many Series.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends seriesUpdateManyAndReturnArgs>(args: SelectSubset<T, seriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Series.
     * @param {seriesUpsertArgs} args - Arguments to update or create a Series.
     * @example
     * // Update or create a Series
     * const series = await prisma.series.upsert({
     *   create: {
     *     // ... data to create a Series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Series we want to update
     *   }
     * })
     */
    upsert<T extends seriesUpsertArgs>(args: SelectSubset<T, seriesUpsertArgs<ExtArgs>>): Prisma__seriesClient<$Result.GetResult<Prisma.$seriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seriesCountArgs} args - Arguments to filter Series to count.
     * @example
     * // Count the number of Series
     * const count = await prisma.series.count({
     *   where: {
     *     // ... the filter for the Series we want to count
     *   }
     * })
    **/
    count<T extends seriesCountArgs>(
      args?: Subset<T, seriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesAggregateArgs>(args: Subset<T, SeriesAggregateArgs>): Prisma.PrismaPromise<GetSeriesAggregateType<T>>

    /**
     * Group by Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends seriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: seriesGroupByArgs['orderBy'] }
        : { orderBy?: seriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, seriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the series model
   */
  readonly fields: seriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__seriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends series$productsArgs<ExtArgs> = {}>(args?: Subset<T, series$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the series model
   */
  interface seriesFieldRefs {
    readonly id: FieldRef<"series", 'Int'>
    readonly value: FieldRef<"series", 'String'>
  }
    

  // Custom InputTypes
  /**
   * series findUnique
   */
  export type seriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * Filter, which series to fetch.
     */
    where: seriesWhereUniqueInput
  }

  /**
   * series findUniqueOrThrow
   */
  export type seriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * Filter, which series to fetch.
     */
    where: seriesWhereUniqueInput
  }

  /**
   * series findFirst
   */
  export type seriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * Filter, which series to fetch.
     */
    where?: seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of series to fetch.
     */
    orderBy?: seriesOrderByWithRelationInput | seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for series.
     */
    cursor?: seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * series findFirstOrThrow
   */
  export type seriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * Filter, which series to fetch.
     */
    where?: seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of series to fetch.
     */
    orderBy?: seriesOrderByWithRelationInput | seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for series.
     */
    cursor?: seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * series findMany
   */
  export type seriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * Filter, which series to fetch.
     */
    where?: seriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of series to fetch.
     */
    orderBy?: seriesOrderByWithRelationInput | seriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing series.
     */
    cursor?: seriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` series.
     */
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * series create
   */
  export type seriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * The data needed to create a series.
     */
    data: XOR<seriesCreateInput, seriesUncheckedCreateInput>
  }

  /**
   * series createMany
   */
  export type seriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many series.
     */
    data: seriesCreateManyInput | seriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * series createManyAndReturn
   */
  export type seriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * The data used to create many series.
     */
    data: seriesCreateManyInput | seriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * series update
   */
  export type seriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * The data needed to update a series.
     */
    data: XOR<seriesUpdateInput, seriesUncheckedUpdateInput>
    /**
     * Choose, which series to update.
     */
    where: seriesWhereUniqueInput
  }

  /**
   * series updateMany
   */
  export type seriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update series.
     */
    data: XOR<seriesUpdateManyMutationInput, seriesUncheckedUpdateManyInput>
    /**
     * Filter which series to update
     */
    where?: seriesWhereInput
    /**
     * Limit how many series to update.
     */
    limit?: number
  }

  /**
   * series updateManyAndReturn
   */
  export type seriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * The data used to update series.
     */
    data: XOR<seriesUpdateManyMutationInput, seriesUncheckedUpdateManyInput>
    /**
     * Filter which series to update
     */
    where?: seriesWhereInput
    /**
     * Limit how many series to update.
     */
    limit?: number
  }

  /**
   * series upsert
   */
  export type seriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * The filter to search for the series to update in case it exists.
     */
    where: seriesWhereUniqueInput
    /**
     * In case the series found by the `where` argument doesn't exist, create a new series with this data.
     */
    create: XOR<seriesCreateInput, seriesUncheckedCreateInput>
    /**
     * In case the series was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seriesUpdateInput, seriesUncheckedUpdateInput>
  }

  /**
   * series delete
   */
  export type seriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
    /**
     * Filter which series to delete.
     */
    where: seriesWhereUniqueInput
  }

  /**
   * series deleteMany
   */
  export type seriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which series to delete
     */
    where?: seriesWhereInput
    /**
     * Limit how many series to delete.
     */
    limit?: number
  }

  /**
   * series.products
   */
  export type series$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the products
     */
    select?: productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the products
     */
    omit?: productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: productsInclude<ExtArgs> | null
    where?: productsWhereInput
    orderBy?: productsOrderByWithRelationInput | productsOrderByWithRelationInput[]
    cursor?: productsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductsScalarFieldEnum | ProductsScalarFieldEnum[]
  }

  /**
   * series without action
   */
  export type seriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the series
     */
    select?: seriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the series
     */
    omit?: seriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: seriesInclude<ExtArgs> | null
  }


  /**
   * Model signals
   */

  export type AggregateSignals = {
    _count: SignalsCountAggregateOutputType | null
    _avg: SignalsAvgAggregateOutputType | null
    _sum: SignalsSumAggregateOutputType | null
    _min: SignalsMinAggregateOutputType | null
    _max: SignalsMaxAggregateOutputType | null
  }

  export type SignalsAvgAggregateOutputType = {
    id: number | null
  }

  export type SignalsSumAggregateOutputType = {
    id: number | null
  }

  export type SignalsMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type SignalsMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type SignalsCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type SignalsAvgAggregateInputType = {
    id?: true
  }

  export type SignalsSumAggregateInputType = {
    id?: true
  }

  export type SignalsMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type SignalsMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type SignalsCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type SignalsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which signals to aggregate.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned signals
    **/
    _count?: true | SignalsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SignalsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SignalsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SignalsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SignalsMaxAggregateInputType
  }

  export type GetSignalsAggregateType<T extends SignalsAggregateArgs> = {
        [P in keyof T & keyof AggregateSignals]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSignals[P]>
      : GetScalarType<T[P], AggregateSignals[P]>
  }




  export type signalsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: signalsWhereInput
    orderBy?: signalsOrderByWithAggregationInput | signalsOrderByWithAggregationInput[]
    by: SignalsScalarFieldEnum[] | SignalsScalarFieldEnum
    having?: signalsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SignalsCountAggregateInputType | true
    _avg?: SignalsAvgAggregateInputType
    _sum?: SignalsSumAggregateInputType
    _min?: SignalsMinAggregateInputType
    _max?: SignalsMaxAggregateInputType
  }

  export type SignalsGroupByOutputType = {
    id: number
    value: string
    _count: SignalsCountAggregateOutputType | null
    _avg: SignalsAvgAggregateOutputType | null
    _sum: SignalsSumAggregateOutputType | null
    _min: SignalsMinAggregateOutputType | null
    _max: SignalsMaxAggregateOutputType | null
  }

  type GetSignalsGroupByPayload<T extends signalsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SignalsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SignalsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SignalsGroupByOutputType[P]>
            : GetScalarType<T[P], SignalsGroupByOutputType[P]>
        }
      >
    >


  export type signalsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["signals"]>

  export type signalsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["signals"]>

  export type signalsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["signals"]>

  export type signalsSelectScalar = {
    id?: boolean
    value?: boolean
  }

  export type signalsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value", ExtArgs["result"]["signals"]>

  export type $signalsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "signals"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
    }, ExtArgs["result"]["signals"]>
    composites: {}
  }

  type signalsGetPayload<S extends boolean | null | undefined | signalsDefaultArgs> = $Result.GetResult<Prisma.$signalsPayload, S>

  type signalsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<signalsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SignalsCountAggregateInputType | true
    }

  export interface signalsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['signals'], meta: { name: 'signals' } }
    /**
     * Find zero or one Signals that matches the filter.
     * @param {signalsFindUniqueArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends signalsFindUniqueArgs>(args: SelectSubset<T, signalsFindUniqueArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Signals that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {signalsFindUniqueOrThrowArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends signalsFindUniqueOrThrowArgs>(args: SelectSubset<T, signalsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsFindFirstArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends signalsFindFirstArgs>(args?: SelectSubset<T, signalsFindFirstArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Signals that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsFindFirstOrThrowArgs} args - Arguments to find a Signals
     * @example
     * // Get one Signals
     * const signals = await prisma.signals.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends signalsFindFirstOrThrowArgs>(args?: SelectSubset<T, signalsFindFirstOrThrowArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Signals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Signals
     * const signals = await prisma.signals.findMany()
     * 
     * // Get first 10 Signals
     * const signals = await prisma.signals.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const signalsWithIdOnly = await prisma.signals.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends signalsFindManyArgs>(args?: SelectSubset<T, signalsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Signals.
     * @param {signalsCreateArgs} args - Arguments to create a Signals.
     * @example
     * // Create one Signals
     * const Signals = await prisma.signals.create({
     *   data: {
     *     // ... data to create a Signals
     *   }
     * })
     * 
     */
    create<T extends signalsCreateArgs>(args: SelectSubset<T, signalsCreateArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Signals.
     * @param {signalsCreateManyArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signals = await prisma.signals.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends signalsCreateManyArgs>(args?: SelectSubset<T, signalsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Signals and returns the data saved in the database.
     * @param {signalsCreateManyAndReturnArgs} args - Arguments to create many Signals.
     * @example
     * // Create many Signals
     * const signals = await prisma.signals.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Signals and only return the `id`
     * const signalsWithIdOnly = await prisma.signals.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends signalsCreateManyAndReturnArgs>(args?: SelectSubset<T, signalsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Signals.
     * @param {signalsDeleteArgs} args - Arguments to delete one Signals.
     * @example
     * // Delete one Signals
     * const Signals = await prisma.signals.delete({
     *   where: {
     *     // ... filter to delete one Signals
     *   }
     * })
     * 
     */
    delete<T extends signalsDeleteArgs>(args: SelectSubset<T, signalsDeleteArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Signals.
     * @param {signalsUpdateArgs} args - Arguments to update one Signals.
     * @example
     * // Update one Signals
     * const signals = await prisma.signals.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends signalsUpdateArgs>(args: SelectSubset<T, signalsUpdateArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Signals.
     * @param {signalsDeleteManyArgs} args - Arguments to filter Signals to delete.
     * @example
     * // Delete a few Signals
     * const { count } = await prisma.signals.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends signalsDeleteManyArgs>(args?: SelectSubset<T, signalsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Signals
     * const signals = await prisma.signals.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends signalsUpdateManyArgs>(args: SelectSubset<T, signalsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Signals and returns the data updated in the database.
     * @param {signalsUpdateManyAndReturnArgs} args - Arguments to update many Signals.
     * @example
     * // Update many Signals
     * const signals = await prisma.signals.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Signals and only return the `id`
     * const signalsWithIdOnly = await prisma.signals.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends signalsUpdateManyAndReturnArgs>(args: SelectSubset<T, signalsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Signals.
     * @param {signalsUpsertArgs} args - Arguments to update or create a Signals.
     * @example
     * // Update or create a Signals
     * const signals = await prisma.signals.upsert({
     *   create: {
     *     // ... data to create a Signals
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Signals we want to update
     *   }
     * })
     */
    upsert<T extends signalsUpsertArgs>(args: SelectSubset<T, signalsUpsertArgs<ExtArgs>>): Prisma__signalsClient<$Result.GetResult<Prisma.$signalsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsCountArgs} args - Arguments to filter Signals to count.
     * @example
     * // Count the number of Signals
     * const count = await prisma.signals.count({
     *   where: {
     *     // ... the filter for the Signals we want to count
     *   }
     * })
    **/
    count<T extends signalsCountArgs>(
      args?: Subset<T, signalsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SignalsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SignalsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SignalsAggregateArgs>(args: Subset<T, SignalsAggregateArgs>): Prisma.PrismaPromise<GetSignalsAggregateType<T>>

    /**
     * Group by Signals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {signalsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends signalsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: signalsGroupByArgs['orderBy'] }
        : { orderBy?: signalsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, signalsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSignalsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the signals model
   */
  readonly fields: signalsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for signals.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__signalsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the signals model
   */
  interface signalsFieldRefs {
    readonly id: FieldRef<"signals", 'Int'>
    readonly value: FieldRef<"signals", 'String'>
  }
    

  // Custom InputTypes
  /**
   * signals findUnique
   */
  export type signalsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals findUniqueOrThrow
   */
  export type signalsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals findFirst
   */
  export type signalsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for signals.
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of signals.
     */
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * signals findFirstOrThrow
   */
  export type signalsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for signals.
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of signals.
     */
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * signals findMany
   */
  export type signalsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Filter, which signals to fetch.
     */
    where?: signalsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of signals to fetch.
     */
    orderBy?: signalsOrderByWithRelationInput | signalsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing signals.
     */
    cursor?: signalsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` signals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` signals.
     */
    skip?: number
    distinct?: SignalsScalarFieldEnum | SignalsScalarFieldEnum[]
  }

  /**
   * signals create
   */
  export type signalsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * The data needed to create a signals.
     */
    data: XOR<signalsCreateInput, signalsUncheckedCreateInput>
  }

  /**
   * signals createMany
   */
  export type signalsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many signals.
     */
    data: signalsCreateManyInput | signalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * signals createManyAndReturn
   */
  export type signalsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * The data used to create many signals.
     */
    data: signalsCreateManyInput | signalsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * signals update
   */
  export type signalsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * The data needed to update a signals.
     */
    data: XOR<signalsUpdateInput, signalsUncheckedUpdateInput>
    /**
     * Choose, which signals to update.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals updateMany
   */
  export type signalsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update signals.
     */
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyInput>
    /**
     * Filter which signals to update
     */
    where?: signalsWhereInput
    /**
     * Limit how many signals to update.
     */
    limit?: number
  }

  /**
   * signals updateManyAndReturn
   */
  export type signalsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * The data used to update signals.
     */
    data: XOR<signalsUpdateManyMutationInput, signalsUncheckedUpdateManyInput>
    /**
     * Filter which signals to update
     */
    where?: signalsWhereInput
    /**
     * Limit how many signals to update.
     */
    limit?: number
  }

  /**
   * signals upsert
   */
  export type signalsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * The filter to search for the signals to update in case it exists.
     */
    where: signalsWhereUniqueInput
    /**
     * In case the signals found by the `where` argument doesn't exist, create a new signals with this data.
     */
    create: XOR<signalsCreateInput, signalsUncheckedCreateInput>
    /**
     * In case the signals was found with the provided `where` argument, update it with this data.
     */
    update: XOR<signalsUpdateInput, signalsUncheckedUpdateInput>
  }

  /**
   * signals delete
   */
  export type signalsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
    /**
     * Filter which signals to delete.
     */
    where: signalsWhereUniqueInput
  }

  /**
   * signals deleteMany
   */
  export type signalsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which signals to delete
     */
    where?: signalsWhereInput
    /**
     * Limit how many signals to delete.
     */
    limit?: number
  }

  /**
   * signals without action
   */
  export type signalsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the signals
     */
    select?: signalsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the signals
     */
    omit?: signalsOmit<ExtArgs> | null
  }


  /**
   * Model tokens
   */

  export type AggregateTokens = {
    _count: TokensCountAggregateOutputType | null
    _avg: TokensAvgAggregateOutputType | null
    _sum: TokensSumAggregateOutputType | null
    _min: TokensMinAggregateOutputType | null
    _max: TokensMaxAggregateOutputType | null
  }

  export type TokensAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TokensSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type TokensMinAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokensMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokensCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokensAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TokensSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type TokensMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokensMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokensCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens to aggregate.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tokens
    **/
    _count?: true | TokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokensMaxAggregateInputType
  }

  export type GetTokensAggregateType<T extends TokensAggregateArgs> = {
        [P in keyof T & keyof AggregateTokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokens[P]>
      : GetScalarType<T[P], AggregateTokens[P]>
  }




  export type tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tokensWhereInput
    orderBy?: tokensOrderByWithAggregationInput | tokensOrderByWithAggregationInput[]
    by: TokensScalarFieldEnum[] | TokensScalarFieldEnum
    having?: tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokensCountAggregateInputType | true
    _avg?: TokensAvgAggregateInputType
    _sum?: TokensSumAggregateInputType
    _min?: TokensMinAggregateInputType
    _max?: TokensMaxAggregateInputType
  }

  export type TokensGroupByOutputType = {
    id: number
    userId: number | null
    token: string
    createdAt: Date
    updatedAt: Date
    _count: TokensCountAggregateOutputType | null
    _avg: TokensAvgAggregateOutputType | null
    _sum: TokensSumAggregateOutputType | null
    _min: TokensMinAggregateOutputType | null
    _max: TokensMaxAggregateOutputType | null
  }

  type GetTokensGroupByPayload<T extends tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokensGroupByOutputType[P]>
            : GetScalarType<T[P], TokensGroupByOutputType[P]>
        }
      >
    >


  export type tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | tokens$usersArgs<ExtArgs>
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | tokens$usersArgs<ExtArgs>
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | tokens$usersArgs<ExtArgs>
  }, ExtArgs["result"]["tokens"]>

  export type tokensSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "createdAt" | "updatedAt", ExtArgs["result"]["tokens"]>
  export type tokensInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | tokens$usersArgs<ExtArgs>
  }
  export type tokensIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | tokens$usersArgs<ExtArgs>
  }
  export type tokensIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | tokens$usersArgs<ExtArgs>
  }

  export type $tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tokens"
    objects: {
      users: Prisma.$usersPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number | null
      token: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tokens"]>
    composites: {}
  }

  type tokensGetPayload<S extends boolean | null | undefined | tokensDefaultArgs> = $Result.GetResult<Prisma.$tokensPayload, S>

  type tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokensCountAggregateInputType | true
    }

  export interface tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tokens'], meta: { name: 'tokens' } }
    /**
     * Find zero or one Tokens that matches the filter.
     * @param {tokensFindUniqueArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tokensFindUniqueArgs>(args: SelectSubset<T, tokensFindUniqueArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tokensFindUniqueOrThrowArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindFirstArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tokensFindFirstArgs>(args?: SelectSubset<T, tokensFindFirstArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindFirstOrThrowArgs} args - Arguments to find a Tokens
     * @example
     * // Get one Tokens
     * const tokens = await prisma.tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.tokens.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.tokens.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokensWithIdOnly = await prisma.tokens.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tokensFindManyArgs>(args?: SelectSubset<T, tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tokens.
     * @param {tokensCreateArgs} args - Arguments to create a Tokens.
     * @example
     * // Create one Tokens
     * const Tokens = await prisma.tokens.create({
     *   data: {
     *     // ... data to create a Tokens
     *   }
     * })
     * 
     */
    create<T extends tokensCreateArgs>(args: SelectSubset<T, tokensCreateArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {tokensCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const tokens = await prisma.tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tokensCreateManyArgs>(args?: SelectSubset<T, tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {tokensCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const tokens = await prisma.tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokensWithIdOnly = await prisma.tokens.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tokens.
     * @param {tokensDeleteArgs} args - Arguments to delete one Tokens.
     * @example
     * // Delete one Tokens
     * const Tokens = await prisma.tokens.delete({
     *   where: {
     *     // ... filter to delete one Tokens
     *   }
     * })
     * 
     */
    delete<T extends tokensDeleteArgs>(args: SelectSubset<T, tokensDeleteArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tokens.
     * @param {tokensUpdateArgs} args - Arguments to update one Tokens.
     * @example
     * // Update one Tokens
     * const tokens = await prisma.tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tokensUpdateArgs>(args: SelectSubset<T, tokensUpdateArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {tokensDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tokensDeleteManyArgs>(args?: SelectSubset<T, tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const tokens = await prisma.tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tokensUpdateManyArgs>(args: SelectSubset<T, tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {tokensUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const tokens = await prisma.tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokensWithIdOnly = await prisma.tokens.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tokens.
     * @param {tokensUpsertArgs} args - Arguments to update or create a Tokens.
     * @example
     * // Update or create a Tokens
     * const tokens = await prisma.tokens.upsert({
     *   create: {
     *     // ... data to create a Tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tokens we want to update
     *   }
     * })
     */
    upsert<T extends tokensUpsertArgs>(args: SelectSubset<T, tokensUpsertArgs<ExtArgs>>): Prisma__tokensClient<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.tokens.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends tokensCountArgs>(
      args?: Subset<T, tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokensAggregateArgs>(args: Subset<T, TokensAggregateArgs>): Prisma.PrismaPromise<GetTokensAggregateType<T>>

    /**
     * Group by Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tokensGroupByArgs['orderBy'] }
        : { orderBy?: tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tokens model
   */
  readonly fields: tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends tokens$usersArgs<ExtArgs> = {}>(args?: Subset<T, tokens$usersArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tokens model
   */
  interface tokensFieldRefs {
    readonly id: FieldRef<"tokens", 'Int'>
    readonly userId: FieldRef<"tokens", 'Int'>
    readonly token: FieldRef<"tokens", 'String'>
    readonly createdAt: FieldRef<"tokens", 'DateTime'>
    readonly updatedAt: FieldRef<"tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tokens findUnique
   */
  export type tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens findUniqueOrThrow
   */
  export type tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens findFirst
   */
  export type tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens.
     */
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens findFirstOrThrow
   */
  export type tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tokens.
     */
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens findMany
   */
  export type tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter, which tokens to fetch.
     */
    where?: tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tokens to fetch.
     */
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tokens.
     */
    cursor?: tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tokens.
     */
    skip?: number
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * tokens create
   */
  export type tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * The data needed to create a tokens.
     */
    data: XOR<tokensCreateInput, tokensUncheckedCreateInput>
  }

  /**
   * tokens createMany
   */
  export type tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tokens.
     */
    data: tokensCreateManyInput | tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tokens createManyAndReturn
   */
  export type tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data used to create many tokens.
     */
    data: tokensCreateManyInput | tokensCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tokens update
   */
  export type tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * The data needed to update a tokens.
     */
    data: XOR<tokensUpdateInput, tokensUncheckedUpdateInput>
    /**
     * Choose, which tokens to update.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens updateMany
   */
  export type tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tokens.
     */
    data: XOR<tokensUpdateManyMutationInput, tokensUncheckedUpdateManyInput>
    /**
     * Filter which tokens to update
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to update.
     */
    limit?: number
  }

  /**
   * tokens updateManyAndReturn
   */
  export type tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * The data used to update tokens.
     */
    data: XOR<tokensUpdateManyMutationInput, tokensUncheckedUpdateManyInput>
    /**
     * Filter which tokens to update
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tokens upsert
   */
  export type tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * The filter to search for the tokens to update in case it exists.
     */
    where: tokensWhereUniqueInput
    /**
     * In case the tokens found by the `where` argument doesn't exist, create a new tokens with this data.
     */
    create: XOR<tokensCreateInput, tokensUncheckedCreateInput>
    /**
     * In case the tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tokensUpdateInput, tokensUncheckedUpdateInput>
  }

  /**
   * tokens delete
   */
  export type tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    /**
     * Filter which tokens to delete.
     */
    where: tokensWhereUniqueInput
  }

  /**
   * tokens deleteMany
   */
  export type tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tokens to delete
     */
    where?: tokensWhereInput
    /**
     * Limit how many tokens to delete.
     */
    limit?: number
  }

  /**
   * tokens.users
   */
  export type tokens$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
  }

  /**
   * tokens without action
   */
  export type tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
  }


  /**
   * Model tube_assembly
   */

  export type AggregateTube_assembly = {
    _count: Tube_assemblyCountAggregateOutputType | null
    _avg: Tube_assemblyAvgAggregateOutputType | null
    _sum: Tube_assemblySumAggregateOutputType | null
    _min: Tube_assemblyMinAggregateOutputType | null
    _max: Tube_assemblyMaxAggregateOutputType | null
  }

  export type Tube_assemblyAvgAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_material_id: number | null
    tube_conveyor_post_id: number | null
  }

  export type Tube_assemblySumAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_material_id: number | null
    tube_conveyor_post_id: number | null
  }

  export type Tube_assemblyMinAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_material_id: number | null
    tube_conveyor_post_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_assemblyMaxAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_material_id: number | null
    tube_conveyor_post_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_assemblyCountAggregateOutputType = {
    id: number
    tube_record_id: number
    tube_material_id: number
    tube_conveyor_post_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tube_assemblyAvgAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_material_id?: true
    tube_conveyor_post_id?: true
  }

  export type Tube_assemblySumAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_material_id?: true
    tube_conveyor_post_id?: true
  }

  export type Tube_assemblyMinAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_material_id?: true
    tube_conveyor_post_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_assemblyMaxAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_material_id?: true
    tube_conveyor_post_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_assemblyCountAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_material_id?: true
    tube_conveyor_post_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tube_assemblyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_assembly to aggregate.
     */
    where?: tube_assemblyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_assemblies to fetch.
     */
    orderBy?: tube_assemblyOrderByWithRelationInput | tube_assemblyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_assemblyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_assemblies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_assemblies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_assemblies
    **/
    _count?: true | Tube_assemblyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_assemblyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_assemblySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_assemblyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_assemblyMaxAggregateInputType
  }

  export type GetTube_assemblyAggregateType<T extends Tube_assemblyAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_assembly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_assembly[P]>
      : GetScalarType<T[P], AggregateTube_assembly[P]>
  }




  export type tube_assemblyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_assemblyWhereInput
    orderBy?: tube_assemblyOrderByWithAggregationInput | tube_assemblyOrderByWithAggregationInput[]
    by: Tube_assemblyScalarFieldEnum[] | Tube_assemblyScalarFieldEnum
    having?: tube_assemblyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_assemblyCountAggregateInputType | true
    _avg?: Tube_assemblyAvgAggregateInputType
    _sum?: Tube_assemblySumAggregateInputType
    _min?: Tube_assemblyMinAggregateInputType
    _max?: Tube_assemblyMaxAggregateInputType
  }

  export type Tube_assemblyGroupByOutputType = {
    id: number
    tube_record_id: number | null
    tube_material_id: number | null
    tube_conveyor_post_id: number | null
    createdAt: Date
    updatedAt: Date
    _count: Tube_assemblyCountAggregateOutputType | null
    _avg: Tube_assemblyAvgAggregateOutputType | null
    _sum: Tube_assemblySumAggregateOutputType | null
    _min: Tube_assemblyMinAggregateOutputType | null
    _max: Tube_assemblyMaxAggregateOutputType | null
  }

  type GetTube_assemblyGroupByPayload<T extends tube_assemblyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_assemblyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_assemblyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_assemblyGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_assemblyGroupByOutputType[P]>
        }
      >
    >


  export type tube_assemblySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    tube_material_id?: boolean
    tube_conveyor_post_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_conveyor_posts?: boolean | tube_assembly$tube_conveyor_postsArgs<ExtArgs>
    tube_materials?: boolean | tube_assembly$tube_materialsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_assembly"]>

  export type tube_assemblySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    tube_material_id?: boolean
    tube_conveyor_post_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_conveyor_posts?: boolean | tube_assembly$tube_conveyor_postsArgs<ExtArgs>
    tube_materials?: boolean | tube_assembly$tube_materialsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_assembly"]>

  export type tube_assemblySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    tube_material_id?: boolean
    tube_conveyor_post_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_conveyor_posts?: boolean | tube_assembly$tube_conveyor_postsArgs<ExtArgs>
    tube_materials?: boolean | tube_assembly$tube_materialsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_assembly"]>

  export type tube_assemblySelectScalar = {
    id?: boolean
    tube_record_id?: boolean
    tube_material_id?: boolean
    tube_conveyor_post_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tube_assemblyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tube_record_id" | "tube_material_id" | "tube_conveyor_post_id" | "createdAt" | "updatedAt", ExtArgs["result"]["tube_assembly"]>
  export type tube_assemblyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_conveyor_posts?: boolean | tube_assembly$tube_conveyor_postsArgs<ExtArgs>
    tube_materials?: boolean | tube_assembly$tube_materialsArgs<ExtArgs>
  }
  export type tube_assemblyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_conveyor_posts?: boolean | tube_assembly$tube_conveyor_postsArgs<ExtArgs>
    tube_materials?: boolean | tube_assembly$tube_materialsArgs<ExtArgs>
  }
  export type tube_assemblyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_conveyor_posts?: boolean | tube_assembly$tube_conveyor_postsArgs<ExtArgs>
    tube_materials?: boolean | tube_assembly$tube_materialsArgs<ExtArgs>
  }

  export type $tube_assemblyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_assembly"
    objects: {
      tube_conveyor_posts: Prisma.$tube_conveyor_postsPayload<ExtArgs> | null
      tube_materials: Prisma.$tube_materialsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tube_record_id: number | null
      tube_material_id: number | null
      tube_conveyor_post_id: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tube_assembly"]>
    composites: {}
  }

  type tube_assemblyGetPayload<S extends boolean | null | undefined | tube_assemblyDefaultArgs> = $Result.GetResult<Prisma.$tube_assemblyPayload, S>

  type tube_assemblyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_assemblyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_assemblyCountAggregateInputType | true
    }

  export interface tube_assemblyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_assembly'], meta: { name: 'tube_assembly' } }
    /**
     * Find zero or one Tube_assembly that matches the filter.
     * @param {tube_assemblyFindUniqueArgs} args - Arguments to find a Tube_assembly
     * @example
     * // Get one Tube_assembly
     * const tube_assembly = await prisma.tube_assembly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_assemblyFindUniqueArgs>(args: SelectSubset<T, tube_assemblyFindUniqueArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_assembly that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_assemblyFindUniqueOrThrowArgs} args - Arguments to find a Tube_assembly
     * @example
     * // Get one Tube_assembly
     * const tube_assembly = await prisma.tube_assembly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_assemblyFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_assemblyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_assembly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_assemblyFindFirstArgs} args - Arguments to find a Tube_assembly
     * @example
     * // Get one Tube_assembly
     * const tube_assembly = await prisma.tube_assembly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_assemblyFindFirstArgs>(args?: SelectSubset<T, tube_assemblyFindFirstArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_assembly that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_assemblyFindFirstOrThrowArgs} args - Arguments to find a Tube_assembly
     * @example
     * // Get one Tube_assembly
     * const tube_assembly = await prisma.tube_assembly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_assemblyFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_assemblyFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_assemblies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_assemblyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_assemblies
     * const tube_assemblies = await prisma.tube_assembly.findMany()
     * 
     * // Get first 10 Tube_assemblies
     * const tube_assemblies = await prisma.tube_assembly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_assemblyWithIdOnly = await prisma.tube_assembly.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_assemblyFindManyArgs>(args?: SelectSubset<T, tube_assemblyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_assembly.
     * @param {tube_assemblyCreateArgs} args - Arguments to create a Tube_assembly.
     * @example
     * // Create one Tube_assembly
     * const Tube_assembly = await prisma.tube_assembly.create({
     *   data: {
     *     // ... data to create a Tube_assembly
     *   }
     * })
     * 
     */
    create<T extends tube_assemblyCreateArgs>(args: SelectSubset<T, tube_assemblyCreateArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_assemblies.
     * @param {tube_assemblyCreateManyArgs} args - Arguments to create many Tube_assemblies.
     * @example
     * // Create many Tube_assemblies
     * const tube_assembly = await prisma.tube_assembly.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_assemblyCreateManyArgs>(args?: SelectSubset<T, tube_assemblyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_assemblies and returns the data saved in the database.
     * @param {tube_assemblyCreateManyAndReturnArgs} args - Arguments to create many Tube_assemblies.
     * @example
     * // Create many Tube_assemblies
     * const tube_assembly = await prisma.tube_assembly.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_assemblies and only return the `id`
     * const tube_assemblyWithIdOnly = await prisma.tube_assembly.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_assemblyCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_assemblyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_assembly.
     * @param {tube_assemblyDeleteArgs} args - Arguments to delete one Tube_assembly.
     * @example
     * // Delete one Tube_assembly
     * const Tube_assembly = await prisma.tube_assembly.delete({
     *   where: {
     *     // ... filter to delete one Tube_assembly
     *   }
     * })
     * 
     */
    delete<T extends tube_assemblyDeleteArgs>(args: SelectSubset<T, tube_assemblyDeleteArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_assembly.
     * @param {tube_assemblyUpdateArgs} args - Arguments to update one Tube_assembly.
     * @example
     * // Update one Tube_assembly
     * const tube_assembly = await prisma.tube_assembly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_assemblyUpdateArgs>(args: SelectSubset<T, tube_assemblyUpdateArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_assemblies.
     * @param {tube_assemblyDeleteManyArgs} args - Arguments to filter Tube_assemblies to delete.
     * @example
     * // Delete a few Tube_assemblies
     * const { count } = await prisma.tube_assembly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_assemblyDeleteManyArgs>(args?: SelectSubset<T, tube_assemblyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_assemblies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_assemblyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_assemblies
     * const tube_assembly = await prisma.tube_assembly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_assemblyUpdateManyArgs>(args: SelectSubset<T, tube_assemblyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_assemblies and returns the data updated in the database.
     * @param {tube_assemblyUpdateManyAndReturnArgs} args - Arguments to update many Tube_assemblies.
     * @example
     * // Update many Tube_assemblies
     * const tube_assembly = await prisma.tube_assembly.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_assemblies and only return the `id`
     * const tube_assemblyWithIdOnly = await prisma.tube_assembly.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_assemblyUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_assemblyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_assembly.
     * @param {tube_assemblyUpsertArgs} args - Arguments to update or create a Tube_assembly.
     * @example
     * // Update or create a Tube_assembly
     * const tube_assembly = await prisma.tube_assembly.upsert({
     *   create: {
     *     // ... data to create a Tube_assembly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_assembly we want to update
     *   }
     * })
     */
    upsert<T extends tube_assemblyUpsertArgs>(args: SelectSubset<T, tube_assemblyUpsertArgs<ExtArgs>>): Prisma__tube_assemblyClient<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_assemblies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_assemblyCountArgs} args - Arguments to filter Tube_assemblies to count.
     * @example
     * // Count the number of Tube_assemblies
     * const count = await prisma.tube_assembly.count({
     *   where: {
     *     // ... the filter for the Tube_assemblies we want to count
     *   }
     * })
    **/
    count<T extends tube_assemblyCountArgs>(
      args?: Subset<T, tube_assemblyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_assemblyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_assembly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_assemblyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_assemblyAggregateArgs>(args: Subset<T, Tube_assemblyAggregateArgs>): Prisma.PrismaPromise<GetTube_assemblyAggregateType<T>>

    /**
     * Group by Tube_assembly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_assemblyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_assemblyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_assemblyGroupByArgs['orderBy'] }
        : { orderBy?: tube_assemblyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_assemblyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_assemblyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_assembly model
   */
  readonly fields: tube_assemblyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_assembly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_assemblyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_conveyor_posts<T extends tube_assembly$tube_conveyor_postsArgs<ExtArgs> = {}>(args?: Subset<T, tube_assembly$tube_conveyor_postsArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tube_materials<T extends tube_assembly$tube_materialsArgs<ExtArgs> = {}>(args?: Subset<T, tube_assembly$tube_materialsArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_assembly model
   */
  interface tube_assemblyFieldRefs {
    readonly id: FieldRef<"tube_assembly", 'Int'>
    readonly tube_record_id: FieldRef<"tube_assembly", 'Int'>
    readonly tube_material_id: FieldRef<"tube_assembly", 'Int'>
    readonly tube_conveyor_post_id: FieldRef<"tube_assembly", 'Int'>
    readonly createdAt: FieldRef<"tube_assembly", 'DateTime'>
    readonly updatedAt: FieldRef<"tube_assembly", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tube_assembly findUnique
   */
  export type tube_assemblyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * Filter, which tube_assembly to fetch.
     */
    where: tube_assemblyWhereUniqueInput
  }

  /**
   * tube_assembly findUniqueOrThrow
   */
  export type tube_assemblyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * Filter, which tube_assembly to fetch.
     */
    where: tube_assemblyWhereUniqueInput
  }

  /**
   * tube_assembly findFirst
   */
  export type tube_assemblyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * Filter, which tube_assembly to fetch.
     */
    where?: tube_assemblyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_assemblies to fetch.
     */
    orderBy?: tube_assemblyOrderByWithRelationInput | tube_assemblyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_assemblies.
     */
    cursor?: tube_assemblyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_assemblies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_assemblies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_assemblies.
     */
    distinct?: Tube_assemblyScalarFieldEnum | Tube_assemblyScalarFieldEnum[]
  }

  /**
   * tube_assembly findFirstOrThrow
   */
  export type tube_assemblyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * Filter, which tube_assembly to fetch.
     */
    where?: tube_assemblyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_assemblies to fetch.
     */
    orderBy?: tube_assemblyOrderByWithRelationInput | tube_assemblyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_assemblies.
     */
    cursor?: tube_assemblyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_assemblies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_assemblies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_assemblies.
     */
    distinct?: Tube_assemblyScalarFieldEnum | Tube_assemblyScalarFieldEnum[]
  }

  /**
   * tube_assembly findMany
   */
  export type tube_assemblyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * Filter, which tube_assemblies to fetch.
     */
    where?: tube_assemblyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_assemblies to fetch.
     */
    orderBy?: tube_assemblyOrderByWithRelationInput | tube_assemblyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_assemblies.
     */
    cursor?: tube_assemblyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_assemblies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_assemblies.
     */
    skip?: number
    distinct?: Tube_assemblyScalarFieldEnum | Tube_assemblyScalarFieldEnum[]
  }

  /**
   * tube_assembly create
   */
  export type tube_assemblyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_assembly.
     */
    data: XOR<tube_assemblyCreateInput, tube_assemblyUncheckedCreateInput>
  }

  /**
   * tube_assembly createMany
   */
  export type tube_assemblyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_assemblies.
     */
    data: tube_assemblyCreateManyInput | tube_assemblyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_assembly createManyAndReturn
   */
  export type tube_assemblyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * The data used to create many tube_assemblies.
     */
    data: tube_assemblyCreateManyInput | tube_assemblyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_assembly update
   */
  export type tube_assemblyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_assembly.
     */
    data: XOR<tube_assemblyUpdateInput, tube_assemblyUncheckedUpdateInput>
    /**
     * Choose, which tube_assembly to update.
     */
    where: tube_assemblyWhereUniqueInput
  }

  /**
   * tube_assembly updateMany
   */
  export type tube_assemblyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_assemblies.
     */
    data: XOR<tube_assemblyUpdateManyMutationInput, tube_assemblyUncheckedUpdateManyInput>
    /**
     * Filter which tube_assemblies to update
     */
    where?: tube_assemblyWhereInput
    /**
     * Limit how many tube_assemblies to update.
     */
    limit?: number
  }

  /**
   * tube_assembly updateManyAndReturn
   */
  export type tube_assemblyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * The data used to update tube_assemblies.
     */
    data: XOR<tube_assemblyUpdateManyMutationInput, tube_assemblyUncheckedUpdateManyInput>
    /**
     * Filter which tube_assemblies to update
     */
    where?: tube_assemblyWhereInput
    /**
     * Limit how many tube_assemblies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_assembly upsert
   */
  export type tube_assemblyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_assembly to update in case it exists.
     */
    where: tube_assemblyWhereUniqueInput
    /**
     * In case the tube_assembly found by the `where` argument doesn't exist, create a new tube_assembly with this data.
     */
    create: XOR<tube_assemblyCreateInput, tube_assemblyUncheckedCreateInput>
    /**
     * In case the tube_assembly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_assemblyUpdateInput, tube_assemblyUncheckedUpdateInput>
  }

  /**
   * tube_assembly delete
   */
  export type tube_assemblyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    /**
     * Filter which tube_assembly to delete.
     */
    where: tube_assemblyWhereUniqueInput
  }

  /**
   * tube_assembly deleteMany
   */
  export type tube_assemblyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_assemblies to delete
     */
    where?: tube_assemblyWhereInput
    /**
     * Limit how many tube_assemblies to delete.
     */
    limit?: number
  }

  /**
   * tube_assembly.tube_conveyor_posts
   */
  export type tube_assembly$tube_conveyor_postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    where?: tube_conveyor_postsWhereInput
  }

  /**
   * tube_assembly.tube_materials
   */
  export type tube_assembly$tube_materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    where?: tube_materialsWhereInput
  }

  /**
   * tube_assembly without action
   */
  export type tube_assemblyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
  }


  /**
   * Model tube_conveyor_posts
   */

  export type AggregateTube_conveyor_posts = {
    _count: Tube_conveyor_postsCountAggregateOutputType | null
    _avg: Tube_conveyor_postsAvgAggregateOutputType | null
    _sum: Tube_conveyor_postsSumAggregateOutputType | null
    _min: Tube_conveyor_postsMinAggregateOutputType | null
    _max: Tube_conveyor_postsMaxAggregateOutputType | null
  }

  export type Tube_conveyor_postsAvgAggregateOutputType = {
    id: number | null
  }

  export type Tube_conveyor_postsSumAggregateOutputType = {
    id: number | null
  }

  export type Tube_conveyor_postsMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Tube_conveyor_postsMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type Tube_conveyor_postsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type Tube_conveyor_postsAvgAggregateInputType = {
    id?: true
  }

  export type Tube_conveyor_postsSumAggregateInputType = {
    id?: true
  }

  export type Tube_conveyor_postsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type Tube_conveyor_postsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type Tube_conveyor_postsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type Tube_conveyor_postsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_conveyor_posts to aggregate.
     */
    where?: tube_conveyor_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyor_posts to fetch.
     */
    orderBy?: tube_conveyor_postsOrderByWithRelationInput | tube_conveyor_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_conveyor_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyor_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyor_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_conveyor_posts
    **/
    _count?: true | Tube_conveyor_postsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_conveyor_postsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_conveyor_postsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_conveyor_postsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_conveyor_postsMaxAggregateInputType
  }

  export type GetTube_conveyor_postsAggregateType<T extends Tube_conveyor_postsAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_conveyor_posts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_conveyor_posts[P]>
      : GetScalarType<T[P], AggregateTube_conveyor_posts[P]>
  }




  export type tube_conveyor_postsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_conveyor_postsWhereInput
    orderBy?: tube_conveyor_postsOrderByWithAggregationInput | tube_conveyor_postsOrderByWithAggregationInput[]
    by: Tube_conveyor_postsScalarFieldEnum[] | Tube_conveyor_postsScalarFieldEnum
    having?: tube_conveyor_postsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_conveyor_postsCountAggregateInputType | true
    _avg?: Tube_conveyor_postsAvgAggregateInputType
    _sum?: Tube_conveyor_postsSumAggregateInputType
    _min?: Tube_conveyor_postsMinAggregateInputType
    _max?: Tube_conveyor_postsMaxAggregateInputType
  }

  export type Tube_conveyor_postsGroupByOutputType = {
    id: number
    name: string
    _count: Tube_conveyor_postsCountAggregateOutputType | null
    _avg: Tube_conveyor_postsAvgAggregateOutputType | null
    _sum: Tube_conveyor_postsSumAggregateOutputType | null
    _min: Tube_conveyor_postsMinAggregateOutputType | null
    _max: Tube_conveyor_postsMaxAggregateOutputType | null
  }

  type GetTube_conveyor_postsGroupByPayload<T extends tube_conveyor_postsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_conveyor_postsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_conveyor_postsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_conveyor_postsGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_conveyor_postsGroupByOutputType[P]>
        }
      >
    >


  export type tube_conveyor_postsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    tube_assembly?: boolean | tube_conveyor_posts$tube_assemblyArgs<ExtArgs>
    _count?: boolean | Tube_conveyor_postsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tube_conveyor_posts"]>

  export type tube_conveyor_postsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tube_conveyor_posts"]>

  export type tube_conveyor_postsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["tube_conveyor_posts"]>

  export type tube_conveyor_postsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type tube_conveyor_postsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["tube_conveyor_posts"]>
  export type tube_conveyor_postsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_assembly?: boolean | tube_conveyor_posts$tube_assemblyArgs<ExtArgs>
    _count?: boolean | Tube_conveyor_postsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tube_conveyor_postsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tube_conveyor_postsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tube_conveyor_postsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_conveyor_posts"
    objects: {
      tube_assembly: Prisma.$tube_assemblyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["tube_conveyor_posts"]>
    composites: {}
  }

  type tube_conveyor_postsGetPayload<S extends boolean | null | undefined | tube_conveyor_postsDefaultArgs> = $Result.GetResult<Prisma.$tube_conveyor_postsPayload, S>

  type tube_conveyor_postsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_conveyor_postsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_conveyor_postsCountAggregateInputType | true
    }

  export interface tube_conveyor_postsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_conveyor_posts'], meta: { name: 'tube_conveyor_posts' } }
    /**
     * Find zero or one Tube_conveyor_posts that matches the filter.
     * @param {tube_conveyor_postsFindUniqueArgs} args - Arguments to find a Tube_conveyor_posts
     * @example
     * // Get one Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_conveyor_postsFindUniqueArgs>(args: SelectSubset<T, tube_conveyor_postsFindUniqueArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_conveyor_posts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_conveyor_postsFindUniqueOrThrowArgs} args - Arguments to find a Tube_conveyor_posts
     * @example
     * // Get one Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_conveyor_postsFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_conveyor_postsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_conveyor_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyor_postsFindFirstArgs} args - Arguments to find a Tube_conveyor_posts
     * @example
     * // Get one Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_conveyor_postsFindFirstArgs>(args?: SelectSubset<T, tube_conveyor_postsFindFirstArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_conveyor_posts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyor_postsFindFirstOrThrowArgs} args - Arguments to find a Tube_conveyor_posts
     * @example
     * // Get one Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_conveyor_postsFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_conveyor_postsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_conveyor_posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyor_postsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.findMany()
     * 
     * // Get first 10 Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_conveyor_postsWithIdOnly = await prisma.tube_conveyor_posts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_conveyor_postsFindManyArgs>(args?: SelectSubset<T, tube_conveyor_postsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_conveyor_posts.
     * @param {tube_conveyor_postsCreateArgs} args - Arguments to create a Tube_conveyor_posts.
     * @example
     * // Create one Tube_conveyor_posts
     * const Tube_conveyor_posts = await prisma.tube_conveyor_posts.create({
     *   data: {
     *     // ... data to create a Tube_conveyor_posts
     *   }
     * })
     * 
     */
    create<T extends tube_conveyor_postsCreateArgs>(args: SelectSubset<T, tube_conveyor_postsCreateArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_conveyor_posts.
     * @param {tube_conveyor_postsCreateManyArgs} args - Arguments to create many Tube_conveyor_posts.
     * @example
     * // Create many Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_conveyor_postsCreateManyArgs>(args?: SelectSubset<T, tube_conveyor_postsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_conveyor_posts and returns the data saved in the database.
     * @param {tube_conveyor_postsCreateManyAndReturnArgs} args - Arguments to create many Tube_conveyor_posts.
     * @example
     * // Create many Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_conveyor_posts and only return the `id`
     * const tube_conveyor_postsWithIdOnly = await prisma.tube_conveyor_posts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_conveyor_postsCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_conveyor_postsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_conveyor_posts.
     * @param {tube_conveyor_postsDeleteArgs} args - Arguments to delete one Tube_conveyor_posts.
     * @example
     * // Delete one Tube_conveyor_posts
     * const Tube_conveyor_posts = await prisma.tube_conveyor_posts.delete({
     *   where: {
     *     // ... filter to delete one Tube_conveyor_posts
     *   }
     * })
     * 
     */
    delete<T extends tube_conveyor_postsDeleteArgs>(args: SelectSubset<T, tube_conveyor_postsDeleteArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_conveyor_posts.
     * @param {tube_conveyor_postsUpdateArgs} args - Arguments to update one Tube_conveyor_posts.
     * @example
     * // Update one Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_conveyor_postsUpdateArgs>(args: SelectSubset<T, tube_conveyor_postsUpdateArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_conveyor_posts.
     * @param {tube_conveyor_postsDeleteManyArgs} args - Arguments to filter Tube_conveyor_posts to delete.
     * @example
     * // Delete a few Tube_conveyor_posts
     * const { count } = await prisma.tube_conveyor_posts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_conveyor_postsDeleteManyArgs>(args?: SelectSubset<T, tube_conveyor_postsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_conveyor_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyor_postsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_conveyor_postsUpdateManyArgs>(args: SelectSubset<T, tube_conveyor_postsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_conveyor_posts and returns the data updated in the database.
     * @param {tube_conveyor_postsUpdateManyAndReturnArgs} args - Arguments to update many Tube_conveyor_posts.
     * @example
     * // Update many Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_conveyor_posts and only return the `id`
     * const tube_conveyor_postsWithIdOnly = await prisma.tube_conveyor_posts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_conveyor_postsUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_conveyor_postsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_conveyor_posts.
     * @param {tube_conveyor_postsUpsertArgs} args - Arguments to update or create a Tube_conveyor_posts.
     * @example
     * // Update or create a Tube_conveyor_posts
     * const tube_conveyor_posts = await prisma.tube_conveyor_posts.upsert({
     *   create: {
     *     // ... data to create a Tube_conveyor_posts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_conveyor_posts we want to update
     *   }
     * })
     */
    upsert<T extends tube_conveyor_postsUpsertArgs>(args: SelectSubset<T, tube_conveyor_postsUpsertArgs<ExtArgs>>): Prisma__tube_conveyor_postsClient<$Result.GetResult<Prisma.$tube_conveyor_postsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_conveyor_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyor_postsCountArgs} args - Arguments to filter Tube_conveyor_posts to count.
     * @example
     * // Count the number of Tube_conveyor_posts
     * const count = await prisma.tube_conveyor_posts.count({
     *   where: {
     *     // ... the filter for the Tube_conveyor_posts we want to count
     *   }
     * })
    **/
    count<T extends tube_conveyor_postsCountArgs>(
      args?: Subset<T, tube_conveyor_postsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_conveyor_postsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_conveyor_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_conveyor_postsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_conveyor_postsAggregateArgs>(args: Subset<T, Tube_conveyor_postsAggregateArgs>): Prisma.PrismaPromise<GetTube_conveyor_postsAggregateType<T>>

    /**
     * Group by Tube_conveyor_posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyor_postsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_conveyor_postsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_conveyor_postsGroupByArgs['orderBy'] }
        : { orderBy?: tube_conveyor_postsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_conveyor_postsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_conveyor_postsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_conveyor_posts model
   */
  readonly fields: tube_conveyor_postsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_conveyor_posts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_conveyor_postsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_assembly<T extends tube_conveyor_posts$tube_assemblyArgs<ExtArgs> = {}>(args?: Subset<T, tube_conveyor_posts$tube_assemblyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_conveyor_posts model
   */
  interface tube_conveyor_postsFieldRefs {
    readonly id: FieldRef<"tube_conveyor_posts", 'Int'>
    readonly name: FieldRef<"tube_conveyor_posts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tube_conveyor_posts findUnique
   */
  export type tube_conveyor_postsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyor_posts to fetch.
     */
    where: tube_conveyor_postsWhereUniqueInput
  }

  /**
   * tube_conveyor_posts findUniqueOrThrow
   */
  export type tube_conveyor_postsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyor_posts to fetch.
     */
    where: tube_conveyor_postsWhereUniqueInput
  }

  /**
   * tube_conveyor_posts findFirst
   */
  export type tube_conveyor_postsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyor_posts to fetch.
     */
    where?: tube_conveyor_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyor_posts to fetch.
     */
    orderBy?: tube_conveyor_postsOrderByWithRelationInput | tube_conveyor_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_conveyor_posts.
     */
    cursor?: tube_conveyor_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyor_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyor_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_conveyor_posts.
     */
    distinct?: Tube_conveyor_postsScalarFieldEnum | Tube_conveyor_postsScalarFieldEnum[]
  }

  /**
   * tube_conveyor_posts findFirstOrThrow
   */
  export type tube_conveyor_postsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyor_posts to fetch.
     */
    where?: tube_conveyor_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyor_posts to fetch.
     */
    orderBy?: tube_conveyor_postsOrderByWithRelationInput | tube_conveyor_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_conveyor_posts.
     */
    cursor?: tube_conveyor_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyor_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyor_posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_conveyor_posts.
     */
    distinct?: Tube_conveyor_postsScalarFieldEnum | Tube_conveyor_postsScalarFieldEnum[]
  }

  /**
   * tube_conveyor_posts findMany
   */
  export type tube_conveyor_postsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyor_posts to fetch.
     */
    where?: tube_conveyor_postsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyor_posts to fetch.
     */
    orderBy?: tube_conveyor_postsOrderByWithRelationInput | tube_conveyor_postsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_conveyor_posts.
     */
    cursor?: tube_conveyor_postsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyor_posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyor_posts.
     */
    skip?: number
    distinct?: Tube_conveyor_postsScalarFieldEnum | Tube_conveyor_postsScalarFieldEnum[]
  }

  /**
   * tube_conveyor_posts create
   */
  export type tube_conveyor_postsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_conveyor_posts.
     */
    data: XOR<tube_conveyor_postsCreateInput, tube_conveyor_postsUncheckedCreateInput>
  }

  /**
   * tube_conveyor_posts createMany
   */
  export type tube_conveyor_postsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_conveyor_posts.
     */
    data: tube_conveyor_postsCreateManyInput | tube_conveyor_postsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_conveyor_posts createManyAndReturn
   */
  export type tube_conveyor_postsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * The data used to create many tube_conveyor_posts.
     */
    data: tube_conveyor_postsCreateManyInput | tube_conveyor_postsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_conveyor_posts update
   */
  export type tube_conveyor_postsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_conveyor_posts.
     */
    data: XOR<tube_conveyor_postsUpdateInput, tube_conveyor_postsUncheckedUpdateInput>
    /**
     * Choose, which tube_conveyor_posts to update.
     */
    where: tube_conveyor_postsWhereUniqueInput
  }

  /**
   * tube_conveyor_posts updateMany
   */
  export type tube_conveyor_postsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_conveyor_posts.
     */
    data: XOR<tube_conveyor_postsUpdateManyMutationInput, tube_conveyor_postsUncheckedUpdateManyInput>
    /**
     * Filter which tube_conveyor_posts to update
     */
    where?: tube_conveyor_postsWhereInput
    /**
     * Limit how many tube_conveyor_posts to update.
     */
    limit?: number
  }

  /**
   * tube_conveyor_posts updateManyAndReturn
   */
  export type tube_conveyor_postsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * The data used to update tube_conveyor_posts.
     */
    data: XOR<tube_conveyor_postsUpdateManyMutationInput, tube_conveyor_postsUncheckedUpdateManyInput>
    /**
     * Filter which tube_conveyor_posts to update
     */
    where?: tube_conveyor_postsWhereInput
    /**
     * Limit how many tube_conveyor_posts to update.
     */
    limit?: number
  }

  /**
   * tube_conveyor_posts upsert
   */
  export type tube_conveyor_postsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_conveyor_posts to update in case it exists.
     */
    where: tube_conveyor_postsWhereUniqueInput
    /**
     * In case the tube_conveyor_posts found by the `where` argument doesn't exist, create a new tube_conveyor_posts with this data.
     */
    create: XOR<tube_conveyor_postsCreateInput, tube_conveyor_postsUncheckedCreateInput>
    /**
     * In case the tube_conveyor_posts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_conveyor_postsUpdateInput, tube_conveyor_postsUncheckedUpdateInput>
  }

  /**
   * tube_conveyor_posts delete
   */
  export type tube_conveyor_postsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
    /**
     * Filter which tube_conveyor_posts to delete.
     */
    where: tube_conveyor_postsWhereUniqueInput
  }

  /**
   * tube_conveyor_posts deleteMany
   */
  export type tube_conveyor_postsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_conveyor_posts to delete
     */
    where?: tube_conveyor_postsWhereInput
    /**
     * Limit how many tube_conveyor_posts to delete.
     */
    limit?: number
  }

  /**
   * tube_conveyor_posts.tube_assembly
   */
  export type tube_conveyor_posts$tube_assemblyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    where?: tube_assemblyWhereInput
    orderBy?: tube_assemblyOrderByWithRelationInput | tube_assemblyOrderByWithRelationInput[]
    cursor?: tube_assemblyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_assemblyScalarFieldEnum | Tube_assemblyScalarFieldEnum[]
  }

  /**
   * tube_conveyor_posts without action
   */
  export type tube_conveyor_postsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyor_posts
     */
    select?: tube_conveyor_postsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyor_posts
     */
    omit?: tube_conveyor_postsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyor_postsInclude<ExtArgs> | null
  }


  /**
   * Model tube_conveyors
   */

  export type AggregateTube_conveyors = {
    _count: Tube_conveyorsCountAggregateOutputType | null
    _avg: Tube_conveyorsAvgAggregateOutputType | null
    _sum: Tube_conveyorsSumAggregateOutputType | null
    _min: Tube_conveyorsMinAggregateOutputType | null
    _max: Tube_conveyorsMaxAggregateOutputType | null
  }

  export type Tube_conveyorsAvgAggregateOutputType = {
    id: number | null
  }

  export type Tube_conveyorsSumAggregateOutputType = {
    id: number | null
  }

  export type Tube_conveyorsMinAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
  }

  export type Tube_conveyorsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    barcode: string | null
  }

  export type Tube_conveyorsCountAggregateOutputType = {
    id: number
    name: number
    barcode: number
    _all: number
  }


  export type Tube_conveyorsAvgAggregateInputType = {
    id?: true
  }

  export type Tube_conveyorsSumAggregateInputType = {
    id?: true
  }

  export type Tube_conveyorsMinAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
  }

  export type Tube_conveyorsMaxAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
  }

  export type Tube_conveyorsCountAggregateInputType = {
    id?: true
    name?: true
    barcode?: true
    _all?: true
  }

  export type Tube_conveyorsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_conveyors to aggregate.
     */
    where?: tube_conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyors to fetch.
     */
    orderBy?: tube_conveyorsOrderByWithRelationInput | tube_conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_conveyors
    **/
    _count?: true | Tube_conveyorsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_conveyorsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_conveyorsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_conveyorsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_conveyorsMaxAggregateInputType
  }

  export type GetTube_conveyorsAggregateType<T extends Tube_conveyorsAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_conveyors]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_conveyors[P]>
      : GetScalarType<T[P], AggregateTube_conveyors[P]>
  }




  export type tube_conveyorsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_conveyorsWhereInput
    orderBy?: tube_conveyorsOrderByWithAggregationInput | tube_conveyorsOrderByWithAggregationInput[]
    by: Tube_conveyorsScalarFieldEnum[] | Tube_conveyorsScalarFieldEnum
    having?: tube_conveyorsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_conveyorsCountAggregateInputType | true
    _avg?: Tube_conveyorsAvgAggregateInputType
    _sum?: Tube_conveyorsSumAggregateInputType
    _min?: Tube_conveyorsMinAggregateInputType
    _max?: Tube_conveyorsMaxAggregateInputType
  }

  export type Tube_conveyorsGroupByOutputType = {
    id: number
    name: string | null
    barcode: string | null
    _count: Tube_conveyorsCountAggregateOutputType | null
    _avg: Tube_conveyorsAvgAggregateOutputType | null
    _sum: Tube_conveyorsSumAggregateOutputType | null
    _min: Tube_conveyorsMinAggregateOutputType | null
    _max: Tube_conveyorsMaxAggregateOutputType | null
  }

  type GetTube_conveyorsGroupByPayload<T extends tube_conveyorsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_conveyorsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_conveyorsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_conveyorsGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_conveyorsGroupByOutputType[P]>
        }
      >
    >


  export type tube_conveyorsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
    tube_records?: boolean | tube_conveyors$tube_recordsArgs<ExtArgs>
    tube_sessions?: boolean | tube_conveyors$tube_sessionsArgs<ExtArgs>
    _count?: boolean | Tube_conveyorsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tube_conveyors"]>

  export type tube_conveyorsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
  }, ExtArgs["result"]["tube_conveyors"]>

  export type tube_conveyorsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    barcode?: boolean
  }, ExtArgs["result"]["tube_conveyors"]>

  export type tube_conveyorsSelectScalar = {
    id?: boolean
    name?: boolean
    barcode?: boolean
  }

  export type tube_conveyorsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "barcode", ExtArgs["result"]["tube_conveyors"]>
  export type tube_conveyorsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_records?: boolean | tube_conveyors$tube_recordsArgs<ExtArgs>
    tube_sessions?: boolean | tube_conveyors$tube_sessionsArgs<ExtArgs>
    _count?: boolean | Tube_conveyorsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tube_conveyorsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tube_conveyorsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tube_conveyorsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_conveyors"
    objects: {
      tube_records: Prisma.$tube_recordsPayload<ExtArgs>[]
      tube_sessions: Prisma.$tube_sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      barcode: string | null
    }, ExtArgs["result"]["tube_conveyors"]>
    composites: {}
  }

  type tube_conveyorsGetPayload<S extends boolean | null | undefined | tube_conveyorsDefaultArgs> = $Result.GetResult<Prisma.$tube_conveyorsPayload, S>

  type tube_conveyorsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_conveyorsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_conveyorsCountAggregateInputType | true
    }

  export interface tube_conveyorsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_conveyors'], meta: { name: 'tube_conveyors' } }
    /**
     * Find zero or one Tube_conveyors that matches the filter.
     * @param {tube_conveyorsFindUniqueArgs} args - Arguments to find a Tube_conveyors
     * @example
     * // Get one Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_conveyorsFindUniqueArgs>(args: SelectSubset<T, tube_conveyorsFindUniqueArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_conveyors that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_conveyorsFindUniqueOrThrowArgs} args - Arguments to find a Tube_conveyors
     * @example
     * // Get one Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_conveyorsFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_conveyorsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_conveyors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyorsFindFirstArgs} args - Arguments to find a Tube_conveyors
     * @example
     * // Get one Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_conveyorsFindFirstArgs>(args?: SelectSubset<T, tube_conveyorsFindFirstArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_conveyors that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyorsFindFirstOrThrowArgs} args - Arguments to find a Tube_conveyors
     * @example
     * // Get one Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_conveyorsFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_conveyorsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_conveyors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyorsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.findMany()
     * 
     * // Get first 10 Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_conveyorsWithIdOnly = await prisma.tube_conveyors.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_conveyorsFindManyArgs>(args?: SelectSubset<T, tube_conveyorsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_conveyors.
     * @param {tube_conveyorsCreateArgs} args - Arguments to create a Tube_conveyors.
     * @example
     * // Create one Tube_conveyors
     * const Tube_conveyors = await prisma.tube_conveyors.create({
     *   data: {
     *     // ... data to create a Tube_conveyors
     *   }
     * })
     * 
     */
    create<T extends tube_conveyorsCreateArgs>(args: SelectSubset<T, tube_conveyorsCreateArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_conveyors.
     * @param {tube_conveyorsCreateManyArgs} args - Arguments to create many Tube_conveyors.
     * @example
     * // Create many Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_conveyorsCreateManyArgs>(args?: SelectSubset<T, tube_conveyorsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_conveyors and returns the data saved in the database.
     * @param {tube_conveyorsCreateManyAndReturnArgs} args - Arguments to create many Tube_conveyors.
     * @example
     * // Create many Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_conveyors and only return the `id`
     * const tube_conveyorsWithIdOnly = await prisma.tube_conveyors.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_conveyorsCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_conveyorsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_conveyors.
     * @param {tube_conveyorsDeleteArgs} args - Arguments to delete one Tube_conveyors.
     * @example
     * // Delete one Tube_conveyors
     * const Tube_conveyors = await prisma.tube_conveyors.delete({
     *   where: {
     *     // ... filter to delete one Tube_conveyors
     *   }
     * })
     * 
     */
    delete<T extends tube_conveyorsDeleteArgs>(args: SelectSubset<T, tube_conveyorsDeleteArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_conveyors.
     * @param {tube_conveyorsUpdateArgs} args - Arguments to update one Tube_conveyors.
     * @example
     * // Update one Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_conveyorsUpdateArgs>(args: SelectSubset<T, tube_conveyorsUpdateArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_conveyors.
     * @param {tube_conveyorsDeleteManyArgs} args - Arguments to filter Tube_conveyors to delete.
     * @example
     * // Delete a few Tube_conveyors
     * const { count } = await prisma.tube_conveyors.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_conveyorsDeleteManyArgs>(args?: SelectSubset<T, tube_conveyorsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyorsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_conveyorsUpdateManyArgs>(args: SelectSubset<T, tube_conveyorsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_conveyors and returns the data updated in the database.
     * @param {tube_conveyorsUpdateManyAndReturnArgs} args - Arguments to update many Tube_conveyors.
     * @example
     * // Update many Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_conveyors and only return the `id`
     * const tube_conveyorsWithIdOnly = await prisma.tube_conveyors.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_conveyorsUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_conveyorsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_conveyors.
     * @param {tube_conveyorsUpsertArgs} args - Arguments to update or create a Tube_conveyors.
     * @example
     * // Update or create a Tube_conveyors
     * const tube_conveyors = await prisma.tube_conveyors.upsert({
     *   create: {
     *     // ... data to create a Tube_conveyors
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_conveyors we want to update
     *   }
     * })
     */
    upsert<T extends tube_conveyorsUpsertArgs>(args: SelectSubset<T, tube_conveyorsUpsertArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyorsCountArgs} args - Arguments to filter Tube_conveyors to count.
     * @example
     * // Count the number of Tube_conveyors
     * const count = await prisma.tube_conveyors.count({
     *   where: {
     *     // ... the filter for the Tube_conveyors we want to count
     *   }
     * })
    **/
    count<T extends tube_conveyorsCountArgs>(
      args?: Subset<T, tube_conveyorsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_conveyorsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_conveyorsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_conveyorsAggregateArgs>(args: Subset<T, Tube_conveyorsAggregateArgs>): Prisma.PrismaPromise<GetTube_conveyorsAggregateType<T>>

    /**
     * Group by Tube_conveyors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_conveyorsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_conveyorsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_conveyorsGroupByArgs['orderBy'] }
        : { orderBy?: tube_conveyorsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_conveyorsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_conveyorsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_conveyors model
   */
  readonly fields: tube_conveyorsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_conveyors.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_conveyorsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_records<T extends tube_conveyors$tube_recordsArgs<ExtArgs> = {}>(args?: Subset<T, tube_conveyors$tube_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tube_sessions<T extends tube_conveyors$tube_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, tube_conveyors$tube_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_conveyors model
   */
  interface tube_conveyorsFieldRefs {
    readonly id: FieldRef<"tube_conveyors", 'Int'>
    readonly name: FieldRef<"tube_conveyors", 'String'>
    readonly barcode: FieldRef<"tube_conveyors", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tube_conveyors findUnique
   */
  export type tube_conveyorsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyors to fetch.
     */
    where: tube_conveyorsWhereUniqueInput
  }

  /**
   * tube_conveyors findUniqueOrThrow
   */
  export type tube_conveyorsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyors to fetch.
     */
    where: tube_conveyorsWhereUniqueInput
  }

  /**
   * tube_conveyors findFirst
   */
  export type tube_conveyorsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyors to fetch.
     */
    where?: tube_conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyors to fetch.
     */
    orderBy?: tube_conveyorsOrderByWithRelationInput | tube_conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_conveyors.
     */
    cursor?: tube_conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_conveyors.
     */
    distinct?: Tube_conveyorsScalarFieldEnum | Tube_conveyorsScalarFieldEnum[]
  }

  /**
   * tube_conveyors findFirstOrThrow
   */
  export type tube_conveyorsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyors to fetch.
     */
    where?: tube_conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyors to fetch.
     */
    orderBy?: tube_conveyorsOrderByWithRelationInput | tube_conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_conveyors.
     */
    cursor?: tube_conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_conveyors.
     */
    distinct?: Tube_conveyorsScalarFieldEnum | Tube_conveyorsScalarFieldEnum[]
  }

  /**
   * tube_conveyors findMany
   */
  export type tube_conveyorsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * Filter, which tube_conveyors to fetch.
     */
    where?: tube_conveyorsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_conveyors to fetch.
     */
    orderBy?: tube_conveyorsOrderByWithRelationInput | tube_conveyorsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_conveyors.
     */
    cursor?: tube_conveyorsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_conveyors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_conveyors.
     */
    skip?: number
    distinct?: Tube_conveyorsScalarFieldEnum | Tube_conveyorsScalarFieldEnum[]
  }

  /**
   * tube_conveyors create
   */
  export type tube_conveyorsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_conveyors.
     */
    data?: XOR<tube_conveyorsCreateInput, tube_conveyorsUncheckedCreateInput>
  }

  /**
   * tube_conveyors createMany
   */
  export type tube_conveyorsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_conveyors.
     */
    data: tube_conveyorsCreateManyInput | tube_conveyorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_conveyors createManyAndReturn
   */
  export type tube_conveyorsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * The data used to create many tube_conveyors.
     */
    data: tube_conveyorsCreateManyInput | tube_conveyorsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_conveyors update
   */
  export type tube_conveyorsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_conveyors.
     */
    data: XOR<tube_conveyorsUpdateInput, tube_conveyorsUncheckedUpdateInput>
    /**
     * Choose, which tube_conveyors to update.
     */
    where: tube_conveyorsWhereUniqueInput
  }

  /**
   * tube_conveyors updateMany
   */
  export type tube_conveyorsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_conveyors.
     */
    data: XOR<tube_conveyorsUpdateManyMutationInput, tube_conveyorsUncheckedUpdateManyInput>
    /**
     * Filter which tube_conveyors to update
     */
    where?: tube_conveyorsWhereInput
    /**
     * Limit how many tube_conveyors to update.
     */
    limit?: number
  }

  /**
   * tube_conveyors updateManyAndReturn
   */
  export type tube_conveyorsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * The data used to update tube_conveyors.
     */
    data: XOR<tube_conveyorsUpdateManyMutationInput, tube_conveyorsUncheckedUpdateManyInput>
    /**
     * Filter which tube_conveyors to update
     */
    where?: tube_conveyorsWhereInput
    /**
     * Limit how many tube_conveyors to update.
     */
    limit?: number
  }

  /**
   * tube_conveyors upsert
   */
  export type tube_conveyorsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_conveyors to update in case it exists.
     */
    where: tube_conveyorsWhereUniqueInput
    /**
     * In case the tube_conveyors found by the `where` argument doesn't exist, create a new tube_conveyors with this data.
     */
    create: XOR<tube_conveyorsCreateInput, tube_conveyorsUncheckedCreateInput>
    /**
     * In case the tube_conveyors was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_conveyorsUpdateInput, tube_conveyorsUncheckedUpdateInput>
  }

  /**
   * tube_conveyors delete
   */
  export type tube_conveyorsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    /**
     * Filter which tube_conveyors to delete.
     */
    where: tube_conveyorsWhereUniqueInput
  }

  /**
   * tube_conveyors deleteMany
   */
  export type tube_conveyorsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_conveyors to delete
     */
    where?: tube_conveyorsWhereInput
    /**
     * Limit how many tube_conveyors to delete.
     */
    limit?: number
  }

  /**
   * tube_conveyors.tube_records
   */
  export type tube_conveyors$tube_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    where?: tube_recordsWhereInput
    orderBy?: tube_recordsOrderByWithRelationInput | tube_recordsOrderByWithRelationInput[]
    cursor?: tube_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_recordsScalarFieldEnum | Tube_recordsScalarFieldEnum[]
  }

  /**
   * tube_conveyors.tube_sessions
   */
  export type tube_conveyors$tube_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    where?: tube_sessionsWhereInput
    orderBy?: tube_sessionsOrderByWithRelationInput | tube_sessionsOrderByWithRelationInput[]
    cursor?: tube_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_sessionsScalarFieldEnum | Tube_sessionsScalarFieldEnum[]
  }

  /**
   * tube_conveyors without action
   */
  export type tube_conveyorsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
  }


  /**
   * Model tube_histories
   */

  export type AggregateTube_histories = {
    _count: Tube_historiesCountAggregateOutputType | null
    _avg: Tube_historiesAvgAggregateOutputType | null
    _sum: Tube_historiesSumAggregateOutputType | null
    _min: Tube_historiesMinAggregateOutputType | null
    _max: Tube_historiesMaxAggregateOutputType | null
  }

  export type Tube_historiesAvgAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_history_type_id: number | null
    employee_id: number | null
    tube_history_note_id: number | null
  }

  export type Tube_historiesSumAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_history_type_id: number | null
    employee_id: number | null
    tube_history_note_id: number | null
  }

  export type Tube_historiesMinAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_history_type_id: number | null
    employee_id: number | null
    note: string | null
    tube_history_note_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_historiesMaxAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    tube_history_type_id: number | null
    employee_id: number | null
    note: string | null
    tube_history_note_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_historiesCountAggregateOutputType = {
    id: number
    tube_record_id: number
    tube_history_type_id: number
    employee_id: number
    note: number
    tube_history_note_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tube_historiesAvgAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_history_type_id?: true
    employee_id?: true
    tube_history_note_id?: true
  }

  export type Tube_historiesSumAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_history_type_id?: true
    employee_id?: true
    tube_history_note_id?: true
  }

  export type Tube_historiesMinAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_history_type_id?: true
    employee_id?: true
    note?: true
    tube_history_note_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_historiesMaxAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_history_type_id?: true
    employee_id?: true
    note?: true
    tube_history_note_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_historiesCountAggregateInputType = {
    id?: true
    tube_record_id?: true
    tube_history_type_id?: true
    employee_id?: true
    note?: true
    tube_history_note_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tube_historiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_histories to aggregate.
     */
    where?: tube_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories to fetch.
     */
    orderBy?: tube_historiesOrderByWithRelationInput | tube_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_histories
    **/
    _count?: true | Tube_historiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_historiesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_historiesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_historiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_historiesMaxAggregateInputType
  }

  export type GetTube_historiesAggregateType<T extends Tube_historiesAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_histories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_histories[P]>
      : GetScalarType<T[P], AggregateTube_histories[P]>
  }




  export type tube_historiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_historiesWhereInput
    orderBy?: tube_historiesOrderByWithAggregationInput | tube_historiesOrderByWithAggregationInput[]
    by: Tube_historiesScalarFieldEnum[] | Tube_historiesScalarFieldEnum
    having?: tube_historiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_historiesCountAggregateInputType | true
    _avg?: Tube_historiesAvgAggregateInputType
    _sum?: Tube_historiesSumAggregateInputType
    _min?: Tube_historiesMinAggregateInputType
    _max?: Tube_historiesMaxAggregateInputType
  }

  export type Tube_historiesGroupByOutputType = {
    id: number
    tube_record_id: number | null
    tube_history_type_id: number | null
    employee_id: number | null
    note: string | null
    tube_history_note_id: number | null
    createdAt: Date
    updatedAt: Date
    _count: Tube_historiesCountAggregateOutputType | null
    _avg: Tube_historiesAvgAggregateOutputType | null
    _sum: Tube_historiesSumAggregateOutputType | null
    _min: Tube_historiesMinAggregateOutputType | null
    _max: Tube_historiesMaxAggregateOutputType | null
  }

  type GetTube_historiesGroupByPayload<T extends tube_historiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_historiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_historiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_historiesGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_historiesGroupByOutputType[P]>
        }
      >
    >


  export type tube_historiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    tube_history_type_id?: boolean
    employee_id?: boolean
    note?: boolean
    tube_history_note_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | tube_histories$employeesArgs<ExtArgs>
    tube_histories_notes?: boolean | tube_histories$tube_histories_notesArgs<ExtArgs>
    tube_history_types?: boolean | tube_histories$tube_history_typesArgs<ExtArgs>
  }, ExtArgs["result"]["tube_histories"]>

  export type tube_historiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    tube_history_type_id?: boolean
    employee_id?: boolean
    note?: boolean
    tube_history_note_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | tube_histories$employeesArgs<ExtArgs>
    tube_histories_notes?: boolean | tube_histories$tube_histories_notesArgs<ExtArgs>
    tube_history_types?: boolean | tube_histories$tube_history_typesArgs<ExtArgs>
  }, ExtArgs["result"]["tube_histories"]>

  export type tube_historiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    tube_history_type_id?: boolean
    employee_id?: boolean
    note?: boolean
    tube_history_note_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employees?: boolean | tube_histories$employeesArgs<ExtArgs>
    tube_histories_notes?: boolean | tube_histories$tube_histories_notesArgs<ExtArgs>
    tube_history_types?: boolean | tube_histories$tube_history_typesArgs<ExtArgs>
  }, ExtArgs["result"]["tube_histories"]>

  export type tube_historiesSelectScalar = {
    id?: boolean
    tube_record_id?: boolean
    tube_history_type_id?: boolean
    employee_id?: boolean
    note?: boolean
    tube_history_note_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tube_historiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tube_record_id" | "tube_history_type_id" | "employee_id" | "note" | "tube_history_note_id" | "createdAt" | "updatedAt", ExtArgs["result"]["tube_histories"]>
  export type tube_historiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | tube_histories$employeesArgs<ExtArgs>
    tube_histories_notes?: boolean | tube_histories$tube_histories_notesArgs<ExtArgs>
    tube_history_types?: boolean | tube_histories$tube_history_typesArgs<ExtArgs>
  }
  export type tube_historiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | tube_histories$employeesArgs<ExtArgs>
    tube_histories_notes?: boolean | tube_histories$tube_histories_notesArgs<ExtArgs>
    tube_history_types?: boolean | tube_histories$tube_history_typesArgs<ExtArgs>
  }
  export type tube_historiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | tube_histories$employeesArgs<ExtArgs>
    tube_histories_notes?: boolean | tube_histories$tube_histories_notesArgs<ExtArgs>
    tube_history_types?: boolean | tube_histories$tube_history_typesArgs<ExtArgs>
  }

  export type $tube_historiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_histories"
    objects: {
      employees: Prisma.$employeesPayload<ExtArgs> | null
      tube_histories_notes: Prisma.$tube_histories_notesPayload<ExtArgs> | null
      tube_history_types: Prisma.$tube_history_typesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tube_record_id: number | null
      tube_history_type_id: number | null
      employee_id: number | null
      note: string | null
      tube_history_note_id: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tube_histories"]>
    composites: {}
  }

  type tube_historiesGetPayload<S extends boolean | null | undefined | tube_historiesDefaultArgs> = $Result.GetResult<Prisma.$tube_historiesPayload, S>

  type tube_historiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_historiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_historiesCountAggregateInputType | true
    }

  export interface tube_historiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_histories'], meta: { name: 'tube_histories' } }
    /**
     * Find zero or one Tube_histories that matches the filter.
     * @param {tube_historiesFindUniqueArgs} args - Arguments to find a Tube_histories
     * @example
     * // Get one Tube_histories
     * const tube_histories = await prisma.tube_histories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_historiesFindUniqueArgs>(args: SelectSubset<T, tube_historiesFindUniqueArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_histories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_historiesFindUniqueOrThrowArgs} args - Arguments to find a Tube_histories
     * @example
     * // Get one Tube_histories
     * const tube_histories = await prisma.tube_histories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_historiesFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_historiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_historiesFindFirstArgs} args - Arguments to find a Tube_histories
     * @example
     * // Get one Tube_histories
     * const tube_histories = await prisma.tube_histories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_historiesFindFirstArgs>(args?: SelectSubset<T, tube_historiesFindFirstArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_histories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_historiesFindFirstOrThrowArgs} args - Arguments to find a Tube_histories
     * @example
     * // Get one Tube_histories
     * const tube_histories = await prisma.tube_histories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_historiesFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_historiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_historiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_histories
     * const tube_histories = await prisma.tube_histories.findMany()
     * 
     * // Get first 10 Tube_histories
     * const tube_histories = await prisma.tube_histories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_historiesWithIdOnly = await prisma.tube_histories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_historiesFindManyArgs>(args?: SelectSubset<T, tube_historiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_histories.
     * @param {tube_historiesCreateArgs} args - Arguments to create a Tube_histories.
     * @example
     * // Create one Tube_histories
     * const Tube_histories = await prisma.tube_histories.create({
     *   data: {
     *     // ... data to create a Tube_histories
     *   }
     * })
     * 
     */
    create<T extends tube_historiesCreateArgs>(args: SelectSubset<T, tube_historiesCreateArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_histories.
     * @param {tube_historiesCreateManyArgs} args - Arguments to create many Tube_histories.
     * @example
     * // Create many Tube_histories
     * const tube_histories = await prisma.tube_histories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_historiesCreateManyArgs>(args?: SelectSubset<T, tube_historiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_histories and returns the data saved in the database.
     * @param {tube_historiesCreateManyAndReturnArgs} args - Arguments to create many Tube_histories.
     * @example
     * // Create many Tube_histories
     * const tube_histories = await prisma.tube_histories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_histories and only return the `id`
     * const tube_historiesWithIdOnly = await prisma.tube_histories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_historiesCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_historiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_histories.
     * @param {tube_historiesDeleteArgs} args - Arguments to delete one Tube_histories.
     * @example
     * // Delete one Tube_histories
     * const Tube_histories = await prisma.tube_histories.delete({
     *   where: {
     *     // ... filter to delete one Tube_histories
     *   }
     * })
     * 
     */
    delete<T extends tube_historiesDeleteArgs>(args: SelectSubset<T, tube_historiesDeleteArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_histories.
     * @param {tube_historiesUpdateArgs} args - Arguments to update one Tube_histories.
     * @example
     * // Update one Tube_histories
     * const tube_histories = await prisma.tube_histories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_historiesUpdateArgs>(args: SelectSubset<T, tube_historiesUpdateArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_histories.
     * @param {tube_historiesDeleteManyArgs} args - Arguments to filter Tube_histories to delete.
     * @example
     * // Delete a few Tube_histories
     * const { count } = await prisma.tube_histories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_historiesDeleteManyArgs>(args?: SelectSubset<T, tube_historiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_historiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_histories
     * const tube_histories = await prisma.tube_histories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_historiesUpdateManyArgs>(args: SelectSubset<T, tube_historiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_histories and returns the data updated in the database.
     * @param {tube_historiesUpdateManyAndReturnArgs} args - Arguments to update many Tube_histories.
     * @example
     * // Update many Tube_histories
     * const tube_histories = await prisma.tube_histories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_histories and only return the `id`
     * const tube_historiesWithIdOnly = await prisma.tube_histories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_historiesUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_historiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_histories.
     * @param {tube_historiesUpsertArgs} args - Arguments to update or create a Tube_histories.
     * @example
     * // Update or create a Tube_histories
     * const tube_histories = await prisma.tube_histories.upsert({
     *   create: {
     *     // ... data to create a Tube_histories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_histories we want to update
     *   }
     * })
     */
    upsert<T extends tube_historiesUpsertArgs>(args: SelectSubset<T, tube_historiesUpsertArgs<ExtArgs>>): Prisma__tube_historiesClient<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_historiesCountArgs} args - Arguments to filter Tube_histories to count.
     * @example
     * // Count the number of Tube_histories
     * const count = await prisma.tube_histories.count({
     *   where: {
     *     // ... the filter for the Tube_histories we want to count
     *   }
     * })
    **/
    count<T extends tube_historiesCountArgs>(
      args?: Subset<T, tube_historiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_historiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_historiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_historiesAggregateArgs>(args: Subset<T, Tube_historiesAggregateArgs>): Prisma.PrismaPromise<GetTube_historiesAggregateType<T>>

    /**
     * Group by Tube_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_historiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_historiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_historiesGroupByArgs['orderBy'] }
        : { orderBy?: tube_historiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_historiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_historiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_histories model
   */
  readonly fields: tube_historiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_histories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_historiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends tube_histories$employeesArgs<ExtArgs> = {}>(args?: Subset<T, tube_histories$employeesArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tube_histories_notes<T extends tube_histories$tube_histories_notesArgs<ExtArgs> = {}>(args?: Subset<T, tube_histories$tube_histories_notesArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tube_history_types<T extends tube_histories$tube_history_typesArgs<ExtArgs> = {}>(args?: Subset<T, tube_histories$tube_history_typesArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_histories model
   */
  interface tube_historiesFieldRefs {
    readonly id: FieldRef<"tube_histories", 'Int'>
    readonly tube_record_id: FieldRef<"tube_histories", 'Int'>
    readonly tube_history_type_id: FieldRef<"tube_histories", 'Int'>
    readonly employee_id: FieldRef<"tube_histories", 'Int'>
    readonly note: FieldRef<"tube_histories", 'String'>
    readonly tube_history_note_id: FieldRef<"tube_histories", 'Int'>
    readonly createdAt: FieldRef<"tube_histories", 'DateTime'>
    readonly updatedAt: FieldRef<"tube_histories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tube_histories findUnique
   */
  export type tube_historiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories to fetch.
     */
    where: tube_historiesWhereUniqueInput
  }

  /**
   * tube_histories findUniqueOrThrow
   */
  export type tube_historiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories to fetch.
     */
    where: tube_historiesWhereUniqueInput
  }

  /**
   * tube_histories findFirst
   */
  export type tube_historiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories to fetch.
     */
    where?: tube_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories to fetch.
     */
    orderBy?: tube_historiesOrderByWithRelationInput | tube_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_histories.
     */
    cursor?: tube_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_histories.
     */
    distinct?: Tube_historiesScalarFieldEnum | Tube_historiesScalarFieldEnum[]
  }

  /**
   * tube_histories findFirstOrThrow
   */
  export type tube_historiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories to fetch.
     */
    where?: tube_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories to fetch.
     */
    orderBy?: tube_historiesOrderByWithRelationInput | tube_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_histories.
     */
    cursor?: tube_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_histories.
     */
    distinct?: Tube_historiesScalarFieldEnum | Tube_historiesScalarFieldEnum[]
  }

  /**
   * tube_histories findMany
   */
  export type tube_historiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories to fetch.
     */
    where?: tube_historiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories to fetch.
     */
    orderBy?: tube_historiesOrderByWithRelationInput | tube_historiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_histories.
     */
    cursor?: tube_historiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories.
     */
    skip?: number
    distinct?: Tube_historiesScalarFieldEnum | Tube_historiesScalarFieldEnum[]
  }

  /**
   * tube_histories create
   */
  export type tube_historiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_histories.
     */
    data: XOR<tube_historiesCreateInput, tube_historiesUncheckedCreateInput>
  }

  /**
   * tube_histories createMany
   */
  export type tube_historiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_histories.
     */
    data: tube_historiesCreateManyInput | tube_historiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_histories createManyAndReturn
   */
  export type tube_historiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * The data used to create many tube_histories.
     */
    data: tube_historiesCreateManyInput | tube_historiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_histories update
   */
  export type tube_historiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_histories.
     */
    data: XOR<tube_historiesUpdateInput, tube_historiesUncheckedUpdateInput>
    /**
     * Choose, which tube_histories to update.
     */
    where: tube_historiesWhereUniqueInput
  }

  /**
   * tube_histories updateMany
   */
  export type tube_historiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_histories.
     */
    data: XOR<tube_historiesUpdateManyMutationInput, tube_historiesUncheckedUpdateManyInput>
    /**
     * Filter which tube_histories to update
     */
    where?: tube_historiesWhereInput
    /**
     * Limit how many tube_histories to update.
     */
    limit?: number
  }

  /**
   * tube_histories updateManyAndReturn
   */
  export type tube_historiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * The data used to update tube_histories.
     */
    data: XOR<tube_historiesUpdateManyMutationInput, tube_historiesUncheckedUpdateManyInput>
    /**
     * Filter which tube_histories to update
     */
    where?: tube_historiesWhereInput
    /**
     * Limit how many tube_histories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_histories upsert
   */
  export type tube_historiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_histories to update in case it exists.
     */
    where: tube_historiesWhereUniqueInput
    /**
     * In case the tube_histories found by the `where` argument doesn't exist, create a new tube_histories with this data.
     */
    create: XOR<tube_historiesCreateInput, tube_historiesUncheckedCreateInput>
    /**
     * In case the tube_histories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_historiesUpdateInput, tube_historiesUncheckedUpdateInput>
  }

  /**
   * tube_histories delete
   */
  export type tube_historiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    /**
     * Filter which tube_histories to delete.
     */
    where: tube_historiesWhereUniqueInput
  }

  /**
   * tube_histories deleteMany
   */
  export type tube_historiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_histories to delete
     */
    where?: tube_historiesWhereInput
    /**
     * Limit how many tube_histories to delete.
     */
    limit?: number
  }

  /**
   * tube_histories.employees
   */
  export type tube_histories$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    where?: employeesWhereInput
  }

  /**
   * tube_histories.tube_histories_notes
   */
  export type tube_histories$tube_histories_notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    where?: tube_histories_notesWhereInput
  }

  /**
   * tube_histories.tube_history_types
   */
  export type tube_histories$tube_history_typesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    where?: tube_history_typesWhereInput
  }

  /**
   * tube_histories without action
   */
  export type tube_historiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
  }


  /**
   * Model tube_histories_notes
   */

  export type AggregateTube_histories_notes = {
    _count: Tube_histories_notesCountAggregateOutputType | null
    _avg: Tube_histories_notesAvgAggregateOutputType | null
    _sum: Tube_histories_notesSumAggregateOutputType | null
    _min: Tube_histories_notesMinAggregateOutputType | null
    _max: Tube_histories_notesMaxAggregateOutputType | null
  }

  export type Tube_histories_notesAvgAggregateOutputType = {
    id: number | null
  }

  export type Tube_histories_notesSumAggregateOutputType = {
    id: number | null
  }

  export type Tube_histories_notesMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type Tube_histories_notesMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type Tube_histories_notesCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type Tube_histories_notesAvgAggregateInputType = {
    id?: true
  }

  export type Tube_histories_notesSumAggregateInputType = {
    id?: true
  }

  export type Tube_histories_notesMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type Tube_histories_notesMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type Tube_histories_notesCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type Tube_histories_notesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_histories_notes to aggregate.
     */
    where?: tube_histories_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories_notes to fetch.
     */
    orderBy?: tube_histories_notesOrderByWithRelationInput | tube_histories_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_histories_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_histories_notes
    **/
    _count?: true | Tube_histories_notesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_histories_notesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_histories_notesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_histories_notesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_histories_notesMaxAggregateInputType
  }

  export type GetTube_histories_notesAggregateType<T extends Tube_histories_notesAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_histories_notes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_histories_notes[P]>
      : GetScalarType<T[P], AggregateTube_histories_notes[P]>
  }




  export type tube_histories_notesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_histories_notesWhereInput
    orderBy?: tube_histories_notesOrderByWithAggregationInput | tube_histories_notesOrderByWithAggregationInput[]
    by: Tube_histories_notesScalarFieldEnum[] | Tube_histories_notesScalarFieldEnum
    having?: tube_histories_notesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_histories_notesCountAggregateInputType | true
    _avg?: Tube_histories_notesAvgAggregateInputType
    _sum?: Tube_histories_notesSumAggregateInputType
    _min?: Tube_histories_notesMinAggregateInputType
    _max?: Tube_histories_notesMaxAggregateInputType
  }

  export type Tube_histories_notesGroupByOutputType = {
    id: number
    value: string | null
    _count: Tube_histories_notesCountAggregateOutputType | null
    _avg: Tube_histories_notesAvgAggregateOutputType | null
    _sum: Tube_histories_notesSumAggregateOutputType | null
    _min: Tube_histories_notesMinAggregateOutputType | null
    _max: Tube_histories_notesMaxAggregateOutputType | null
  }

  type GetTube_histories_notesGroupByPayload<T extends tube_histories_notesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_histories_notesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_histories_notesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_histories_notesGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_histories_notesGroupByOutputType[P]>
        }
      >
    >


  export type tube_histories_notesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    tube_histories?: boolean | tube_histories_notes$tube_historiesArgs<ExtArgs>
    _count?: boolean | Tube_histories_notesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tube_histories_notes"]>

  export type tube_histories_notesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["tube_histories_notes"]>

  export type tube_histories_notesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["tube_histories_notes"]>

  export type tube_histories_notesSelectScalar = {
    id?: boolean
    value?: boolean
  }

  export type tube_histories_notesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value", ExtArgs["result"]["tube_histories_notes"]>
  export type tube_histories_notesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_histories?: boolean | tube_histories_notes$tube_historiesArgs<ExtArgs>
    _count?: boolean | Tube_histories_notesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tube_histories_notesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tube_histories_notesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tube_histories_notesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_histories_notes"
    objects: {
      tube_histories: Prisma.$tube_historiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string | null
    }, ExtArgs["result"]["tube_histories_notes"]>
    composites: {}
  }

  type tube_histories_notesGetPayload<S extends boolean | null | undefined | tube_histories_notesDefaultArgs> = $Result.GetResult<Prisma.$tube_histories_notesPayload, S>

  type tube_histories_notesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_histories_notesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_histories_notesCountAggregateInputType | true
    }

  export interface tube_histories_notesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_histories_notes'], meta: { name: 'tube_histories_notes' } }
    /**
     * Find zero or one Tube_histories_notes that matches the filter.
     * @param {tube_histories_notesFindUniqueArgs} args - Arguments to find a Tube_histories_notes
     * @example
     * // Get one Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_histories_notesFindUniqueArgs>(args: SelectSubset<T, tube_histories_notesFindUniqueArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_histories_notes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_histories_notesFindUniqueOrThrowArgs} args - Arguments to find a Tube_histories_notes
     * @example
     * // Get one Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_histories_notesFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_histories_notesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_histories_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_histories_notesFindFirstArgs} args - Arguments to find a Tube_histories_notes
     * @example
     * // Get one Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_histories_notesFindFirstArgs>(args?: SelectSubset<T, tube_histories_notesFindFirstArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_histories_notes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_histories_notesFindFirstOrThrowArgs} args - Arguments to find a Tube_histories_notes
     * @example
     * // Get one Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_histories_notesFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_histories_notesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_histories_notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_histories_notesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.findMany()
     * 
     * // Get first 10 Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_histories_notesWithIdOnly = await prisma.tube_histories_notes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_histories_notesFindManyArgs>(args?: SelectSubset<T, tube_histories_notesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_histories_notes.
     * @param {tube_histories_notesCreateArgs} args - Arguments to create a Tube_histories_notes.
     * @example
     * // Create one Tube_histories_notes
     * const Tube_histories_notes = await prisma.tube_histories_notes.create({
     *   data: {
     *     // ... data to create a Tube_histories_notes
     *   }
     * })
     * 
     */
    create<T extends tube_histories_notesCreateArgs>(args: SelectSubset<T, tube_histories_notesCreateArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_histories_notes.
     * @param {tube_histories_notesCreateManyArgs} args - Arguments to create many Tube_histories_notes.
     * @example
     * // Create many Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_histories_notesCreateManyArgs>(args?: SelectSubset<T, tube_histories_notesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_histories_notes and returns the data saved in the database.
     * @param {tube_histories_notesCreateManyAndReturnArgs} args - Arguments to create many Tube_histories_notes.
     * @example
     * // Create many Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_histories_notes and only return the `id`
     * const tube_histories_notesWithIdOnly = await prisma.tube_histories_notes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_histories_notesCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_histories_notesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_histories_notes.
     * @param {tube_histories_notesDeleteArgs} args - Arguments to delete one Tube_histories_notes.
     * @example
     * // Delete one Tube_histories_notes
     * const Tube_histories_notes = await prisma.tube_histories_notes.delete({
     *   where: {
     *     // ... filter to delete one Tube_histories_notes
     *   }
     * })
     * 
     */
    delete<T extends tube_histories_notesDeleteArgs>(args: SelectSubset<T, tube_histories_notesDeleteArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_histories_notes.
     * @param {tube_histories_notesUpdateArgs} args - Arguments to update one Tube_histories_notes.
     * @example
     * // Update one Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_histories_notesUpdateArgs>(args: SelectSubset<T, tube_histories_notesUpdateArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_histories_notes.
     * @param {tube_histories_notesDeleteManyArgs} args - Arguments to filter Tube_histories_notes to delete.
     * @example
     * // Delete a few Tube_histories_notes
     * const { count } = await prisma.tube_histories_notes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_histories_notesDeleteManyArgs>(args?: SelectSubset<T, tube_histories_notesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_histories_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_histories_notesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_histories_notesUpdateManyArgs>(args: SelectSubset<T, tube_histories_notesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_histories_notes and returns the data updated in the database.
     * @param {tube_histories_notesUpdateManyAndReturnArgs} args - Arguments to update many Tube_histories_notes.
     * @example
     * // Update many Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_histories_notes and only return the `id`
     * const tube_histories_notesWithIdOnly = await prisma.tube_histories_notes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_histories_notesUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_histories_notesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_histories_notes.
     * @param {tube_histories_notesUpsertArgs} args - Arguments to update or create a Tube_histories_notes.
     * @example
     * // Update or create a Tube_histories_notes
     * const tube_histories_notes = await prisma.tube_histories_notes.upsert({
     *   create: {
     *     // ... data to create a Tube_histories_notes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_histories_notes we want to update
     *   }
     * })
     */
    upsert<T extends tube_histories_notesUpsertArgs>(args: SelectSubset<T, tube_histories_notesUpsertArgs<ExtArgs>>): Prisma__tube_histories_notesClient<$Result.GetResult<Prisma.$tube_histories_notesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_histories_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_histories_notesCountArgs} args - Arguments to filter Tube_histories_notes to count.
     * @example
     * // Count the number of Tube_histories_notes
     * const count = await prisma.tube_histories_notes.count({
     *   where: {
     *     // ... the filter for the Tube_histories_notes we want to count
     *   }
     * })
    **/
    count<T extends tube_histories_notesCountArgs>(
      args?: Subset<T, tube_histories_notesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_histories_notesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_histories_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_histories_notesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_histories_notesAggregateArgs>(args: Subset<T, Tube_histories_notesAggregateArgs>): Prisma.PrismaPromise<GetTube_histories_notesAggregateType<T>>

    /**
     * Group by Tube_histories_notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_histories_notesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_histories_notesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_histories_notesGroupByArgs['orderBy'] }
        : { orderBy?: tube_histories_notesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_histories_notesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_histories_notesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_histories_notes model
   */
  readonly fields: tube_histories_notesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_histories_notes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_histories_notesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_histories<T extends tube_histories_notes$tube_historiesArgs<ExtArgs> = {}>(args?: Subset<T, tube_histories_notes$tube_historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_histories_notes model
   */
  interface tube_histories_notesFieldRefs {
    readonly id: FieldRef<"tube_histories_notes", 'Int'>
    readonly value: FieldRef<"tube_histories_notes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tube_histories_notes findUnique
   */
  export type tube_histories_notesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories_notes to fetch.
     */
    where: tube_histories_notesWhereUniqueInput
  }

  /**
   * tube_histories_notes findUniqueOrThrow
   */
  export type tube_histories_notesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories_notes to fetch.
     */
    where: tube_histories_notesWhereUniqueInput
  }

  /**
   * tube_histories_notes findFirst
   */
  export type tube_histories_notesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories_notes to fetch.
     */
    where?: tube_histories_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories_notes to fetch.
     */
    orderBy?: tube_histories_notesOrderByWithRelationInput | tube_histories_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_histories_notes.
     */
    cursor?: tube_histories_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_histories_notes.
     */
    distinct?: Tube_histories_notesScalarFieldEnum | Tube_histories_notesScalarFieldEnum[]
  }

  /**
   * tube_histories_notes findFirstOrThrow
   */
  export type tube_histories_notesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories_notes to fetch.
     */
    where?: tube_histories_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories_notes to fetch.
     */
    orderBy?: tube_histories_notesOrderByWithRelationInput | tube_histories_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_histories_notes.
     */
    cursor?: tube_histories_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories_notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_histories_notes.
     */
    distinct?: Tube_histories_notesScalarFieldEnum | Tube_histories_notesScalarFieldEnum[]
  }

  /**
   * tube_histories_notes findMany
   */
  export type tube_histories_notesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * Filter, which tube_histories_notes to fetch.
     */
    where?: tube_histories_notesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_histories_notes to fetch.
     */
    orderBy?: tube_histories_notesOrderByWithRelationInput | tube_histories_notesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_histories_notes.
     */
    cursor?: tube_histories_notesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_histories_notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_histories_notes.
     */
    skip?: number
    distinct?: Tube_histories_notesScalarFieldEnum | Tube_histories_notesScalarFieldEnum[]
  }

  /**
   * tube_histories_notes create
   */
  export type tube_histories_notesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_histories_notes.
     */
    data?: XOR<tube_histories_notesCreateInput, tube_histories_notesUncheckedCreateInput>
  }

  /**
   * tube_histories_notes createMany
   */
  export type tube_histories_notesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_histories_notes.
     */
    data: tube_histories_notesCreateManyInput | tube_histories_notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_histories_notes createManyAndReturn
   */
  export type tube_histories_notesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * The data used to create many tube_histories_notes.
     */
    data: tube_histories_notesCreateManyInput | tube_histories_notesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_histories_notes update
   */
  export type tube_histories_notesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_histories_notes.
     */
    data: XOR<tube_histories_notesUpdateInput, tube_histories_notesUncheckedUpdateInput>
    /**
     * Choose, which tube_histories_notes to update.
     */
    where: tube_histories_notesWhereUniqueInput
  }

  /**
   * tube_histories_notes updateMany
   */
  export type tube_histories_notesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_histories_notes.
     */
    data: XOR<tube_histories_notesUpdateManyMutationInput, tube_histories_notesUncheckedUpdateManyInput>
    /**
     * Filter which tube_histories_notes to update
     */
    where?: tube_histories_notesWhereInput
    /**
     * Limit how many tube_histories_notes to update.
     */
    limit?: number
  }

  /**
   * tube_histories_notes updateManyAndReturn
   */
  export type tube_histories_notesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * The data used to update tube_histories_notes.
     */
    data: XOR<tube_histories_notesUpdateManyMutationInput, tube_histories_notesUncheckedUpdateManyInput>
    /**
     * Filter which tube_histories_notes to update
     */
    where?: tube_histories_notesWhereInput
    /**
     * Limit how many tube_histories_notes to update.
     */
    limit?: number
  }

  /**
   * tube_histories_notes upsert
   */
  export type tube_histories_notesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_histories_notes to update in case it exists.
     */
    where: tube_histories_notesWhereUniqueInput
    /**
     * In case the tube_histories_notes found by the `where` argument doesn't exist, create a new tube_histories_notes with this data.
     */
    create: XOR<tube_histories_notesCreateInput, tube_histories_notesUncheckedCreateInput>
    /**
     * In case the tube_histories_notes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_histories_notesUpdateInput, tube_histories_notesUncheckedUpdateInput>
  }

  /**
   * tube_histories_notes delete
   */
  export type tube_histories_notesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
    /**
     * Filter which tube_histories_notes to delete.
     */
    where: tube_histories_notesWhereUniqueInput
  }

  /**
   * tube_histories_notes deleteMany
   */
  export type tube_histories_notesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_histories_notes to delete
     */
    where?: tube_histories_notesWhereInput
    /**
     * Limit how many tube_histories_notes to delete.
     */
    limit?: number
  }

  /**
   * tube_histories_notes.tube_histories
   */
  export type tube_histories_notes$tube_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    where?: tube_historiesWhereInput
    orderBy?: tube_historiesOrderByWithRelationInput | tube_historiesOrderByWithRelationInput[]
    cursor?: tube_historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_historiesScalarFieldEnum | Tube_historiesScalarFieldEnum[]
  }

  /**
   * tube_histories_notes without action
   */
  export type tube_histories_notesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories_notes
     */
    select?: tube_histories_notesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories_notes
     */
    omit?: tube_histories_notesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_histories_notesInclude<ExtArgs> | null
  }


  /**
   * Model tube_history_types
   */

  export type AggregateTube_history_types = {
    _count: Tube_history_typesCountAggregateOutputType | null
    _avg: Tube_history_typesAvgAggregateOutputType | null
    _sum: Tube_history_typesSumAggregateOutputType | null
    _min: Tube_history_typesMinAggregateOutputType | null
    _max: Tube_history_typesMaxAggregateOutputType | null
  }

  export type Tube_history_typesAvgAggregateOutputType = {
    id: number | null
  }

  export type Tube_history_typesSumAggregateOutputType = {
    id: number | null
  }

  export type Tube_history_typesMinAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type Tube_history_typesMaxAggregateOutputType = {
    id: number | null
    value: string | null
    description: string | null
  }

  export type Tube_history_typesCountAggregateOutputType = {
    id: number
    value: number
    description: number
    _all: number
  }


  export type Tube_history_typesAvgAggregateInputType = {
    id?: true
  }

  export type Tube_history_typesSumAggregateInputType = {
    id?: true
  }

  export type Tube_history_typesMinAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type Tube_history_typesMaxAggregateInputType = {
    id?: true
    value?: true
    description?: true
  }

  export type Tube_history_typesCountAggregateInputType = {
    id?: true
    value?: true
    description?: true
    _all?: true
  }

  export type Tube_history_typesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_history_types to aggregate.
     */
    where?: tube_history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_history_types to fetch.
     */
    orderBy?: tube_history_typesOrderByWithRelationInput | tube_history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_history_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_history_types
    **/
    _count?: true | Tube_history_typesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_history_typesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_history_typesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_history_typesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_history_typesMaxAggregateInputType
  }

  export type GetTube_history_typesAggregateType<T extends Tube_history_typesAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_history_types]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_history_types[P]>
      : GetScalarType<T[P], AggregateTube_history_types[P]>
  }




  export type tube_history_typesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_history_typesWhereInput
    orderBy?: tube_history_typesOrderByWithAggregationInput | tube_history_typesOrderByWithAggregationInput[]
    by: Tube_history_typesScalarFieldEnum[] | Tube_history_typesScalarFieldEnum
    having?: tube_history_typesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_history_typesCountAggregateInputType | true
    _avg?: Tube_history_typesAvgAggregateInputType
    _sum?: Tube_history_typesSumAggregateInputType
    _min?: Tube_history_typesMinAggregateInputType
    _max?: Tube_history_typesMaxAggregateInputType
  }

  export type Tube_history_typesGroupByOutputType = {
    id: number
    value: string
    description: string
    _count: Tube_history_typesCountAggregateOutputType | null
    _avg: Tube_history_typesAvgAggregateOutputType | null
    _sum: Tube_history_typesSumAggregateOutputType | null
    _min: Tube_history_typesMinAggregateOutputType | null
    _max: Tube_history_typesMaxAggregateOutputType | null
  }

  type GetTube_history_typesGroupByPayload<T extends tube_history_typesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_history_typesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_history_typesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_history_typesGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_history_typesGroupByOutputType[P]>
        }
      >
    >


  export type tube_history_typesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
    tube_histories?: boolean | tube_history_types$tube_historiesArgs<ExtArgs>
    _count?: boolean | Tube_history_typesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tube_history_types"]>

  export type tube_history_typesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["tube_history_types"]>

  export type tube_history_typesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    description?: boolean
  }, ExtArgs["result"]["tube_history_types"]>

  export type tube_history_typesSelectScalar = {
    id?: boolean
    value?: boolean
    description?: boolean
  }

  export type tube_history_typesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value" | "description", ExtArgs["result"]["tube_history_types"]>
  export type tube_history_typesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_histories?: boolean | tube_history_types$tube_historiesArgs<ExtArgs>
    _count?: boolean | Tube_history_typesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tube_history_typesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tube_history_typesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tube_history_typesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_history_types"
    objects: {
      tube_histories: Prisma.$tube_historiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
      description: string
    }, ExtArgs["result"]["tube_history_types"]>
    composites: {}
  }

  type tube_history_typesGetPayload<S extends boolean | null | undefined | tube_history_typesDefaultArgs> = $Result.GetResult<Prisma.$tube_history_typesPayload, S>

  type tube_history_typesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_history_typesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_history_typesCountAggregateInputType | true
    }

  export interface tube_history_typesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_history_types'], meta: { name: 'tube_history_types' } }
    /**
     * Find zero or one Tube_history_types that matches the filter.
     * @param {tube_history_typesFindUniqueArgs} args - Arguments to find a Tube_history_types
     * @example
     * // Get one Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_history_typesFindUniqueArgs>(args: SelectSubset<T, tube_history_typesFindUniqueArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_history_types that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_history_typesFindUniqueOrThrowArgs} args - Arguments to find a Tube_history_types
     * @example
     * // Get one Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_history_typesFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_history_typesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_history_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_history_typesFindFirstArgs} args - Arguments to find a Tube_history_types
     * @example
     * // Get one Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_history_typesFindFirstArgs>(args?: SelectSubset<T, tube_history_typesFindFirstArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_history_types that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_history_typesFindFirstOrThrowArgs} args - Arguments to find a Tube_history_types
     * @example
     * // Get one Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_history_typesFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_history_typesFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_history_types that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_history_typesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.findMany()
     * 
     * // Get first 10 Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_history_typesWithIdOnly = await prisma.tube_history_types.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_history_typesFindManyArgs>(args?: SelectSubset<T, tube_history_typesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_history_types.
     * @param {tube_history_typesCreateArgs} args - Arguments to create a Tube_history_types.
     * @example
     * // Create one Tube_history_types
     * const Tube_history_types = await prisma.tube_history_types.create({
     *   data: {
     *     // ... data to create a Tube_history_types
     *   }
     * })
     * 
     */
    create<T extends tube_history_typesCreateArgs>(args: SelectSubset<T, tube_history_typesCreateArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_history_types.
     * @param {tube_history_typesCreateManyArgs} args - Arguments to create many Tube_history_types.
     * @example
     * // Create many Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_history_typesCreateManyArgs>(args?: SelectSubset<T, tube_history_typesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_history_types and returns the data saved in the database.
     * @param {tube_history_typesCreateManyAndReturnArgs} args - Arguments to create many Tube_history_types.
     * @example
     * // Create many Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_history_types and only return the `id`
     * const tube_history_typesWithIdOnly = await prisma.tube_history_types.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_history_typesCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_history_typesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_history_types.
     * @param {tube_history_typesDeleteArgs} args - Arguments to delete one Tube_history_types.
     * @example
     * // Delete one Tube_history_types
     * const Tube_history_types = await prisma.tube_history_types.delete({
     *   where: {
     *     // ... filter to delete one Tube_history_types
     *   }
     * })
     * 
     */
    delete<T extends tube_history_typesDeleteArgs>(args: SelectSubset<T, tube_history_typesDeleteArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_history_types.
     * @param {tube_history_typesUpdateArgs} args - Arguments to update one Tube_history_types.
     * @example
     * // Update one Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_history_typesUpdateArgs>(args: SelectSubset<T, tube_history_typesUpdateArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_history_types.
     * @param {tube_history_typesDeleteManyArgs} args - Arguments to filter Tube_history_types to delete.
     * @example
     * // Delete a few Tube_history_types
     * const { count } = await prisma.tube_history_types.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_history_typesDeleteManyArgs>(args?: SelectSubset<T, tube_history_typesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_history_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_history_typesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_history_typesUpdateManyArgs>(args: SelectSubset<T, tube_history_typesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_history_types and returns the data updated in the database.
     * @param {tube_history_typesUpdateManyAndReturnArgs} args - Arguments to update many Tube_history_types.
     * @example
     * // Update many Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_history_types and only return the `id`
     * const tube_history_typesWithIdOnly = await prisma.tube_history_types.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_history_typesUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_history_typesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_history_types.
     * @param {tube_history_typesUpsertArgs} args - Arguments to update or create a Tube_history_types.
     * @example
     * // Update or create a Tube_history_types
     * const tube_history_types = await prisma.tube_history_types.upsert({
     *   create: {
     *     // ... data to create a Tube_history_types
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_history_types we want to update
     *   }
     * })
     */
    upsert<T extends tube_history_typesUpsertArgs>(args: SelectSubset<T, tube_history_typesUpsertArgs<ExtArgs>>): Prisma__tube_history_typesClient<$Result.GetResult<Prisma.$tube_history_typesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_history_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_history_typesCountArgs} args - Arguments to filter Tube_history_types to count.
     * @example
     * // Count the number of Tube_history_types
     * const count = await prisma.tube_history_types.count({
     *   where: {
     *     // ... the filter for the Tube_history_types we want to count
     *   }
     * })
    **/
    count<T extends tube_history_typesCountArgs>(
      args?: Subset<T, tube_history_typesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_history_typesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_history_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_history_typesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_history_typesAggregateArgs>(args: Subset<T, Tube_history_typesAggregateArgs>): Prisma.PrismaPromise<GetTube_history_typesAggregateType<T>>

    /**
     * Group by Tube_history_types.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_history_typesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_history_typesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_history_typesGroupByArgs['orderBy'] }
        : { orderBy?: tube_history_typesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_history_typesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_history_typesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_history_types model
   */
  readonly fields: tube_history_typesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_history_types.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_history_typesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_histories<T extends tube_history_types$tube_historiesArgs<ExtArgs> = {}>(args?: Subset<T, tube_history_types$tube_historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_history_types model
   */
  interface tube_history_typesFieldRefs {
    readonly id: FieldRef<"tube_history_types", 'Int'>
    readonly value: FieldRef<"tube_history_types", 'String'>
    readonly description: FieldRef<"tube_history_types", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tube_history_types findUnique
   */
  export type tube_history_typesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * Filter, which tube_history_types to fetch.
     */
    where: tube_history_typesWhereUniqueInput
  }

  /**
   * tube_history_types findUniqueOrThrow
   */
  export type tube_history_typesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * Filter, which tube_history_types to fetch.
     */
    where: tube_history_typesWhereUniqueInput
  }

  /**
   * tube_history_types findFirst
   */
  export type tube_history_typesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * Filter, which tube_history_types to fetch.
     */
    where?: tube_history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_history_types to fetch.
     */
    orderBy?: tube_history_typesOrderByWithRelationInput | tube_history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_history_types.
     */
    cursor?: tube_history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_history_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_history_types.
     */
    distinct?: Tube_history_typesScalarFieldEnum | Tube_history_typesScalarFieldEnum[]
  }

  /**
   * tube_history_types findFirstOrThrow
   */
  export type tube_history_typesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * Filter, which tube_history_types to fetch.
     */
    where?: tube_history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_history_types to fetch.
     */
    orderBy?: tube_history_typesOrderByWithRelationInput | tube_history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_history_types.
     */
    cursor?: tube_history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_history_types.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_history_types.
     */
    distinct?: Tube_history_typesScalarFieldEnum | Tube_history_typesScalarFieldEnum[]
  }

  /**
   * tube_history_types findMany
   */
  export type tube_history_typesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * Filter, which tube_history_types to fetch.
     */
    where?: tube_history_typesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_history_types to fetch.
     */
    orderBy?: tube_history_typesOrderByWithRelationInput | tube_history_typesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_history_types.
     */
    cursor?: tube_history_typesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_history_types from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_history_types.
     */
    skip?: number
    distinct?: Tube_history_typesScalarFieldEnum | Tube_history_typesScalarFieldEnum[]
  }

  /**
   * tube_history_types create
   */
  export type tube_history_typesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_history_types.
     */
    data: XOR<tube_history_typesCreateInput, tube_history_typesUncheckedCreateInput>
  }

  /**
   * tube_history_types createMany
   */
  export type tube_history_typesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_history_types.
     */
    data: tube_history_typesCreateManyInput | tube_history_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_history_types createManyAndReturn
   */
  export type tube_history_typesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * The data used to create many tube_history_types.
     */
    data: tube_history_typesCreateManyInput | tube_history_typesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_history_types update
   */
  export type tube_history_typesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_history_types.
     */
    data: XOR<tube_history_typesUpdateInput, tube_history_typesUncheckedUpdateInput>
    /**
     * Choose, which tube_history_types to update.
     */
    where: tube_history_typesWhereUniqueInput
  }

  /**
   * tube_history_types updateMany
   */
  export type tube_history_typesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_history_types.
     */
    data: XOR<tube_history_typesUpdateManyMutationInput, tube_history_typesUncheckedUpdateManyInput>
    /**
     * Filter which tube_history_types to update
     */
    where?: tube_history_typesWhereInput
    /**
     * Limit how many tube_history_types to update.
     */
    limit?: number
  }

  /**
   * tube_history_types updateManyAndReturn
   */
  export type tube_history_typesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * The data used to update tube_history_types.
     */
    data: XOR<tube_history_typesUpdateManyMutationInput, tube_history_typesUncheckedUpdateManyInput>
    /**
     * Filter which tube_history_types to update
     */
    where?: tube_history_typesWhereInput
    /**
     * Limit how many tube_history_types to update.
     */
    limit?: number
  }

  /**
   * tube_history_types upsert
   */
  export type tube_history_typesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_history_types to update in case it exists.
     */
    where: tube_history_typesWhereUniqueInput
    /**
     * In case the tube_history_types found by the `where` argument doesn't exist, create a new tube_history_types with this data.
     */
    create: XOR<tube_history_typesCreateInput, tube_history_typesUncheckedCreateInput>
    /**
     * In case the tube_history_types was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_history_typesUpdateInput, tube_history_typesUncheckedUpdateInput>
  }

  /**
   * tube_history_types delete
   */
  export type tube_history_typesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
    /**
     * Filter which tube_history_types to delete.
     */
    where: tube_history_typesWhereUniqueInput
  }

  /**
   * tube_history_types deleteMany
   */
  export type tube_history_typesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_history_types to delete
     */
    where?: tube_history_typesWhereInput
    /**
     * Limit how many tube_history_types to delete.
     */
    limit?: number
  }

  /**
   * tube_history_types.tube_histories
   */
  export type tube_history_types$tube_historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_histories
     */
    select?: tube_historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_histories
     */
    omit?: tube_historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_historiesInclude<ExtArgs> | null
    where?: tube_historiesWhereInput
    orderBy?: tube_historiesOrderByWithRelationInput | tube_historiesOrderByWithRelationInput[]
    cursor?: tube_historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_historiesScalarFieldEnum | Tube_historiesScalarFieldEnum[]
  }

  /**
   * tube_history_types without action
   */
  export type tube_history_typesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_history_types
     */
    select?: tube_history_typesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_history_types
     */
    omit?: tube_history_typesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_history_typesInclude<ExtArgs> | null
  }


  /**
   * Model tube_materials
   */

  export type AggregateTube_materials = {
    _count: Tube_materialsCountAggregateOutputType | null
    _avg: Tube_materialsAvgAggregateOutputType | null
    _sum: Tube_materialsSumAggregateOutputType | null
    _min: Tube_materialsMinAggregateOutputType | null
    _max: Tube_materialsMaxAggregateOutputType | null
  }

  export type Tube_materialsAvgAggregateOutputType = {
    id: number | null
  }

  export type Tube_materialsSumAggregateOutputType = {
    id: number | null
  }

  export type Tube_materialsMinAggregateOutputType = {
    id: number | null
    code_1C: string | null
    name: string | null
  }

  export type Tube_materialsMaxAggregateOutputType = {
    id: number | null
    code_1C: string | null
    name: string | null
  }

  export type Tube_materialsCountAggregateOutputType = {
    id: number
    code_1C: number
    name: number
    _all: number
  }


  export type Tube_materialsAvgAggregateInputType = {
    id?: true
  }

  export type Tube_materialsSumAggregateInputType = {
    id?: true
  }

  export type Tube_materialsMinAggregateInputType = {
    id?: true
    code_1C?: true
    name?: true
  }

  export type Tube_materialsMaxAggregateInputType = {
    id?: true
    code_1C?: true
    name?: true
  }

  export type Tube_materialsCountAggregateInputType = {
    id?: true
    code_1C?: true
    name?: true
    _all?: true
  }

  export type Tube_materialsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_materials to aggregate.
     */
    where?: tube_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_materials to fetch.
     */
    orderBy?: tube_materialsOrderByWithRelationInput | tube_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_materials
    **/
    _count?: true | Tube_materialsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_materialsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_materialsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_materialsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_materialsMaxAggregateInputType
  }

  export type GetTube_materialsAggregateType<T extends Tube_materialsAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_materials]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_materials[P]>
      : GetScalarType<T[P], AggregateTube_materials[P]>
  }




  export type tube_materialsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_materialsWhereInput
    orderBy?: tube_materialsOrderByWithAggregationInput | tube_materialsOrderByWithAggregationInput[]
    by: Tube_materialsScalarFieldEnum[] | Tube_materialsScalarFieldEnum
    having?: tube_materialsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_materialsCountAggregateInputType | true
    _avg?: Tube_materialsAvgAggregateInputType
    _sum?: Tube_materialsSumAggregateInputType
    _min?: Tube_materialsMinAggregateInputType
    _max?: Tube_materialsMaxAggregateInputType
  }

  export type Tube_materialsGroupByOutputType = {
    id: number
    code_1C: string | null
    name: string | null
    _count: Tube_materialsCountAggregateOutputType | null
    _avg: Tube_materialsAvgAggregateOutputType | null
    _sum: Tube_materialsSumAggregateOutputType | null
    _min: Tube_materialsMinAggregateOutputType | null
    _max: Tube_materialsMaxAggregateOutputType | null
  }

  type GetTube_materialsGroupByPayload<T extends tube_materialsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_materialsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_materialsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_materialsGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_materialsGroupByOutputType[P]>
        }
      >
    >


  export type tube_materialsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code_1C?: boolean
    name?: boolean
    tube_assembly?: boolean | tube_materials$tube_assemblyArgs<ExtArgs>
    tube_specifications?: boolean | tube_materials$tube_specificationsArgs<ExtArgs>
    _count?: boolean | Tube_materialsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tube_materials"]>

  export type tube_materialsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code_1C?: boolean
    name?: boolean
  }, ExtArgs["result"]["tube_materials"]>

  export type tube_materialsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code_1C?: boolean
    name?: boolean
  }, ExtArgs["result"]["tube_materials"]>

  export type tube_materialsSelectScalar = {
    id?: boolean
    code_1C?: boolean
    name?: boolean
  }

  export type tube_materialsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code_1C" | "name", ExtArgs["result"]["tube_materials"]>
  export type tube_materialsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_assembly?: boolean | tube_materials$tube_assemblyArgs<ExtArgs>
    tube_specifications?: boolean | tube_materials$tube_specificationsArgs<ExtArgs>
    _count?: boolean | Tube_materialsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tube_materialsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tube_materialsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tube_materialsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_materials"
    objects: {
      tube_assembly: Prisma.$tube_assemblyPayload<ExtArgs>[]
      tube_specifications: Prisma.$tube_specificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code_1C: string | null
      name: string | null
    }, ExtArgs["result"]["tube_materials"]>
    composites: {}
  }

  type tube_materialsGetPayload<S extends boolean | null | undefined | tube_materialsDefaultArgs> = $Result.GetResult<Prisma.$tube_materialsPayload, S>

  type tube_materialsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_materialsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_materialsCountAggregateInputType | true
    }

  export interface tube_materialsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_materials'], meta: { name: 'tube_materials' } }
    /**
     * Find zero or one Tube_materials that matches the filter.
     * @param {tube_materialsFindUniqueArgs} args - Arguments to find a Tube_materials
     * @example
     * // Get one Tube_materials
     * const tube_materials = await prisma.tube_materials.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_materialsFindUniqueArgs>(args: SelectSubset<T, tube_materialsFindUniqueArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_materials that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_materialsFindUniqueOrThrowArgs} args - Arguments to find a Tube_materials
     * @example
     * // Get one Tube_materials
     * const tube_materials = await prisma.tube_materials.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_materialsFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_materialsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_materialsFindFirstArgs} args - Arguments to find a Tube_materials
     * @example
     * // Get one Tube_materials
     * const tube_materials = await prisma.tube_materials.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_materialsFindFirstArgs>(args?: SelectSubset<T, tube_materialsFindFirstArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_materials that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_materialsFindFirstOrThrowArgs} args - Arguments to find a Tube_materials
     * @example
     * // Get one Tube_materials
     * const tube_materials = await prisma.tube_materials.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_materialsFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_materialsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_materialsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_materials
     * const tube_materials = await prisma.tube_materials.findMany()
     * 
     * // Get first 10 Tube_materials
     * const tube_materials = await prisma.tube_materials.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_materialsWithIdOnly = await prisma.tube_materials.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_materialsFindManyArgs>(args?: SelectSubset<T, tube_materialsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_materials.
     * @param {tube_materialsCreateArgs} args - Arguments to create a Tube_materials.
     * @example
     * // Create one Tube_materials
     * const Tube_materials = await prisma.tube_materials.create({
     *   data: {
     *     // ... data to create a Tube_materials
     *   }
     * })
     * 
     */
    create<T extends tube_materialsCreateArgs>(args: SelectSubset<T, tube_materialsCreateArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_materials.
     * @param {tube_materialsCreateManyArgs} args - Arguments to create many Tube_materials.
     * @example
     * // Create many Tube_materials
     * const tube_materials = await prisma.tube_materials.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_materialsCreateManyArgs>(args?: SelectSubset<T, tube_materialsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_materials and returns the data saved in the database.
     * @param {tube_materialsCreateManyAndReturnArgs} args - Arguments to create many Tube_materials.
     * @example
     * // Create many Tube_materials
     * const tube_materials = await prisma.tube_materials.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_materials and only return the `id`
     * const tube_materialsWithIdOnly = await prisma.tube_materials.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_materialsCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_materialsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_materials.
     * @param {tube_materialsDeleteArgs} args - Arguments to delete one Tube_materials.
     * @example
     * // Delete one Tube_materials
     * const Tube_materials = await prisma.tube_materials.delete({
     *   where: {
     *     // ... filter to delete one Tube_materials
     *   }
     * })
     * 
     */
    delete<T extends tube_materialsDeleteArgs>(args: SelectSubset<T, tube_materialsDeleteArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_materials.
     * @param {tube_materialsUpdateArgs} args - Arguments to update one Tube_materials.
     * @example
     * // Update one Tube_materials
     * const tube_materials = await prisma.tube_materials.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_materialsUpdateArgs>(args: SelectSubset<T, tube_materialsUpdateArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_materials.
     * @param {tube_materialsDeleteManyArgs} args - Arguments to filter Tube_materials to delete.
     * @example
     * // Delete a few Tube_materials
     * const { count } = await prisma.tube_materials.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_materialsDeleteManyArgs>(args?: SelectSubset<T, tube_materialsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_materialsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_materials
     * const tube_materials = await prisma.tube_materials.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_materialsUpdateManyArgs>(args: SelectSubset<T, tube_materialsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_materials and returns the data updated in the database.
     * @param {tube_materialsUpdateManyAndReturnArgs} args - Arguments to update many Tube_materials.
     * @example
     * // Update many Tube_materials
     * const tube_materials = await prisma.tube_materials.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_materials and only return the `id`
     * const tube_materialsWithIdOnly = await prisma.tube_materials.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_materialsUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_materialsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_materials.
     * @param {tube_materialsUpsertArgs} args - Arguments to update or create a Tube_materials.
     * @example
     * // Update or create a Tube_materials
     * const tube_materials = await prisma.tube_materials.upsert({
     *   create: {
     *     // ... data to create a Tube_materials
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_materials we want to update
     *   }
     * })
     */
    upsert<T extends tube_materialsUpsertArgs>(args: SelectSubset<T, tube_materialsUpsertArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_materialsCountArgs} args - Arguments to filter Tube_materials to count.
     * @example
     * // Count the number of Tube_materials
     * const count = await prisma.tube_materials.count({
     *   where: {
     *     // ... the filter for the Tube_materials we want to count
     *   }
     * })
    **/
    count<T extends tube_materialsCountArgs>(
      args?: Subset<T, tube_materialsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_materialsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_materialsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_materialsAggregateArgs>(args: Subset<T, Tube_materialsAggregateArgs>): Prisma.PrismaPromise<GetTube_materialsAggregateType<T>>

    /**
     * Group by Tube_materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_materialsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_materialsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_materialsGroupByArgs['orderBy'] }
        : { orderBy?: tube_materialsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_materialsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_materialsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_materials model
   */
  readonly fields: tube_materialsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_materials.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_materialsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_assembly<T extends tube_materials$tube_assemblyArgs<ExtArgs> = {}>(args?: Subset<T, tube_materials$tube_assemblyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_assemblyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tube_specifications<T extends tube_materials$tube_specificationsArgs<ExtArgs> = {}>(args?: Subset<T, tube_materials$tube_specificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_materials model
   */
  interface tube_materialsFieldRefs {
    readonly id: FieldRef<"tube_materials", 'Int'>
    readonly code_1C: FieldRef<"tube_materials", 'String'>
    readonly name: FieldRef<"tube_materials", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tube_materials findUnique
   */
  export type tube_materialsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * Filter, which tube_materials to fetch.
     */
    where: tube_materialsWhereUniqueInput
  }

  /**
   * tube_materials findUniqueOrThrow
   */
  export type tube_materialsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * Filter, which tube_materials to fetch.
     */
    where: tube_materialsWhereUniqueInput
  }

  /**
   * tube_materials findFirst
   */
  export type tube_materialsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * Filter, which tube_materials to fetch.
     */
    where?: tube_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_materials to fetch.
     */
    orderBy?: tube_materialsOrderByWithRelationInput | tube_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_materials.
     */
    cursor?: tube_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_materials.
     */
    distinct?: Tube_materialsScalarFieldEnum | Tube_materialsScalarFieldEnum[]
  }

  /**
   * tube_materials findFirstOrThrow
   */
  export type tube_materialsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * Filter, which tube_materials to fetch.
     */
    where?: tube_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_materials to fetch.
     */
    orderBy?: tube_materialsOrderByWithRelationInput | tube_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_materials.
     */
    cursor?: tube_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_materials.
     */
    distinct?: Tube_materialsScalarFieldEnum | Tube_materialsScalarFieldEnum[]
  }

  /**
   * tube_materials findMany
   */
  export type tube_materialsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * Filter, which tube_materials to fetch.
     */
    where?: tube_materialsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_materials to fetch.
     */
    orderBy?: tube_materialsOrderByWithRelationInput | tube_materialsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_materials.
     */
    cursor?: tube_materialsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_materials.
     */
    skip?: number
    distinct?: Tube_materialsScalarFieldEnum | Tube_materialsScalarFieldEnum[]
  }

  /**
   * tube_materials create
   */
  export type tube_materialsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_materials.
     */
    data?: XOR<tube_materialsCreateInput, tube_materialsUncheckedCreateInput>
  }

  /**
   * tube_materials createMany
   */
  export type tube_materialsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_materials.
     */
    data: tube_materialsCreateManyInput | tube_materialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_materials createManyAndReturn
   */
  export type tube_materialsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * The data used to create many tube_materials.
     */
    data: tube_materialsCreateManyInput | tube_materialsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_materials update
   */
  export type tube_materialsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_materials.
     */
    data: XOR<tube_materialsUpdateInput, tube_materialsUncheckedUpdateInput>
    /**
     * Choose, which tube_materials to update.
     */
    where: tube_materialsWhereUniqueInput
  }

  /**
   * tube_materials updateMany
   */
  export type tube_materialsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_materials.
     */
    data: XOR<tube_materialsUpdateManyMutationInput, tube_materialsUncheckedUpdateManyInput>
    /**
     * Filter which tube_materials to update
     */
    where?: tube_materialsWhereInput
    /**
     * Limit how many tube_materials to update.
     */
    limit?: number
  }

  /**
   * tube_materials updateManyAndReturn
   */
  export type tube_materialsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * The data used to update tube_materials.
     */
    data: XOR<tube_materialsUpdateManyMutationInput, tube_materialsUncheckedUpdateManyInput>
    /**
     * Filter which tube_materials to update
     */
    where?: tube_materialsWhereInput
    /**
     * Limit how many tube_materials to update.
     */
    limit?: number
  }

  /**
   * tube_materials upsert
   */
  export type tube_materialsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_materials to update in case it exists.
     */
    where: tube_materialsWhereUniqueInput
    /**
     * In case the tube_materials found by the `where` argument doesn't exist, create a new tube_materials with this data.
     */
    create: XOR<tube_materialsCreateInput, tube_materialsUncheckedCreateInput>
    /**
     * In case the tube_materials was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_materialsUpdateInput, tube_materialsUncheckedUpdateInput>
  }

  /**
   * tube_materials delete
   */
  export type tube_materialsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    /**
     * Filter which tube_materials to delete.
     */
    where: tube_materialsWhereUniqueInput
  }

  /**
   * tube_materials deleteMany
   */
  export type tube_materialsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_materials to delete
     */
    where?: tube_materialsWhereInput
    /**
     * Limit how many tube_materials to delete.
     */
    limit?: number
  }

  /**
   * tube_materials.tube_assembly
   */
  export type tube_materials$tube_assemblyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_assembly
     */
    select?: tube_assemblySelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_assembly
     */
    omit?: tube_assemblyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_assemblyInclude<ExtArgs> | null
    where?: tube_assemblyWhereInput
    orderBy?: tube_assemblyOrderByWithRelationInput | tube_assemblyOrderByWithRelationInput[]
    cursor?: tube_assemblyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_assemblyScalarFieldEnum | Tube_assemblyScalarFieldEnum[]
  }

  /**
   * tube_materials.tube_specifications
   */
  export type tube_materials$tube_specificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    where?: tube_specificationsWhereInput
    orderBy?: tube_specificationsOrderByWithRelationInput | tube_specificationsOrderByWithRelationInput[]
    cursor?: tube_specificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_specificationsScalarFieldEnum | Tube_specificationsScalarFieldEnum[]
  }

  /**
   * tube_materials without action
   */
  export type tube_materialsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
  }


  /**
   * Model tube_parameters
   */

  export type AggregateTube_parameters = {
    _count: Tube_parametersCountAggregateOutputType | null
    _avg: Tube_parametersAvgAggregateOutputType | null
    _sum: Tube_parametersSumAggregateOutputType | null
    _min: Tube_parametersMinAggregateOutputType | null
    _max: Tube_parametersMaxAggregateOutputType | null
  }

  export type Tube_parametersAvgAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    press_speed_min: number | null
    press_speed_max: number | null
    molding_time_min: number | null
    molding_time_max: number | null
    turning_automate_speed_min: number | null
    turning_automate_speed_max: number | null
    annealing_furnace_temp_min: number | null
    annealing_furnace_temp_max: number | null
    cap_machine_speed_min: number | null
    cap_machine_speed_max: number | null
    cap_machine_air_pressure_min: number | null
    cap_machine_air_pressure_max: number | null
    grips_forward_min: number | null
    grips_forward_max: number | null
    grips_opening_left_min: number | null
    grips_opening_left_max: number | null
    grips_opening_right_min: number | null
    grips_opening_right_max: number | null
    grips_closing_min: number | null
    grips_closing_max: number | null
    injection_start_min: number | null
    injection_start_max: number | null
    injection_end_min: number | null
    injection_end_max: number | null
    tube_start_position_min: number | null
    tube_start_position_max: number | null
    tube_end_position_min: number | null
    tube_end_position_max: number | null
    padding_machine_speed_min: number | null
    padding_machine_speed_max: number | null
    padding_machine_air_pressure_min: number | null
    padding_machine_air_pressure_max: number | null
    padding_furnace_temp_min: number | null
    padding_furnace_temp_max: number | null
    offset_furnace_temp_min: number | null
    offset_furnace_temp_max: number | null
    printer_motor_speed_min: number | null
    printer_motor_speed_max: number | null
    holders_motor_speed_min: number | null
    holders_motor_speed_max: number | null
    station_motor_speed_min: number | null
    station_motor_speed_max: number | null
    ink_injection_time_min: number | null
    ink_injection_time_max: number | null
    lacquer_machine_speed_min: number | null
    lacquer_machine_speed_max: number | null
    lacquer_machine_air_pressure_min: number | null
    lacquer_machine_air_pressure_max: number | null
    feed_can_air_pressure_min: number | null
    feed_can_air_pressure_max: number | null
    nozzle_regulator_air_pressure_min: number | null
    nozzle_regulator_air_pressure_max: number | null
    cells_speed_min: number | null
    cells_speed_max: number | null
    injection_AB_start_position_min: number | null
    injection_AB_start_position_max: number | null
    injection_CD_start_position_min: number | null
    injection_CD_start_position_max: number | null
    injection_ABCD_end_position_min: number | null
    injection_ABCD_end_position_max: number | null
    tube_molding_start_position_min: number | null
    tube_molding_start_position_max: number | null
    tube_molding_end_position_min: number | null
    tube_molding_end_position_max: number | null
    polimerization_furnace_temperature_min: number | null
    polimerization_furnace_temperature_max: number | null
  }

  export type Tube_parametersSumAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    press_speed_min: number | null
    press_speed_max: number | null
    molding_time_min: number | null
    molding_time_max: number | null
    turning_automate_speed_min: number | null
    turning_automate_speed_max: number | null
    annealing_furnace_temp_min: number | null
    annealing_furnace_temp_max: number | null
    cap_machine_speed_min: number | null
    cap_machine_speed_max: number | null
    cap_machine_air_pressure_min: number | null
    cap_machine_air_pressure_max: number | null
    grips_forward_min: number | null
    grips_forward_max: number | null
    grips_opening_left_min: number | null
    grips_opening_left_max: number | null
    grips_opening_right_min: number | null
    grips_opening_right_max: number | null
    grips_closing_min: number | null
    grips_closing_max: number | null
    injection_start_min: number | null
    injection_start_max: number | null
    injection_end_min: number | null
    injection_end_max: number | null
    tube_start_position_min: number | null
    tube_start_position_max: number | null
    tube_end_position_min: number | null
    tube_end_position_max: number | null
    padding_machine_speed_min: number | null
    padding_machine_speed_max: number | null
    padding_machine_air_pressure_min: number | null
    padding_machine_air_pressure_max: number | null
    padding_furnace_temp_min: number | null
    padding_furnace_temp_max: number | null
    offset_furnace_temp_min: number | null
    offset_furnace_temp_max: number | null
    printer_motor_speed_min: number | null
    printer_motor_speed_max: number | null
    holders_motor_speed_min: number | null
    holders_motor_speed_max: number | null
    station_motor_speed_min: number | null
    station_motor_speed_max: number | null
    ink_injection_time_min: number | null
    ink_injection_time_max: number | null
    lacquer_machine_speed_min: number | null
    lacquer_machine_speed_max: number | null
    lacquer_machine_air_pressure_min: number | null
    lacquer_machine_air_pressure_max: number | null
    feed_can_air_pressure_min: number | null
    feed_can_air_pressure_max: number | null
    nozzle_regulator_air_pressure_min: number | null
    nozzle_regulator_air_pressure_max: number | null
    cells_speed_min: number | null
    cells_speed_max: number | null
    injection_AB_start_position_min: number | null
    injection_AB_start_position_max: number | null
    injection_CD_start_position_min: number | null
    injection_CD_start_position_max: number | null
    injection_ABCD_end_position_min: number | null
    injection_ABCD_end_position_max: number | null
    tube_molding_start_position_min: number | null
    tube_molding_start_position_max: number | null
    tube_molding_end_position_min: number | null
    tube_molding_end_position_max: number | null
    polimerization_furnace_temperature_min: number | null
    polimerization_furnace_temperature_max: number | null
  }

  export type Tube_parametersMinAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    press_speed_min: number | null
    press_speed_max: number | null
    molding_time_min: number | null
    molding_time_max: number | null
    turning_automate_speed_min: number | null
    turning_automate_speed_max: number | null
    annealing_furnace_temp_min: number | null
    annealing_furnace_temp_max: number | null
    cap_machine_speed_min: number | null
    cap_machine_speed_max: number | null
    cap_machine_air_pressure_min: number | null
    cap_machine_air_pressure_max: number | null
    grips_forward_min: number | null
    grips_forward_max: number | null
    grips_opening_left_min: number | null
    grips_opening_left_max: number | null
    grips_opening_right_min: number | null
    grips_opening_right_max: number | null
    grips_closing_min: number | null
    grips_closing_max: number | null
    injection_start_min: number | null
    injection_start_max: number | null
    injection_end_min: number | null
    injection_end_max: number | null
    tube_start_position_min: number | null
    tube_start_position_max: number | null
    tube_end_position_min: number | null
    tube_end_position_max: number | null
    padding_machine_speed_min: number | null
    padding_machine_speed_max: number | null
    padding_machine_air_pressure_min: number | null
    padding_machine_air_pressure_max: number | null
    padding_furnace_temp_min: number | null
    padding_furnace_temp_max: number | null
    offset_furnace_temp_min: number | null
    offset_furnace_temp_max: number | null
    printer_motor_speed_min: number | null
    printer_motor_speed_max: number | null
    holders_motor_speed_min: number | null
    holders_motor_speed_max: number | null
    station_motor_speed_min: number | null
    station_motor_speed_max: number | null
    ink_injection_time_min: number | null
    ink_injection_time_max: number | null
    lacquer_machine_speed_min: number | null
    lacquer_machine_speed_max: number | null
    lacquer_machine_air_pressure_min: number | null
    lacquer_machine_air_pressure_max: number | null
    feed_can_air_pressure_min: number | null
    feed_can_air_pressure_max: number | null
    nozzle_regulator_air_pressure_min: number | null
    nozzle_regulator_air_pressure_max: number | null
    cells_speed_min: number | null
    cells_speed_max: number | null
    injection_AB_start_position_min: number | null
    injection_AB_start_position_max: number | null
    injection_CD_start_position_min: number | null
    injection_CD_start_position_max: number | null
    injection_ABCD_end_position_min: number | null
    injection_ABCD_end_position_max: number | null
    tube_molding_start_position_min: number | null
    tube_molding_start_position_max: number | null
    tube_molding_end_position_min: number | null
    tube_molding_end_position_max: number | null
    polimerization_furnace_temperature_min: number | null
    polimerization_furnace_temperature_max: number | null
  }

  export type Tube_parametersMaxAggregateOutputType = {
    id: number | null
    tube_record_id: number | null
    press_speed_min: number | null
    press_speed_max: number | null
    molding_time_min: number | null
    molding_time_max: number | null
    turning_automate_speed_min: number | null
    turning_automate_speed_max: number | null
    annealing_furnace_temp_min: number | null
    annealing_furnace_temp_max: number | null
    cap_machine_speed_min: number | null
    cap_machine_speed_max: number | null
    cap_machine_air_pressure_min: number | null
    cap_machine_air_pressure_max: number | null
    grips_forward_min: number | null
    grips_forward_max: number | null
    grips_opening_left_min: number | null
    grips_opening_left_max: number | null
    grips_opening_right_min: number | null
    grips_opening_right_max: number | null
    grips_closing_min: number | null
    grips_closing_max: number | null
    injection_start_min: number | null
    injection_start_max: number | null
    injection_end_min: number | null
    injection_end_max: number | null
    tube_start_position_min: number | null
    tube_start_position_max: number | null
    tube_end_position_min: number | null
    tube_end_position_max: number | null
    padding_machine_speed_min: number | null
    padding_machine_speed_max: number | null
    padding_machine_air_pressure_min: number | null
    padding_machine_air_pressure_max: number | null
    padding_furnace_temp_min: number | null
    padding_furnace_temp_max: number | null
    offset_furnace_temp_min: number | null
    offset_furnace_temp_max: number | null
    printer_motor_speed_min: number | null
    printer_motor_speed_max: number | null
    holders_motor_speed_min: number | null
    holders_motor_speed_max: number | null
    station_motor_speed_min: number | null
    station_motor_speed_max: number | null
    ink_injection_time_min: number | null
    ink_injection_time_max: number | null
    lacquer_machine_speed_min: number | null
    lacquer_machine_speed_max: number | null
    lacquer_machine_air_pressure_min: number | null
    lacquer_machine_air_pressure_max: number | null
    feed_can_air_pressure_min: number | null
    feed_can_air_pressure_max: number | null
    nozzle_regulator_air_pressure_min: number | null
    nozzle_regulator_air_pressure_max: number | null
    cells_speed_min: number | null
    cells_speed_max: number | null
    injection_AB_start_position_min: number | null
    injection_AB_start_position_max: number | null
    injection_CD_start_position_min: number | null
    injection_CD_start_position_max: number | null
    injection_ABCD_end_position_min: number | null
    injection_ABCD_end_position_max: number | null
    tube_molding_start_position_min: number | null
    tube_molding_start_position_max: number | null
    tube_molding_end_position_min: number | null
    tube_molding_end_position_max: number | null
    polimerization_furnace_temperature_min: number | null
    polimerization_furnace_temperature_max: number | null
  }

  export type Tube_parametersCountAggregateOutputType = {
    id: number
    tube_record_id: number
    press_speed_min: number
    press_speed_max: number
    molding_time_min: number
    molding_time_max: number
    turning_automate_speed_min: number
    turning_automate_speed_max: number
    annealing_furnace_temp_min: number
    annealing_furnace_temp_max: number
    cap_machine_speed_min: number
    cap_machine_speed_max: number
    cap_machine_air_pressure_min: number
    cap_machine_air_pressure_max: number
    grips_forward_min: number
    grips_forward_max: number
    grips_opening_left_min: number
    grips_opening_left_max: number
    grips_opening_right_min: number
    grips_opening_right_max: number
    grips_closing_min: number
    grips_closing_max: number
    injection_start_min: number
    injection_start_max: number
    injection_end_min: number
    injection_end_max: number
    tube_start_position_min: number
    tube_start_position_max: number
    tube_end_position_min: number
    tube_end_position_max: number
    padding_machine_speed_min: number
    padding_machine_speed_max: number
    padding_machine_air_pressure_min: number
    padding_machine_air_pressure_max: number
    padding_furnace_temp_min: number
    padding_furnace_temp_max: number
    offset_furnace_temp_min: number
    offset_furnace_temp_max: number
    printer_motor_speed_min: number
    printer_motor_speed_max: number
    holders_motor_speed_min: number
    holders_motor_speed_max: number
    station_motor_speed_min: number
    station_motor_speed_max: number
    ink_injection_time_min: number
    ink_injection_time_max: number
    lacquer_machine_speed_min: number
    lacquer_machine_speed_max: number
    lacquer_machine_air_pressure_min: number
    lacquer_machine_air_pressure_max: number
    feed_can_air_pressure_min: number
    feed_can_air_pressure_max: number
    nozzle_regulator_air_pressure_min: number
    nozzle_regulator_air_pressure_max: number
    cells_speed_min: number
    cells_speed_max: number
    injection_AB_start_position_min: number
    injection_AB_start_position_max: number
    injection_CD_start_position_min: number
    injection_CD_start_position_max: number
    injection_ABCD_end_position_min: number
    injection_ABCD_end_position_max: number
    tube_molding_start_position_min: number
    tube_molding_start_position_max: number
    tube_molding_end_position_min: number
    tube_molding_end_position_max: number
    polimerization_furnace_temperature_min: number
    polimerization_furnace_temperature_max: number
    _all: number
  }


  export type Tube_parametersAvgAggregateInputType = {
    id?: true
    tube_record_id?: true
    press_speed_min?: true
    press_speed_max?: true
    molding_time_min?: true
    molding_time_max?: true
    turning_automate_speed_min?: true
    turning_automate_speed_max?: true
    annealing_furnace_temp_min?: true
    annealing_furnace_temp_max?: true
    cap_machine_speed_min?: true
    cap_machine_speed_max?: true
    cap_machine_air_pressure_min?: true
    cap_machine_air_pressure_max?: true
    grips_forward_min?: true
    grips_forward_max?: true
    grips_opening_left_min?: true
    grips_opening_left_max?: true
    grips_opening_right_min?: true
    grips_opening_right_max?: true
    grips_closing_min?: true
    grips_closing_max?: true
    injection_start_min?: true
    injection_start_max?: true
    injection_end_min?: true
    injection_end_max?: true
    tube_start_position_min?: true
    tube_start_position_max?: true
    tube_end_position_min?: true
    tube_end_position_max?: true
    padding_machine_speed_min?: true
    padding_machine_speed_max?: true
    padding_machine_air_pressure_min?: true
    padding_machine_air_pressure_max?: true
    padding_furnace_temp_min?: true
    padding_furnace_temp_max?: true
    offset_furnace_temp_min?: true
    offset_furnace_temp_max?: true
    printer_motor_speed_min?: true
    printer_motor_speed_max?: true
    holders_motor_speed_min?: true
    holders_motor_speed_max?: true
    station_motor_speed_min?: true
    station_motor_speed_max?: true
    ink_injection_time_min?: true
    ink_injection_time_max?: true
    lacquer_machine_speed_min?: true
    lacquer_machine_speed_max?: true
    lacquer_machine_air_pressure_min?: true
    lacquer_machine_air_pressure_max?: true
    feed_can_air_pressure_min?: true
    feed_can_air_pressure_max?: true
    nozzle_regulator_air_pressure_min?: true
    nozzle_regulator_air_pressure_max?: true
    cells_speed_min?: true
    cells_speed_max?: true
    injection_AB_start_position_min?: true
    injection_AB_start_position_max?: true
    injection_CD_start_position_min?: true
    injection_CD_start_position_max?: true
    injection_ABCD_end_position_min?: true
    injection_ABCD_end_position_max?: true
    tube_molding_start_position_min?: true
    tube_molding_start_position_max?: true
    tube_molding_end_position_min?: true
    tube_molding_end_position_max?: true
    polimerization_furnace_temperature_min?: true
    polimerization_furnace_temperature_max?: true
  }

  export type Tube_parametersSumAggregateInputType = {
    id?: true
    tube_record_id?: true
    press_speed_min?: true
    press_speed_max?: true
    molding_time_min?: true
    molding_time_max?: true
    turning_automate_speed_min?: true
    turning_automate_speed_max?: true
    annealing_furnace_temp_min?: true
    annealing_furnace_temp_max?: true
    cap_machine_speed_min?: true
    cap_machine_speed_max?: true
    cap_machine_air_pressure_min?: true
    cap_machine_air_pressure_max?: true
    grips_forward_min?: true
    grips_forward_max?: true
    grips_opening_left_min?: true
    grips_opening_left_max?: true
    grips_opening_right_min?: true
    grips_opening_right_max?: true
    grips_closing_min?: true
    grips_closing_max?: true
    injection_start_min?: true
    injection_start_max?: true
    injection_end_min?: true
    injection_end_max?: true
    tube_start_position_min?: true
    tube_start_position_max?: true
    tube_end_position_min?: true
    tube_end_position_max?: true
    padding_machine_speed_min?: true
    padding_machine_speed_max?: true
    padding_machine_air_pressure_min?: true
    padding_machine_air_pressure_max?: true
    padding_furnace_temp_min?: true
    padding_furnace_temp_max?: true
    offset_furnace_temp_min?: true
    offset_furnace_temp_max?: true
    printer_motor_speed_min?: true
    printer_motor_speed_max?: true
    holders_motor_speed_min?: true
    holders_motor_speed_max?: true
    station_motor_speed_min?: true
    station_motor_speed_max?: true
    ink_injection_time_min?: true
    ink_injection_time_max?: true
    lacquer_machine_speed_min?: true
    lacquer_machine_speed_max?: true
    lacquer_machine_air_pressure_min?: true
    lacquer_machine_air_pressure_max?: true
    feed_can_air_pressure_min?: true
    feed_can_air_pressure_max?: true
    nozzle_regulator_air_pressure_min?: true
    nozzle_regulator_air_pressure_max?: true
    cells_speed_min?: true
    cells_speed_max?: true
    injection_AB_start_position_min?: true
    injection_AB_start_position_max?: true
    injection_CD_start_position_min?: true
    injection_CD_start_position_max?: true
    injection_ABCD_end_position_min?: true
    injection_ABCD_end_position_max?: true
    tube_molding_start_position_min?: true
    tube_molding_start_position_max?: true
    tube_molding_end_position_min?: true
    tube_molding_end_position_max?: true
    polimerization_furnace_temperature_min?: true
    polimerization_furnace_temperature_max?: true
  }

  export type Tube_parametersMinAggregateInputType = {
    id?: true
    tube_record_id?: true
    press_speed_min?: true
    press_speed_max?: true
    molding_time_min?: true
    molding_time_max?: true
    turning_automate_speed_min?: true
    turning_automate_speed_max?: true
    annealing_furnace_temp_min?: true
    annealing_furnace_temp_max?: true
    cap_machine_speed_min?: true
    cap_machine_speed_max?: true
    cap_machine_air_pressure_min?: true
    cap_machine_air_pressure_max?: true
    grips_forward_min?: true
    grips_forward_max?: true
    grips_opening_left_min?: true
    grips_opening_left_max?: true
    grips_opening_right_min?: true
    grips_opening_right_max?: true
    grips_closing_min?: true
    grips_closing_max?: true
    injection_start_min?: true
    injection_start_max?: true
    injection_end_min?: true
    injection_end_max?: true
    tube_start_position_min?: true
    tube_start_position_max?: true
    tube_end_position_min?: true
    tube_end_position_max?: true
    padding_machine_speed_min?: true
    padding_machine_speed_max?: true
    padding_machine_air_pressure_min?: true
    padding_machine_air_pressure_max?: true
    padding_furnace_temp_min?: true
    padding_furnace_temp_max?: true
    offset_furnace_temp_min?: true
    offset_furnace_temp_max?: true
    printer_motor_speed_min?: true
    printer_motor_speed_max?: true
    holders_motor_speed_min?: true
    holders_motor_speed_max?: true
    station_motor_speed_min?: true
    station_motor_speed_max?: true
    ink_injection_time_min?: true
    ink_injection_time_max?: true
    lacquer_machine_speed_min?: true
    lacquer_machine_speed_max?: true
    lacquer_machine_air_pressure_min?: true
    lacquer_machine_air_pressure_max?: true
    feed_can_air_pressure_min?: true
    feed_can_air_pressure_max?: true
    nozzle_regulator_air_pressure_min?: true
    nozzle_regulator_air_pressure_max?: true
    cells_speed_min?: true
    cells_speed_max?: true
    injection_AB_start_position_min?: true
    injection_AB_start_position_max?: true
    injection_CD_start_position_min?: true
    injection_CD_start_position_max?: true
    injection_ABCD_end_position_min?: true
    injection_ABCD_end_position_max?: true
    tube_molding_start_position_min?: true
    tube_molding_start_position_max?: true
    tube_molding_end_position_min?: true
    tube_molding_end_position_max?: true
    polimerization_furnace_temperature_min?: true
    polimerization_furnace_temperature_max?: true
  }

  export type Tube_parametersMaxAggregateInputType = {
    id?: true
    tube_record_id?: true
    press_speed_min?: true
    press_speed_max?: true
    molding_time_min?: true
    molding_time_max?: true
    turning_automate_speed_min?: true
    turning_automate_speed_max?: true
    annealing_furnace_temp_min?: true
    annealing_furnace_temp_max?: true
    cap_machine_speed_min?: true
    cap_machine_speed_max?: true
    cap_machine_air_pressure_min?: true
    cap_machine_air_pressure_max?: true
    grips_forward_min?: true
    grips_forward_max?: true
    grips_opening_left_min?: true
    grips_opening_left_max?: true
    grips_opening_right_min?: true
    grips_opening_right_max?: true
    grips_closing_min?: true
    grips_closing_max?: true
    injection_start_min?: true
    injection_start_max?: true
    injection_end_min?: true
    injection_end_max?: true
    tube_start_position_min?: true
    tube_start_position_max?: true
    tube_end_position_min?: true
    tube_end_position_max?: true
    padding_machine_speed_min?: true
    padding_machine_speed_max?: true
    padding_machine_air_pressure_min?: true
    padding_machine_air_pressure_max?: true
    padding_furnace_temp_min?: true
    padding_furnace_temp_max?: true
    offset_furnace_temp_min?: true
    offset_furnace_temp_max?: true
    printer_motor_speed_min?: true
    printer_motor_speed_max?: true
    holders_motor_speed_min?: true
    holders_motor_speed_max?: true
    station_motor_speed_min?: true
    station_motor_speed_max?: true
    ink_injection_time_min?: true
    ink_injection_time_max?: true
    lacquer_machine_speed_min?: true
    lacquer_machine_speed_max?: true
    lacquer_machine_air_pressure_min?: true
    lacquer_machine_air_pressure_max?: true
    feed_can_air_pressure_min?: true
    feed_can_air_pressure_max?: true
    nozzle_regulator_air_pressure_min?: true
    nozzle_regulator_air_pressure_max?: true
    cells_speed_min?: true
    cells_speed_max?: true
    injection_AB_start_position_min?: true
    injection_AB_start_position_max?: true
    injection_CD_start_position_min?: true
    injection_CD_start_position_max?: true
    injection_ABCD_end_position_min?: true
    injection_ABCD_end_position_max?: true
    tube_molding_start_position_min?: true
    tube_molding_start_position_max?: true
    tube_molding_end_position_min?: true
    tube_molding_end_position_max?: true
    polimerization_furnace_temperature_min?: true
    polimerization_furnace_temperature_max?: true
  }

  export type Tube_parametersCountAggregateInputType = {
    id?: true
    tube_record_id?: true
    press_speed_min?: true
    press_speed_max?: true
    molding_time_min?: true
    molding_time_max?: true
    turning_automate_speed_min?: true
    turning_automate_speed_max?: true
    annealing_furnace_temp_min?: true
    annealing_furnace_temp_max?: true
    cap_machine_speed_min?: true
    cap_machine_speed_max?: true
    cap_machine_air_pressure_min?: true
    cap_machine_air_pressure_max?: true
    grips_forward_min?: true
    grips_forward_max?: true
    grips_opening_left_min?: true
    grips_opening_left_max?: true
    grips_opening_right_min?: true
    grips_opening_right_max?: true
    grips_closing_min?: true
    grips_closing_max?: true
    injection_start_min?: true
    injection_start_max?: true
    injection_end_min?: true
    injection_end_max?: true
    tube_start_position_min?: true
    tube_start_position_max?: true
    tube_end_position_min?: true
    tube_end_position_max?: true
    padding_machine_speed_min?: true
    padding_machine_speed_max?: true
    padding_machine_air_pressure_min?: true
    padding_machine_air_pressure_max?: true
    padding_furnace_temp_min?: true
    padding_furnace_temp_max?: true
    offset_furnace_temp_min?: true
    offset_furnace_temp_max?: true
    printer_motor_speed_min?: true
    printer_motor_speed_max?: true
    holders_motor_speed_min?: true
    holders_motor_speed_max?: true
    station_motor_speed_min?: true
    station_motor_speed_max?: true
    ink_injection_time_min?: true
    ink_injection_time_max?: true
    lacquer_machine_speed_min?: true
    lacquer_machine_speed_max?: true
    lacquer_machine_air_pressure_min?: true
    lacquer_machine_air_pressure_max?: true
    feed_can_air_pressure_min?: true
    feed_can_air_pressure_max?: true
    nozzle_regulator_air_pressure_min?: true
    nozzle_regulator_air_pressure_max?: true
    cells_speed_min?: true
    cells_speed_max?: true
    injection_AB_start_position_min?: true
    injection_AB_start_position_max?: true
    injection_CD_start_position_min?: true
    injection_CD_start_position_max?: true
    injection_ABCD_end_position_min?: true
    injection_ABCD_end_position_max?: true
    tube_molding_start_position_min?: true
    tube_molding_start_position_max?: true
    tube_molding_end_position_min?: true
    tube_molding_end_position_max?: true
    polimerization_furnace_temperature_min?: true
    polimerization_furnace_temperature_max?: true
    _all?: true
  }

  export type Tube_parametersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_parameters to aggregate.
     */
    where?: tube_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_parameters to fetch.
     */
    orderBy?: tube_parametersOrderByWithRelationInput | tube_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_parameters
    **/
    _count?: true | Tube_parametersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_parametersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_parametersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_parametersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_parametersMaxAggregateInputType
  }

  export type GetTube_parametersAggregateType<T extends Tube_parametersAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_parameters]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_parameters[P]>
      : GetScalarType<T[P], AggregateTube_parameters[P]>
  }




  export type tube_parametersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_parametersWhereInput
    orderBy?: tube_parametersOrderByWithAggregationInput | tube_parametersOrderByWithAggregationInput[]
    by: Tube_parametersScalarFieldEnum[] | Tube_parametersScalarFieldEnum
    having?: tube_parametersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_parametersCountAggregateInputType | true
    _avg?: Tube_parametersAvgAggregateInputType
    _sum?: Tube_parametersSumAggregateInputType
    _min?: Tube_parametersMinAggregateInputType
    _max?: Tube_parametersMaxAggregateInputType
  }

  export type Tube_parametersGroupByOutputType = {
    id: number
    tube_record_id: number | null
    press_speed_min: number | null
    press_speed_max: number | null
    molding_time_min: number | null
    molding_time_max: number | null
    turning_automate_speed_min: number | null
    turning_automate_speed_max: number | null
    annealing_furnace_temp_min: number | null
    annealing_furnace_temp_max: number | null
    cap_machine_speed_min: number | null
    cap_machine_speed_max: number | null
    cap_machine_air_pressure_min: number | null
    cap_machine_air_pressure_max: number | null
    grips_forward_min: number | null
    grips_forward_max: number | null
    grips_opening_left_min: number | null
    grips_opening_left_max: number | null
    grips_opening_right_min: number | null
    grips_opening_right_max: number | null
    grips_closing_min: number | null
    grips_closing_max: number | null
    injection_start_min: number | null
    injection_start_max: number | null
    injection_end_min: number | null
    injection_end_max: number | null
    tube_start_position_min: number | null
    tube_start_position_max: number | null
    tube_end_position_min: number | null
    tube_end_position_max: number | null
    padding_machine_speed_min: number | null
    padding_machine_speed_max: number | null
    padding_machine_air_pressure_min: number | null
    padding_machine_air_pressure_max: number | null
    padding_furnace_temp_min: number | null
    padding_furnace_temp_max: number | null
    offset_furnace_temp_min: number | null
    offset_furnace_temp_max: number | null
    printer_motor_speed_min: number | null
    printer_motor_speed_max: number | null
    holders_motor_speed_min: number | null
    holders_motor_speed_max: number | null
    station_motor_speed_min: number | null
    station_motor_speed_max: number | null
    ink_injection_time_min: number | null
    ink_injection_time_max: number | null
    lacquer_machine_speed_min: number | null
    lacquer_machine_speed_max: number | null
    lacquer_machine_air_pressure_min: number | null
    lacquer_machine_air_pressure_max: number | null
    feed_can_air_pressure_min: number | null
    feed_can_air_pressure_max: number | null
    nozzle_regulator_air_pressure_min: number | null
    nozzle_regulator_air_pressure_max: number | null
    cells_speed_min: number | null
    cells_speed_max: number | null
    injection_AB_start_position_min: number | null
    injection_AB_start_position_max: number | null
    injection_CD_start_position_min: number | null
    injection_CD_start_position_max: number | null
    injection_ABCD_end_position_min: number | null
    injection_ABCD_end_position_max: number | null
    tube_molding_start_position_min: number | null
    tube_molding_start_position_max: number | null
    tube_molding_end_position_min: number | null
    tube_molding_end_position_max: number | null
    polimerization_furnace_temperature_min: number | null
    polimerization_furnace_temperature_max: number | null
    _count: Tube_parametersCountAggregateOutputType | null
    _avg: Tube_parametersAvgAggregateOutputType | null
    _sum: Tube_parametersSumAggregateOutputType | null
    _min: Tube_parametersMinAggregateOutputType | null
    _max: Tube_parametersMaxAggregateOutputType | null
  }

  type GetTube_parametersGroupByPayload<T extends tube_parametersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_parametersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_parametersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_parametersGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_parametersGroupByOutputType[P]>
        }
      >
    >


  export type tube_parametersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    press_speed_min?: boolean
    press_speed_max?: boolean
    molding_time_min?: boolean
    molding_time_max?: boolean
    turning_automate_speed_min?: boolean
    turning_automate_speed_max?: boolean
    annealing_furnace_temp_min?: boolean
    annealing_furnace_temp_max?: boolean
    cap_machine_speed_min?: boolean
    cap_machine_speed_max?: boolean
    cap_machine_air_pressure_min?: boolean
    cap_machine_air_pressure_max?: boolean
    grips_forward_min?: boolean
    grips_forward_max?: boolean
    grips_opening_left_min?: boolean
    grips_opening_left_max?: boolean
    grips_opening_right_min?: boolean
    grips_opening_right_max?: boolean
    grips_closing_min?: boolean
    grips_closing_max?: boolean
    injection_start_min?: boolean
    injection_start_max?: boolean
    injection_end_min?: boolean
    injection_end_max?: boolean
    tube_start_position_min?: boolean
    tube_start_position_max?: boolean
    tube_end_position_min?: boolean
    tube_end_position_max?: boolean
    padding_machine_speed_min?: boolean
    padding_machine_speed_max?: boolean
    padding_machine_air_pressure_min?: boolean
    padding_machine_air_pressure_max?: boolean
    padding_furnace_temp_min?: boolean
    padding_furnace_temp_max?: boolean
    offset_furnace_temp_min?: boolean
    offset_furnace_temp_max?: boolean
    printer_motor_speed_min?: boolean
    printer_motor_speed_max?: boolean
    holders_motor_speed_min?: boolean
    holders_motor_speed_max?: boolean
    station_motor_speed_min?: boolean
    station_motor_speed_max?: boolean
    ink_injection_time_min?: boolean
    ink_injection_time_max?: boolean
    lacquer_machine_speed_min?: boolean
    lacquer_machine_speed_max?: boolean
    lacquer_machine_air_pressure_min?: boolean
    lacquer_machine_air_pressure_max?: boolean
    feed_can_air_pressure_min?: boolean
    feed_can_air_pressure_max?: boolean
    nozzle_regulator_air_pressure_min?: boolean
    nozzle_regulator_air_pressure_max?: boolean
    cells_speed_min?: boolean
    cells_speed_max?: boolean
    injection_AB_start_position_min?: boolean
    injection_AB_start_position_max?: boolean
    injection_CD_start_position_min?: boolean
    injection_CD_start_position_max?: boolean
    injection_ABCD_end_position_min?: boolean
    injection_ABCD_end_position_max?: boolean
    tube_molding_start_position_min?: boolean
    tube_molding_start_position_max?: boolean
    tube_molding_end_position_min?: boolean
    tube_molding_end_position_max?: boolean
    polimerization_furnace_temperature_min?: boolean
    polimerization_furnace_temperature_max?: boolean
  }, ExtArgs["result"]["tube_parameters"]>

  export type tube_parametersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    press_speed_min?: boolean
    press_speed_max?: boolean
    molding_time_min?: boolean
    molding_time_max?: boolean
    turning_automate_speed_min?: boolean
    turning_automate_speed_max?: boolean
    annealing_furnace_temp_min?: boolean
    annealing_furnace_temp_max?: boolean
    cap_machine_speed_min?: boolean
    cap_machine_speed_max?: boolean
    cap_machine_air_pressure_min?: boolean
    cap_machine_air_pressure_max?: boolean
    grips_forward_min?: boolean
    grips_forward_max?: boolean
    grips_opening_left_min?: boolean
    grips_opening_left_max?: boolean
    grips_opening_right_min?: boolean
    grips_opening_right_max?: boolean
    grips_closing_min?: boolean
    grips_closing_max?: boolean
    injection_start_min?: boolean
    injection_start_max?: boolean
    injection_end_min?: boolean
    injection_end_max?: boolean
    tube_start_position_min?: boolean
    tube_start_position_max?: boolean
    tube_end_position_min?: boolean
    tube_end_position_max?: boolean
    padding_machine_speed_min?: boolean
    padding_machine_speed_max?: boolean
    padding_machine_air_pressure_min?: boolean
    padding_machine_air_pressure_max?: boolean
    padding_furnace_temp_min?: boolean
    padding_furnace_temp_max?: boolean
    offset_furnace_temp_min?: boolean
    offset_furnace_temp_max?: boolean
    printer_motor_speed_min?: boolean
    printer_motor_speed_max?: boolean
    holders_motor_speed_min?: boolean
    holders_motor_speed_max?: boolean
    station_motor_speed_min?: boolean
    station_motor_speed_max?: boolean
    ink_injection_time_min?: boolean
    ink_injection_time_max?: boolean
    lacquer_machine_speed_min?: boolean
    lacquer_machine_speed_max?: boolean
    lacquer_machine_air_pressure_min?: boolean
    lacquer_machine_air_pressure_max?: boolean
    feed_can_air_pressure_min?: boolean
    feed_can_air_pressure_max?: boolean
    nozzle_regulator_air_pressure_min?: boolean
    nozzle_regulator_air_pressure_max?: boolean
    cells_speed_min?: boolean
    cells_speed_max?: boolean
    injection_AB_start_position_min?: boolean
    injection_AB_start_position_max?: boolean
    injection_CD_start_position_min?: boolean
    injection_CD_start_position_max?: boolean
    injection_ABCD_end_position_min?: boolean
    injection_ABCD_end_position_max?: boolean
    tube_molding_start_position_min?: boolean
    tube_molding_start_position_max?: boolean
    tube_molding_end_position_min?: boolean
    tube_molding_end_position_max?: boolean
    polimerization_furnace_temperature_min?: boolean
    polimerization_furnace_temperature_max?: boolean
  }, ExtArgs["result"]["tube_parameters"]>

  export type tube_parametersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_record_id?: boolean
    press_speed_min?: boolean
    press_speed_max?: boolean
    molding_time_min?: boolean
    molding_time_max?: boolean
    turning_automate_speed_min?: boolean
    turning_automate_speed_max?: boolean
    annealing_furnace_temp_min?: boolean
    annealing_furnace_temp_max?: boolean
    cap_machine_speed_min?: boolean
    cap_machine_speed_max?: boolean
    cap_machine_air_pressure_min?: boolean
    cap_machine_air_pressure_max?: boolean
    grips_forward_min?: boolean
    grips_forward_max?: boolean
    grips_opening_left_min?: boolean
    grips_opening_left_max?: boolean
    grips_opening_right_min?: boolean
    grips_opening_right_max?: boolean
    grips_closing_min?: boolean
    grips_closing_max?: boolean
    injection_start_min?: boolean
    injection_start_max?: boolean
    injection_end_min?: boolean
    injection_end_max?: boolean
    tube_start_position_min?: boolean
    tube_start_position_max?: boolean
    tube_end_position_min?: boolean
    tube_end_position_max?: boolean
    padding_machine_speed_min?: boolean
    padding_machine_speed_max?: boolean
    padding_machine_air_pressure_min?: boolean
    padding_machine_air_pressure_max?: boolean
    padding_furnace_temp_min?: boolean
    padding_furnace_temp_max?: boolean
    offset_furnace_temp_min?: boolean
    offset_furnace_temp_max?: boolean
    printer_motor_speed_min?: boolean
    printer_motor_speed_max?: boolean
    holders_motor_speed_min?: boolean
    holders_motor_speed_max?: boolean
    station_motor_speed_min?: boolean
    station_motor_speed_max?: boolean
    ink_injection_time_min?: boolean
    ink_injection_time_max?: boolean
    lacquer_machine_speed_min?: boolean
    lacquer_machine_speed_max?: boolean
    lacquer_machine_air_pressure_min?: boolean
    lacquer_machine_air_pressure_max?: boolean
    feed_can_air_pressure_min?: boolean
    feed_can_air_pressure_max?: boolean
    nozzle_regulator_air_pressure_min?: boolean
    nozzle_regulator_air_pressure_max?: boolean
    cells_speed_min?: boolean
    cells_speed_max?: boolean
    injection_AB_start_position_min?: boolean
    injection_AB_start_position_max?: boolean
    injection_CD_start_position_min?: boolean
    injection_CD_start_position_max?: boolean
    injection_ABCD_end_position_min?: boolean
    injection_ABCD_end_position_max?: boolean
    tube_molding_start_position_min?: boolean
    tube_molding_start_position_max?: boolean
    tube_molding_end_position_min?: boolean
    tube_molding_end_position_max?: boolean
    polimerization_furnace_temperature_min?: boolean
    polimerization_furnace_temperature_max?: boolean
  }, ExtArgs["result"]["tube_parameters"]>

  export type tube_parametersSelectScalar = {
    id?: boolean
    tube_record_id?: boolean
    press_speed_min?: boolean
    press_speed_max?: boolean
    molding_time_min?: boolean
    molding_time_max?: boolean
    turning_automate_speed_min?: boolean
    turning_automate_speed_max?: boolean
    annealing_furnace_temp_min?: boolean
    annealing_furnace_temp_max?: boolean
    cap_machine_speed_min?: boolean
    cap_machine_speed_max?: boolean
    cap_machine_air_pressure_min?: boolean
    cap_machine_air_pressure_max?: boolean
    grips_forward_min?: boolean
    grips_forward_max?: boolean
    grips_opening_left_min?: boolean
    grips_opening_left_max?: boolean
    grips_opening_right_min?: boolean
    grips_opening_right_max?: boolean
    grips_closing_min?: boolean
    grips_closing_max?: boolean
    injection_start_min?: boolean
    injection_start_max?: boolean
    injection_end_min?: boolean
    injection_end_max?: boolean
    tube_start_position_min?: boolean
    tube_start_position_max?: boolean
    tube_end_position_min?: boolean
    tube_end_position_max?: boolean
    padding_machine_speed_min?: boolean
    padding_machine_speed_max?: boolean
    padding_machine_air_pressure_min?: boolean
    padding_machine_air_pressure_max?: boolean
    padding_furnace_temp_min?: boolean
    padding_furnace_temp_max?: boolean
    offset_furnace_temp_min?: boolean
    offset_furnace_temp_max?: boolean
    printer_motor_speed_min?: boolean
    printer_motor_speed_max?: boolean
    holders_motor_speed_min?: boolean
    holders_motor_speed_max?: boolean
    station_motor_speed_min?: boolean
    station_motor_speed_max?: boolean
    ink_injection_time_min?: boolean
    ink_injection_time_max?: boolean
    lacquer_machine_speed_min?: boolean
    lacquer_machine_speed_max?: boolean
    lacquer_machine_air_pressure_min?: boolean
    lacquer_machine_air_pressure_max?: boolean
    feed_can_air_pressure_min?: boolean
    feed_can_air_pressure_max?: boolean
    nozzle_regulator_air_pressure_min?: boolean
    nozzle_regulator_air_pressure_max?: boolean
    cells_speed_min?: boolean
    cells_speed_max?: boolean
    injection_AB_start_position_min?: boolean
    injection_AB_start_position_max?: boolean
    injection_CD_start_position_min?: boolean
    injection_CD_start_position_max?: boolean
    injection_ABCD_end_position_min?: boolean
    injection_ABCD_end_position_max?: boolean
    tube_molding_start_position_min?: boolean
    tube_molding_start_position_max?: boolean
    tube_molding_end_position_min?: boolean
    tube_molding_end_position_max?: boolean
    polimerization_furnace_temperature_min?: boolean
    polimerization_furnace_temperature_max?: boolean
  }

  export type tube_parametersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tube_record_id" | "press_speed_min" | "press_speed_max" | "molding_time_min" | "molding_time_max" | "turning_automate_speed_min" | "turning_automate_speed_max" | "annealing_furnace_temp_min" | "annealing_furnace_temp_max" | "cap_machine_speed_min" | "cap_machine_speed_max" | "cap_machine_air_pressure_min" | "cap_machine_air_pressure_max" | "grips_forward_min" | "grips_forward_max" | "grips_opening_left_min" | "grips_opening_left_max" | "grips_opening_right_min" | "grips_opening_right_max" | "grips_closing_min" | "grips_closing_max" | "injection_start_min" | "injection_start_max" | "injection_end_min" | "injection_end_max" | "tube_start_position_min" | "tube_start_position_max" | "tube_end_position_min" | "tube_end_position_max" | "padding_machine_speed_min" | "padding_machine_speed_max" | "padding_machine_air_pressure_min" | "padding_machine_air_pressure_max" | "padding_furnace_temp_min" | "padding_furnace_temp_max" | "offset_furnace_temp_min" | "offset_furnace_temp_max" | "printer_motor_speed_min" | "printer_motor_speed_max" | "holders_motor_speed_min" | "holders_motor_speed_max" | "station_motor_speed_min" | "station_motor_speed_max" | "ink_injection_time_min" | "ink_injection_time_max" | "lacquer_machine_speed_min" | "lacquer_machine_speed_max" | "lacquer_machine_air_pressure_min" | "lacquer_machine_air_pressure_max" | "feed_can_air_pressure_min" | "feed_can_air_pressure_max" | "nozzle_regulator_air_pressure_min" | "nozzle_regulator_air_pressure_max" | "cells_speed_min" | "cells_speed_max" | "injection_AB_start_position_min" | "injection_AB_start_position_max" | "injection_CD_start_position_min" | "injection_CD_start_position_max" | "injection_ABCD_end_position_min" | "injection_ABCD_end_position_max" | "tube_molding_start_position_min" | "tube_molding_start_position_max" | "tube_molding_end_position_min" | "tube_molding_end_position_max" | "polimerization_furnace_temperature_min" | "polimerization_furnace_temperature_max", ExtArgs["result"]["tube_parameters"]>

  export type $tube_parametersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_parameters"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tube_record_id: number | null
      press_speed_min: number | null
      press_speed_max: number | null
      molding_time_min: number | null
      molding_time_max: number | null
      turning_automate_speed_min: number | null
      turning_automate_speed_max: number | null
      annealing_furnace_temp_min: number | null
      annealing_furnace_temp_max: number | null
      cap_machine_speed_min: number | null
      cap_machine_speed_max: number | null
      cap_machine_air_pressure_min: number | null
      cap_machine_air_pressure_max: number | null
      grips_forward_min: number | null
      grips_forward_max: number | null
      grips_opening_left_min: number | null
      grips_opening_left_max: number | null
      grips_opening_right_min: number | null
      grips_opening_right_max: number | null
      grips_closing_min: number | null
      grips_closing_max: number | null
      injection_start_min: number | null
      injection_start_max: number | null
      injection_end_min: number | null
      injection_end_max: number | null
      tube_start_position_min: number | null
      tube_start_position_max: number | null
      tube_end_position_min: number | null
      tube_end_position_max: number | null
      padding_machine_speed_min: number | null
      padding_machine_speed_max: number | null
      padding_machine_air_pressure_min: number | null
      padding_machine_air_pressure_max: number | null
      padding_furnace_temp_min: number | null
      padding_furnace_temp_max: number | null
      offset_furnace_temp_min: number | null
      offset_furnace_temp_max: number | null
      printer_motor_speed_min: number | null
      printer_motor_speed_max: number | null
      holders_motor_speed_min: number | null
      holders_motor_speed_max: number | null
      station_motor_speed_min: number | null
      station_motor_speed_max: number | null
      ink_injection_time_min: number | null
      ink_injection_time_max: number | null
      lacquer_machine_speed_min: number | null
      lacquer_machine_speed_max: number | null
      lacquer_machine_air_pressure_min: number | null
      lacquer_machine_air_pressure_max: number | null
      feed_can_air_pressure_min: number | null
      feed_can_air_pressure_max: number | null
      nozzle_regulator_air_pressure_min: number | null
      nozzle_regulator_air_pressure_max: number | null
      cells_speed_min: number | null
      cells_speed_max: number | null
      injection_AB_start_position_min: number | null
      injection_AB_start_position_max: number | null
      injection_CD_start_position_min: number | null
      injection_CD_start_position_max: number | null
      injection_ABCD_end_position_min: number | null
      injection_ABCD_end_position_max: number | null
      tube_molding_start_position_min: number | null
      tube_molding_start_position_max: number | null
      tube_molding_end_position_min: number | null
      tube_molding_end_position_max: number | null
      polimerization_furnace_temperature_min: number | null
      polimerization_furnace_temperature_max: number | null
    }, ExtArgs["result"]["tube_parameters"]>
    composites: {}
  }

  type tube_parametersGetPayload<S extends boolean | null | undefined | tube_parametersDefaultArgs> = $Result.GetResult<Prisma.$tube_parametersPayload, S>

  type tube_parametersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_parametersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_parametersCountAggregateInputType | true
    }

  export interface tube_parametersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_parameters'], meta: { name: 'tube_parameters' } }
    /**
     * Find zero or one Tube_parameters that matches the filter.
     * @param {tube_parametersFindUniqueArgs} args - Arguments to find a Tube_parameters
     * @example
     * // Get one Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_parametersFindUniqueArgs>(args: SelectSubset<T, tube_parametersFindUniqueArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_parameters that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_parametersFindUniqueOrThrowArgs} args - Arguments to find a Tube_parameters
     * @example
     * // Get one Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_parametersFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_parametersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_parametersFindFirstArgs} args - Arguments to find a Tube_parameters
     * @example
     * // Get one Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_parametersFindFirstArgs>(args?: SelectSubset<T, tube_parametersFindFirstArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_parameters that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_parametersFindFirstOrThrowArgs} args - Arguments to find a Tube_parameters
     * @example
     * // Get one Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_parametersFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_parametersFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_parameters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_parametersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.findMany()
     * 
     * // Get first 10 Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_parametersWithIdOnly = await prisma.tube_parameters.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_parametersFindManyArgs>(args?: SelectSubset<T, tube_parametersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_parameters.
     * @param {tube_parametersCreateArgs} args - Arguments to create a Tube_parameters.
     * @example
     * // Create one Tube_parameters
     * const Tube_parameters = await prisma.tube_parameters.create({
     *   data: {
     *     // ... data to create a Tube_parameters
     *   }
     * })
     * 
     */
    create<T extends tube_parametersCreateArgs>(args: SelectSubset<T, tube_parametersCreateArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_parameters.
     * @param {tube_parametersCreateManyArgs} args - Arguments to create many Tube_parameters.
     * @example
     * // Create many Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_parametersCreateManyArgs>(args?: SelectSubset<T, tube_parametersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_parameters and returns the data saved in the database.
     * @param {tube_parametersCreateManyAndReturnArgs} args - Arguments to create many Tube_parameters.
     * @example
     * // Create many Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_parameters and only return the `id`
     * const tube_parametersWithIdOnly = await prisma.tube_parameters.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_parametersCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_parametersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_parameters.
     * @param {tube_parametersDeleteArgs} args - Arguments to delete one Tube_parameters.
     * @example
     * // Delete one Tube_parameters
     * const Tube_parameters = await prisma.tube_parameters.delete({
     *   where: {
     *     // ... filter to delete one Tube_parameters
     *   }
     * })
     * 
     */
    delete<T extends tube_parametersDeleteArgs>(args: SelectSubset<T, tube_parametersDeleteArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_parameters.
     * @param {tube_parametersUpdateArgs} args - Arguments to update one Tube_parameters.
     * @example
     * // Update one Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_parametersUpdateArgs>(args: SelectSubset<T, tube_parametersUpdateArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_parameters.
     * @param {tube_parametersDeleteManyArgs} args - Arguments to filter Tube_parameters to delete.
     * @example
     * // Delete a few Tube_parameters
     * const { count } = await prisma.tube_parameters.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_parametersDeleteManyArgs>(args?: SelectSubset<T, tube_parametersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_parametersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_parametersUpdateManyArgs>(args: SelectSubset<T, tube_parametersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_parameters and returns the data updated in the database.
     * @param {tube_parametersUpdateManyAndReturnArgs} args - Arguments to update many Tube_parameters.
     * @example
     * // Update many Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_parameters and only return the `id`
     * const tube_parametersWithIdOnly = await prisma.tube_parameters.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_parametersUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_parametersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_parameters.
     * @param {tube_parametersUpsertArgs} args - Arguments to update or create a Tube_parameters.
     * @example
     * // Update or create a Tube_parameters
     * const tube_parameters = await prisma.tube_parameters.upsert({
     *   create: {
     *     // ... data to create a Tube_parameters
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_parameters we want to update
     *   }
     * })
     */
    upsert<T extends tube_parametersUpsertArgs>(args: SelectSubset<T, tube_parametersUpsertArgs<ExtArgs>>): Prisma__tube_parametersClient<$Result.GetResult<Prisma.$tube_parametersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_parametersCountArgs} args - Arguments to filter Tube_parameters to count.
     * @example
     * // Count the number of Tube_parameters
     * const count = await prisma.tube_parameters.count({
     *   where: {
     *     // ... the filter for the Tube_parameters we want to count
     *   }
     * })
    **/
    count<T extends tube_parametersCountArgs>(
      args?: Subset<T, tube_parametersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_parametersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_parametersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_parametersAggregateArgs>(args: Subset<T, Tube_parametersAggregateArgs>): Prisma.PrismaPromise<GetTube_parametersAggregateType<T>>

    /**
     * Group by Tube_parameters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_parametersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_parametersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_parametersGroupByArgs['orderBy'] }
        : { orderBy?: tube_parametersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_parametersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_parametersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_parameters model
   */
  readonly fields: tube_parametersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_parameters.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_parametersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_parameters model
   */
  interface tube_parametersFieldRefs {
    readonly id: FieldRef<"tube_parameters", 'Int'>
    readonly tube_record_id: FieldRef<"tube_parameters", 'Int'>
    readonly press_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly press_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly molding_time_min: FieldRef<"tube_parameters", 'Int'>
    readonly molding_time_max: FieldRef<"tube_parameters", 'Int'>
    readonly turning_automate_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly turning_automate_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly annealing_furnace_temp_min: FieldRef<"tube_parameters", 'Int'>
    readonly annealing_furnace_temp_max: FieldRef<"tube_parameters", 'Int'>
    readonly cap_machine_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly cap_machine_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly cap_machine_air_pressure_min: FieldRef<"tube_parameters", 'Float'>
    readonly cap_machine_air_pressure_max: FieldRef<"tube_parameters", 'Float'>
    readonly grips_forward_min: FieldRef<"tube_parameters", 'Int'>
    readonly grips_forward_max: FieldRef<"tube_parameters", 'Int'>
    readonly grips_opening_left_min: FieldRef<"tube_parameters", 'Int'>
    readonly grips_opening_left_max: FieldRef<"tube_parameters", 'Int'>
    readonly grips_opening_right_min: FieldRef<"tube_parameters", 'Int'>
    readonly grips_opening_right_max: FieldRef<"tube_parameters", 'Int'>
    readonly grips_closing_min: FieldRef<"tube_parameters", 'Int'>
    readonly grips_closing_max: FieldRef<"tube_parameters", 'Int'>
    readonly injection_start_min: FieldRef<"tube_parameters", 'Int'>
    readonly injection_start_max: FieldRef<"tube_parameters", 'Int'>
    readonly injection_end_min: FieldRef<"tube_parameters", 'Int'>
    readonly injection_end_max: FieldRef<"tube_parameters", 'Int'>
    readonly tube_start_position_min: FieldRef<"tube_parameters", 'Int'>
    readonly tube_start_position_max: FieldRef<"tube_parameters", 'Int'>
    readonly tube_end_position_min: FieldRef<"tube_parameters", 'Int'>
    readonly tube_end_position_max: FieldRef<"tube_parameters", 'Int'>
    readonly padding_machine_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly padding_machine_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly padding_machine_air_pressure_min: FieldRef<"tube_parameters", 'Float'>
    readonly padding_machine_air_pressure_max: FieldRef<"tube_parameters", 'Float'>
    readonly padding_furnace_temp_min: FieldRef<"tube_parameters", 'Int'>
    readonly padding_furnace_temp_max: FieldRef<"tube_parameters", 'Int'>
    readonly offset_furnace_temp_min: FieldRef<"tube_parameters", 'Int'>
    readonly offset_furnace_temp_max: FieldRef<"tube_parameters", 'Int'>
    readonly printer_motor_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly printer_motor_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly holders_motor_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly holders_motor_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly station_motor_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly station_motor_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly ink_injection_time_min: FieldRef<"tube_parameters", 'Float'>
    readonly ink_injection_time_max: FieldRef<"tube_parameters", 'Float'>
    readonly lacquer_machine_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly lacquer_machine_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly lacquer_machine_air_pressure_min: FieldRef<"tube_parameters", 'Float'>
    readonly lacquer_machine_air_pressure_max: FieldRef<"tube_parameters", 'Float'>
    readonly feed_can_air_pressure_min: FieldRef<"tube_parameters", 'Float'>
    readonly feed_can_air_pressure_max: FieldRef<"tube_parameters", 'Float'>
    readonly nozzle_regulator_air_pressure_min: FieldRef<"tube_parameters", 'Float'>
    readonly nozzle_regulator_air_pressure_max: FieldRef<"tube_parameters", 'Float'>
    readonly cells_speed_min: FieldRef<"tube_parameters", 'Int'>
    readonly cells_speed_max: FieldRef<"tube_parameters", 'Int'>
    readonly injection_AB_start_position_min: FieldRef<"tube_parameters", 'Int'>
    readonly injection_AB_start_position_max: FieldRef<"tube_parameters", 'Int'>
    readonly injection_CD_start_position_min: FieldRef<"tube_parameters", 'Int'>
    readonly injection_CD_start_position_max: FieldRef<"tube_parameters", 'Int'>
    readonly injection_ABCD_end_position_min: FieldRef<"tube_parameters", 'Int'>
    readonly injection_ABCD_end_position_max: FieldRef<"tube_parameters", 'Int'>
    readonly tube_molding_start_position_min: FieldRef<"tube_parameters", 'Int'>
    readonly tube_molding_start_position_max: FieldRef<"tube_parameters", 'Int'>
    readonly tube_molding_end_position_min: FieldRef<"tube_parameters", 'Int'>
    readonly tube_molding_end_position_max: FieldRef<"tube_parameters", 'Int'>
    readonly polimerization_furnace_temperature_min: FieldRef<"tube_parameters", 'Int'>
    readonly polimerization_furnace_temperature_max: FieldRef<"tube_parameters", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * tube_parameters findUnique
   */
  export type tube_parametersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * Filter, which tube_parameters to fetch.
     */
    where: tube_parametersWhereUniqueInput
  }

  /**
   * tube_parameters findUniqueOrThrow
   */
  export type tube_parametersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * Filter, which tube_parameters to fetch.
     */
    where: tube_parametersWhereUniqueInput
  }

  /**
   * tube_parameters findFirst
   */
  export type tube_parametersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * Filter, which tube_parameters to fetch.
     */
    where?: tube_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_parameters to fetch.
     */
    orderBy?: tube_parametersOrderByWithRelationInput | tube_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_parameters.
     */
    cursor?: tube_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_parameters.
     */
    distinct?: Tube_parametersScalarFieldEnum | Tube_parametersScalarFieldEnum[]
  }

  /**
   * tube_parameters findFirstOrThrow
   */
  export type tube_parametersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * Filter, which tube_parameters to fetch.
     */
    where?: tube_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_parameters to fetch.
     */
    orderBy?: tube_parametersOrderByWithRelationInput | tube_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_parameters.
     */
    cursor?: tube_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_parameters.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_parameters.
     */
    distinct?: Tube_parametersScalarFieldEnum | Tube_parametersScalarFieldEnum[]
  }

  /**
   * tube_parameters findMany
   */
  export type tube_parametersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * Filter, which tube_parameters to fetch.
     */
    where?: tube_parametersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_parameters to fetch.
     */
    orderBy?: tube_parametersOrderByWithRelationInput | tube_parametersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_parameters.
     */
    cursor?: tube_parametersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_parameters from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_parameters.
     */
    skip?: number
    distinct?: Tube_parametersScalarFieldEnum | Tube_parametersScalarFieldEnum[]
  }

  /**
   * tube_parameters create
   */
  export type tube_parametersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * The data needed to create a tube_parameters.
     */
    data?: XOR<tube_parametersCreateInput, tube_parametersUncheckedCreateInput>
  }

  /**
   * tube_parameters createMany
   */
  export type tube_parametersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_parameters.
     */
    data: tube_parametersCreateManyInput | tube_parametersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_parameters createManyAndReturn
   */
  export type tube_parametersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * The data used to create many tube_parameters.
     */
    data: tube_parametersCreateManyInput | tube_parametersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_parameters update
   */
  export type tube_parametersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * The data needed to update a tube_parameters.
     */
    data: XOR<tube_parametersUpdateInput, tube_parametersUncheckedUpdateInput>
    /**
     * Choose, which tube_parameters to update.
     */
    where: tube_parametersWhereUniqueInput
  }

  /**
   * tube_parameters updateMany
   */
  export type tube_parametersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_parameters.
     */
    data: XOR<tube_parametersUpdateManyMutationInput, tube_parametersUncheckedUpdateManyInput>
    /**
     * Filter which tube_parameters to update
     */
    where?: tube_parametersWhereInput
    /**
     * Limit how many tube_parameters to update.
     */
    limit?: number
  }

  /**
   * tube_parameters updateManyAndReturn
   */
  export type tube_parametersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * The data used to update tube_parameters.
     */
    data: XOR<tube_parametersUpdateManyMutationInput, tube_parametersUncheckedUpdateManyInput>
    /**
     * Filter which tube_parameters to update
     */
    where?: tube_parametersWhereInput
    /**
     * Limit how many tube_parameters to update.
     */
    limit?: number
  }

  /**
   * tube_parameters upsert
   */
  export type tube_parametersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * The filter to search for the tube_parameters to update in case it exists.
     */
    where: tube_parametersWhereUniqueInput
    /**
     * In case the tube_parameters found by the `where` argument doesn't exist, create a new tube_parameters with this data.
     */
    create: XOR<tube_parametersCreateInput, tube_parametersUncheckedCreateInput>
    /**
     * In case the tube_parameters was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_parametersUpdateInput, tube_parametersUncheckedUpdateInput>
  }

  /**
   * tube_parameters delete
   */
  export type tube_parametersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
    /**
     * Filter which tube_parameters to delete.
     */
    where: tube_parametersWhereUniqueInput
  }

  /**
   * tube_parameters deleteMany
   */
  export type tube_parametersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_parameters to delete
     */
    where?: tube_parametersWhereInput
    /**
     * Limit how many tube_parameters to delete.
     */
    limit?: number
  }

  /**
   * tube_parameters without action
   */
  export type tube_parametersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_parameters
     */
    select?: tube_parametersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_parameters
     */
    omit?: tube_parametersOmit<ExtArgs> | null
  }


  /**
   * Model tube_products
   */

  export type AggregateTube_products = {
    _count: Tube_productsCountAggregateOutputType | null
    _avg: Tube_productsAvgAggregateOutputType | null
    _sum: Tube_productsSumAggregateOutputType | null
    _min: Tube_productsMinAggregateOutputType | null
    _max: Tube_productsMaxAggregateOutputType | null
  }

  export type Tube_productsAvgAggregateOutputType = {
    id: number | null
  }

  export type Tube_productsSumAggregateOutputType = {
    id: number | null
  }

  export type Tube_productsMinAggregateOutputType = {
    id: number | null
    code_1C: string | null
    marking: string | null
    name: string | null
  }

  export type Tube_productsMaxAggregateOutputType = {
    id: number | null
    code_1C: string | null
    marking: string | null
    name: string | null
  }

  export type Tube_productsCountAggregateOutputType = {
    id: number
    code_1C: number
    marking: number
    name: number
    _all: number
  }


  export type Tube_productsAvgAggregateInputType = {
    id?: true
  }

  export type Tube_productsSumAggregateInputType = {
    id?: true
  }

  export type Tube_productsMinAggregateInputType = {
    id?: true
    code_1C?: true
    marking?: true
    name?: true
  }

  export type Tube_productsMaxAggregateInputType = {
    id?: true
    code_1C?: true
    marking?: true
    name?: true
  }

  export type Tube_productsCountAggregateInputType = {
    id?: true
    code_1C?: true
    marking?: true
    name?: true
    _all?: true
  }

  export type Tube_productsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_products to aggregate.
     */
    where?: tube_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_products to fetch.
     */
    orderBy?: tube_productsOrderByWithRelationInput | tube_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_products
    **/
    _count?: true | Tube_productsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_productsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_productsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_productsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_productsMaxAggregateInputType
  }

  export type GetTube_productsAggregateType<T extends Tube_productsAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_products]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_products[P]>
      : GetScalarType<T[P], AggregateTube_products[P]>
  }




  export type tube_productsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_productsWhereInput
    orderBy?: tube_productsOrderByWithAggregationInput | tube_productsOrderByWithAggregationInput[]
    by: Tube_productsScalarFieldEnum[] | Tube_productsScalarFieldEnum
    having?: tube_productsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_productsCountAggregateInputType | true
    _avg?: Tube_productsAvgAggregateInputType
    _sum?: Tube_productsSumAggregateInputType
    _min?: Tube_productsMinAggregateInputType
    _max?: Tube_productsMaxAggregateInputType
  }

  export type Tube_productsGroupByOutputType = {
    id: number
    code_1C: string | null
    marking: string | null
    name: string | null
    _count: Tube_productsCountAggregateOutputType | null
    _avg: Tube_productsAvgAggregateOutputType | null
    _sum: Tube_productsSumAggregateOutputType | null
    _min: Tube_productsMinAggregateOutputType | null
    _max: Tube_productsMaxAggregateOutputType | null
  }

  type GetTube_productsGroupByPayload<T extends tube_productsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_productsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_productsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_productsGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_productsGroupByOutputType[P]>
        }
      >
    >


  export type tube_productsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code_1C?: boolean
    marking?: boolean
    name?: boolean
    tube_records?: boolean | tube_products$tube_recordsArgs<ExtArgs>
    tube_specifications?: boolean | tube_products$tube_specificationsArgs<ExtArgs>
    _count?: boolean | Tube_productsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tube_products"]>

  export type tube_productsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code_1C?: boolean
    marking?: boolean
    name?: boolean
  }, ExtArgs["result"]["tube_products"]>

  export type tube_productsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code_1C?: boolean
    marking?: boolean
    name?: boolean
  }, ExtArgs["result"]["tube_products"]>

  export type tube_productsSelectScalar = {
    id?: boolean
    code_1C?: boolean
    marking?: boolean
    name?: boolean
  }

  export type tube_productsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code_1C" | "marking" | "name", ExtArgs["result"]["tube_products"]>
  export type tube_productsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_records?: boolean | tube_products$tube_recordsArgs<ExtArgs>
    tube_specifications?: boolean | tube_products$tube_specificationsArgs<ExtArgs>
    _count?: boolean | Tube_productsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type tube_productsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type tube_productsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $tube_productsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_products"
    objects: {
      tube_records: Prisma.$tube_recordsPayload<ExtArgs>[]
      tube_specifications: Prisma.$tube_specificationsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code_1C: string | null
      marking: string | null
      name: string | null
    }, ExtArgs["result"]["tube_products"]>
    composites: {}
  }

  type tube_productsGetPayload<S extends boolean | null | undefined | tube_productsDefaultArgs> = $Result.GetResult<Prisma.$tube_productsPayload, S>

  type tube_productsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_productsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_productsCountAggregateInputType | true
    }

  export interface tube_productsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_products'], meta: { name: 'tube_products' } }
    /**
     * Find zero or one Tube_products that matches the filter.
     * @param {tube_productsFindUniqueArgs} args - Arguments to find a Tube_products
     * @example
     * // Get one Tube_products
     * const tube_products = await prisma.tube_products.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_productsFindUniqueArgs>(args: SelectSubset<T, tube_productsFindUniqueArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_products that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_productsFindUniqueOrThrowArgs} args - Arguments to find a Tube_products
     * @example
     * // Get one Tube_products
     * const tube_products = await prisma.tube_products.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_productsFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_productsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_productsFindFirstArgs} args - Arguments to find a Tube_products
     * @example
     * // Get one Tube_products
     * const tube_products = await prisma.tube_products.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_productsFindFirstArgs>(args?: SelectSubset<T, tube_productsFindFirstArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_products that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_productsFindFirstOrThrowArgs} args - Arguments to find a Tube_products
     * @example
     * // Get one Tube_products
     * const tube_products = await prisma.tube_products.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_productsFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_productsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_productsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_products
     * const tube_products = await prisma.tube_products.findMany()
     * 
     * // Get first 10 Tube_products
     * const tube_products = await prisma.tube_products.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_productsWithIdOnly = await prisma.tube_products.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_productsFindManyArgs>(args?: SelectSubset<T, tube_productsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_products.
     * @param {tube_productsCreateArgs} args - Arguments to create a Tube_products.
     * @example
     * // Create one Tube_products
     * const Tube_products = await prisma.tube_products.create({
     *   data: {
     *     // ... data to create a Tube_products
     *   }
     * })
     * 
     */
    create<T extends tube_productsCreateArgs>(args: SelectSubset<T, tube_productsCreateArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_products.
     * @param {tube_productsCreateManyArgs} args - Arguments to create many Tube_products.
     * @example
     * // Create many Tube_products
     * const tube_products = await prisma.tube_products.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_productsCreateManyArgs>(args?: SelectSubset<T, tube_productsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_products and returns the data saved in the database.
     * @param {tube_productsCreateManyAndReturnArgs} args - Arguments to create many Tube_products.
     * @example
     * // Create many Tube_products
     * const tube_products = await prisma.tube_products.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_products and only return the `id`
     * const tube_productsWithIdOnly = await prisma.tube_products.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_productsCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_productsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_products.
     * @param {tube_productsDeleteArgs} args - Arguments to delete one Tube_products.
     * @example
     * // Delete one Tube_products
     * const Tube_products = await prisma.tube_products.delete({
     *   where: {
     *     // ... filter to delete one Tube_products
     *   }
     * })
     * 
     */
    delete<T extends tube_productsDeleteArgs>(args: SelectSubset<T, tube_productsDeleteArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_products.
     * @param {tube_productsUpdateArgs} args - Arguments to update one Tube_products.
     * @example
     * // Update one Tube_products
     * const tube_products = await prisma.tube_products.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_productsUpdateArgs>(args: SelectSubset<T, tube_productsUpdateArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_products.
     * @param {tube_productsDeleteManyArgs} args - Arguments to filter Tube_products to delete.
     * @example
     * // Delete a few Tube_products
     * const { count } = await prisma.tube_products.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_productsDeleteManyArgs>(args?: SelectSubset<T, tube_productsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_productsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_products
     * const tube_products = await prisma.tube_products.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_productsUpdateManyArgs>(args: SelectSubset<T, tube_productsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_products and returns the data updated in the database.
     * @param {tube_productsUpdateManyAndReturnArgs} args - Arguments to update many Tube_products.
     * @example
     * // Update many Tube_products
     * const tube_products = await prisma.tube_products.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_products and only return the `id`
     * const tube_productsWithIdOnly = await prisma.tube_products.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_productsUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_productsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_products.
     * @param {tube_productsUpsertArgs} args - Arguments to update or create a Tube_products.
     * @example
     * // Update or create a Tube_products
     * const tube_products = await prisma.tube_products.upsert({
     *   create: {
     *     // ... data to create a Tube_products
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_products we want to update
     *   }
     * })
     */
    upsert<T extends tube_productsUpsertArgs>(args: SelectSubset<T, tube_productsUpsertArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_productsCountArgs} args - Arguments to filter Tube_products to count.
     * @example
     * // Count the number of Tube_products
     * const count = await prisma.tube_products.count({
     *   where: {
     *     // ... the filter for the Tube_products we want to count
     *   }
     * })
    **/
    count<T extends tube_productsCountArgs>(
      args?: Subset<T, tube_productsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_productsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_productsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_productsAggregateArgs>(args: Subset<T, Tube_productsAggregateArgs>): Prisma.PrismaPromise<GetTube_productsAggregateType<T>>

    /**
     * Group by Tube_products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_productsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_productsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_productsGroupByArgs['orderBy'] }
        : { orderBy?: tube_productsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_productsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_productsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_products model
   */
  readonly fields: tube_productsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_products.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_productsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_records<T extends tube_products$tube_recordsArgs<ExtArgs> = {}>(args?: Subset<T, tube_products$tube_recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tube_specifications<T extends tube_products$tube_specificationsArgs<ExtArgs> = {}>(args?: Subset<T, tube_products$tube_specificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_products model
   */
  interface tube_productsFieldRefs {
    readonly id: FieldRef<"tube_products", 'Int'>
    readonly code_1C: FieldRef<"tube_products", 'String'>
    readonly marking: FieldRef<"tube_products", 'String'>
    readonly name: FieldRef<"tube_products", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tube_products findUnique
   */
  export type tube_productsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * Filter, which tube_products to fetch.
     */
    where: tube_productsWhereUniqueInput
  }

  /**
   * tube_products findUniqueOrThrow
   */
  export type tube_productsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * Filter, which tube_products to fetch.
     */
    where: tube_productsWhereUniqueInput
  }

  /**
   * tube_products findFirst
   */
  export type tube_productsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * Filter, which tube_products to fetch.
     */
    where?: tube_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_products to fetch.
     */
    orderBy?: tube_productsOrderByWithRelationInput | tube_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_products.
     */
    cursor?: tube_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_products.
     */
    distinct?: Tube_productsScalarFieldEnum | Tube_productsScalarFieldEnum[]
  }

  /**
   * tube_products findFirstOrThrow
   */
  export type tube_productsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * Filter, which tube_products to fetch.
     */
    where?: tube_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_products to fetch.
     */
    orderBy?: tube_productsOrderByWithRelationInput | tube_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_products.
     */
    cursor?: tube_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_products.
     */
    distinct?: Tube_productsScalarFieldEnum | Tube_productsScalarFieldEnum[]
  }

  /**
   * tube_products findMany
   */
  export type tube_productsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * Filter, which tube_products to fetch.
     */
    where?: tube_productsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_products to fetch.
     */
    orderBy?: tube_productsOrderByWithRelationInput | tube_productsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_products.
     */
    cursor?: tube_productsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_products.
     */
    skip?: number
    distinct?: Tube_productsScalarFieldEnum | Tube_productsScalarFieldEnum[]
  }

  /**
   * tube_products create
   */
  export type tube_productsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_products.
     */
    data?: XOR<tube_productsCreateInput, tube_productsUncheckedCreateInput>
  }

  /**
   * tube_products createMany
   */
  export type tube_productsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_products.
     */
    data: tube_productsCreateManyInput | tube_productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_products createManyAndReturn
   */
  export type tube_productsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * The data used to create many tube_products.
     */
    data: tube_productsCreateManyInput | tube_productsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_products update
   */
  export type tube_productsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_products.
     */
    data: XOR<tube_productsUpdateInput, tube_productsUncheckedUpdateInput>
    /**
     * Choose, which tube_products to update.
     */
    where: tube_productsWhereUniqueInput
  }

  /**
   * tube_products updateMany
   */
  export type tube_productsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_products.
     */
    data: XOR<tube_productsUpdateManyMutationInput, tube_productsUncheckedUpdateManyInput>
    /**
     * Filter which tube_products to update
     */
    where?: tube_productsWhereInput
    /**
     * Limit how many tube_products to update.
     */
    limit?: number
  }

  /**
   * tube_products updateManyAndReturn
   */
  export type tube_productsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * The data used to update tube_products.
     */
    data: XOR<tube_productsUpdateManyMutationInput, tube_productsUncheckedUpdateManyInput>
    /**
     * Filter which tube_products to update
     */
    where?: tube_productsWhereInput
    /**
     * Limit how many tube_products to update.
     */
    limit?: number
  }

  /**
   * tube_products upsert
   */
  export type tube_productsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_products to update in case it exists.
     */
    where: tube_productsWhereUniqueInput
    /**
     * In case the tube_products found by the `where` argument doesn't exist, create a new tube_products with this data.
     */
    create: XOR<tube_productsCreateInput, tube_productsUncheckedCreateInput>
    /**
     * In case the tube_products was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_productsUpdateInput, tube_productsUncheckedUpdateInput>
  }

  /**
   * tube_products delete
   */
  export type tube_productsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    /**
     * Filter which tube_products to delete.
     */
    where: tube_productsWhereUniqueInput
  }

  /**
   * tube_products deleteMany
   */
  export type tube_productsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_products to delete
     */
    where?: tube_productsWhereInput
    /**
     * Limit how many tube_products to delete.
     */
    limit?: number
  }

  /**
   * tube_products.tube_records
   */
  export type tube_products$tube_recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    where?: tube_recordsWhereInput
    orderBy?: tube_recordsOrderByWithRelationInput | tube_recordsOrderByWithRelationInput[]
    cursor?: tube_recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_recordsScalarFieldEnum | Tube_recordsScalarFieldEnum[]
  }

  /**
   * tube_products.tube_specifications
   */
  export type tube_products$tube_specificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    where?: tube_specificationsWhereInput
    orderBy?: tube_specificationsOrderByWithRelationInput | tube_specificationsOrderByWithRelationInput[]
    cursor?: tube_specificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Tube_specificationsScalarFieldEnum | Tube_specificationsScalarFieldEnum[]
  }

  /**
   * tube_products without action
   */
  export type tube_productsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
  }


  /**
   * Model tube_records
   */

  export type AggregateTube_records = {
    _count: Tube_recordsCountAggregateOutputType | null
    _avg: Tube_recordsAvgAggregateOutputType | null
    _sum: Tube_recordsSumAggregateOutputType | null
    _min: Tube_recordsMinAggregateOutputType | null
    _max: Tube_recordsMaxAggregateOutputType | null
  }

  export type Tube_recordsAvgAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_conveyor_id: number | null
    boil_id: number | null
    plan: number | null
  }

  export type Tube_recordsSumAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_conveyor_id: number | null
    boil_id: number | null
    plan: number | null
  }

  export type Tube_recordsMinAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_conveyor_id: number | null
    boil_id: number | null
    plan: number | null
    start_date: Date | null
    active: boolean | null
    finished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_recordsMaxAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_conveyor_id: number | null
    boil_id: number | null
    plan: number | null
    start_date: Date | null
    active: boolean | null
    finished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_recordsCountAggregateOutputType = {
    id: number
    tube_product_id: number
    tube_conveyor_id: number
    boil_id: number
    plan: number
    start_date: number
    active: number
    finished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tube_recordsAvgAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_conveyor_id?: true
    boil_id?: true
    plan?: true
  }

  export type Tube_recordsSumAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_conveyor_id?: true
    boil_id?: true
    plan?: true
  }

  export type Tube_recordsMinAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_conveyor_id?: true
    boil_id?: true
    plan?: true
    start_date?: true
    active?: true
    finished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_recordsMaxAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_conveyor_id?: true
    boil_id?: true
    plan?: true
    start_date?: true
    active?: true
    finished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_recordsCountAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_conveyor_id?: true
    boil_id?: true
    plan?: true
    start_date?: true
    active?: true
    finished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tube_recordsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_records to aggregate.
     */
    where?: tube_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_records to fetch.
     */
    orderBy?: tube_recordsOrderByWithRelationInput | tube_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_records
    **/
    _count?: true | Tube_recordsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_recordsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_recordsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_recordsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_recordsMaxAggregateInputType
  }

  export type GetTube_recordsAggregateType<T extends Tube_recordsAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_records]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_records[P]>
      : GetScalarType<T[P], AggregateTube_records[P]>
  }




  export type tube_recordsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_recordsWhereInput
    orderBy?: tube_recordsOrderByWithAggregationInput | tube_recordsOrderByWithAggregationInput[]
    by: Tube_recordsScalarFieldEnum[] | Tube_recordsScalarFieldEnum
    having?: tube_recordsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_recordsCountAggregateInputType | true
    _avg?: Tube_recordsAvgAggregateInputType
    _sum?: Tube_recordsSumAggregateInputType
    _min?: Tube_recordsMinAggregateInputType
    _max?: Tube_recordsMaxAggregateInputType
  }

  export type Tube_recordsGroupByOutputType = {
    id: number
    tube_product_id: number | null
    tube_conveyor_id: number | null
    boil_id: number | null
    plan: number
    start_date: Date | null
    active: boolean | null
    finished: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: Tube_recordsCountAggregateOutputType | null
    _avg: Tube_recordsAvgAggregateOutputType | null
    _sum: Tube_recordsSumAggregateOutputType | null
    _min: Tube_recordsMinAggregateOutputType | null
    _max: Tube_recordsMaxAggregateOutputType | null
  }

  type GetTube_recordsGroupByPayload<T extends tube_recordsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_recordsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_recordsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_recordsGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_recordsGroupByOutputType[P]>
        }
      >
    >


  export type tube_recordsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_product_id?: boolean
    tube_conveyor_id?: boolean
    boil_id?: boolean
    plan?: boolean
    start_date?: boolean
    active?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boils?: boolean | tube_records$boilsArgs<ExtArgs>
    tube_conveyors?: boolean | tube_records$tube_conveyorsArgs<ExtArgs>
    tube_products?: boolean | tube_records$tube_productsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_records"]>

  export type tube_recordsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_product_id?: boolean
    tube_conveyor_id?: boolean
    boil_id?: boolean
    plan?: boolean
    start_date?: boolean
    active?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boils?: boolean | tube_records$boilsArgs<ExtArgs>
    tube_conveyors?: boolean | tube_records$tube_conveyorsArgs<ExtArgs>
    tube_products?: boolean | tube_records$tube_productsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_records"]>

  export type tube_recordsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_product_id?: boolean
    tube_conveyor_id?: boolean
    boil_id?: boolean
    plan?: boolean
    start_date?: boolean
    active?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    boils?: boolean | tube_records$boilsArgs<ExtArgs>
    tube_conveyors?: boolean | tube_records$tube_conveyorsArgs<ExtArgs>
    tube_products?: boolean | tube_records$tube_productsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_records"]>

  export type tube_recordsSelectScalar = {
    id?: boolean
    tube_product_id?: boolean
    tube_conveyor_id?: boolean
    boil_id?: boolean
    plan?: boolean
    start_date?: boolean
    active?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tube_recordsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tube_product_id" | "tube_conveyor_id" | "boil_id" | "plan" | "start_date" | "active" | "finished" | "createdAt" | "updatedAt", ExtArgs["result"]["tube_records"]>
  export type tube_recordsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | tube_records$boilsArgs<ExtArgs>
    tube_conveyors?: boolean | tube_records$tube_conveyorsArgs<ExtArgs>
    tube_products?: boolean | tube_records$tube_productsArgs<ExtArgs>
  }
  export type tube_recordsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | tube_records$boilsArgs<ExtArgs>
    tube_conveyors?: boolean | tube_records$tube_conveyorsArgs<ExtArgs>
    tube_products?: boolean | tube_records$tube_productsArgs<ExtArgs>
  }
  export type tube_recordsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    boils?: boolean | tube_records$boilsArgs<ExtArgs>
    tube_conveyors?: boolean | tube_records$tube_conveyorsArgs<ExtArgs>
    tube_products?: boolean | tube_records$tube_productsArgs<ExtArgs>
  }

  export type $tube_recordsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_records"
    objects: {
      boils: Prisma.$boilsPayload<ExtArgs> | null
      tube_conveyors: Prisma.$tube_conveyorsPayload<ExtArgs> | null
      tube_products: Prisma.$tube_productsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tube_product_id: number | null
      tube_conveyor_id: number | null
      boil_id: number | null
      plan: number
      start_date: Date | null
      active: boolean | null
      finished: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tube_records"]>
    composites: {}
  }

  type tube_recordsGetPayload<S extends boolean | null | undefined | tube_recordsDefaultArgs> = $Result.GetResult<Prisma.$tube_recordsPayload, S>

  type tube_recordsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_recordsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_recordsCountAggregateInputType | true
    }

  export interface tube_recordsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_records'], meta: { name: 'tube_records' } }
    /**
     * Find zero or one Tube_records that matches the filter.
     * @param {tube_recordsFindUniqueArgs} args - Arguments to find a Tube_records
     * @example
     * // Get one Tube_records
     * const tube_records = await prisma.tube_records.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_recordsFindUniqueArgs>(args: SelectSubset<T, tube_recordsFindUniqueArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_records that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_recordsFindUniqueOrThrowArgs} args - Arguments to find a Tube_records
     * @example
     * // Get one Tube_records
     * const tube_records = await prisma.tube_records.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_recordsFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_recordsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_recordsFindFirstArgs} args - Arguments to find a Tube_records
     * @example
     * // Get one Tube_records
     * const tube_records = await prisma.tube_records.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_recordsFindFirstArgs>(args?: SelectSubset<T, tube_recordsFindFirstArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_records that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_recordsFindFirstOrThrowArgs} args - Arguments to find a Tube_records
     * @example
     * // Get one Tube_records
     * const tube_records = await prisma.tube_records.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_recordsFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_recordsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_records that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_recordsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_records
     * const tube_records = await prisma.tube_records.findMany()
     * 
     * // Get first 10 Tube_records
     * const tube_records = await prisma.tube_records.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_recordsWithIdOnly = await prisma.tube_records.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_recordsFindManyArgs>(args?: SelectSubset<T, tube_recordsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_records.
     * @param {tube_recordsCreateArgs} args - Arguments to create a Tube_records.
     * @example
     * // Create one Tube_records
     * const Tube_records = await prisma.tube_records.create({
     *   data: {
     *     // ... data to create a Tube_records
     *   }
     * })
     * 
     */
    create<T extends tube_recordsCreateArgs>(args: SelectSubset<T, tube_recordsCreateArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_records.
     * @param {tube_recordsCreateManyArgs} args - Arguments to create many Tube_records.
     * @example
     * // Create many Tube_records
     * const tube_records = await prisma.tube_records.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_recordsCreateManyArgs>(args?: SelectSubset<T, tube_recordsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_records and returns the data saved in the database.
     * @param {tube_recordsCreateManyAndReturnArgs} args - Arguments to create many Tube_records.
     * @example
     * // Create many Tube_records
     * const tube_records = await prisma.tube_records.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_records and only return the `id`
     * const tube_recordsWithIdOnly = await prisma.tube_records.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_recordsCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_recordsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_records.
     * @param {tube_recordsDeleteArgs} args - Arguments to delete one Tube_records.
     * @example
     * // Delete one Tube_records
     * const Tube_records = await prisma.tube_records.delete({
     *   where: {
     *     // ... filter to delete one Tube_records
     *   }
     * })
     * 
     */
    delete<T extends tube_recordsDeleteArgs>(args: SelectSubset<T, tube_recordsDeleteArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_records.
     * @param {tube_recordsUpdateArgs} args - Arguments to update one Tube_records.
     * @example
     * // Update one Tube_records
     * const tube_records = await prisma.tube_records.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_recordsUpdateArgs>(args: SelectSubset<T, tube_recordsUpdateArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_records.
     * @param {tube_recordsDeleteManyArgs} args - Arguments to filter Tube_records to delete.
     * @example
     * // Delete a few Tube_records
     * const { count } = await prisma.tube_records.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_recordsDeleteManyArgs>(args?: SelectSubset<T, tube_recordsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_recordsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_records
     * const tube_records = await prisma.tube_records.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_recordsUpdateManyArgs>(args: SelectSubset<T, tube_recordsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_records and returns the data updated in the database.
     * @param {tube_recordsUpdateManyAndReturnArgs} args - Arguments to update many Tube_records.
     * @example
     * // Update many Tube_records
     * const tube_records = await prisma.tube_records.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_records and only return the `id`
     * const tube_recordsWithIdOnly = await prisma.tube_records.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_recordsUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_recordsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_records.
     * @param {tube_recordsUpsertArgs} args - Arguments to update or create a Tube_records.
     * @example
     * // Update or create a Tube_records
     * const tube_records = await prisma.tube_records.upsert({
     *   create: {
     *     // ... data to create a Tube_records
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_records we want to update
     *   }
     * })
     */
    upsert<T extends tube_recordsUpsertArgs>(args: SelectSubset<T, tube_recordsUpsertArgs<ExtArgs>>): Prisma__tube_recordsClient<$Result.GetResult<Prisma.$tube_recordsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_recordsCountArgs} args - Arguments to filter Tube_records to count.
     * @example
     * // Count the number of Tube_records
     * const count = await prisma.tube_records.count({
     *   where: {
     *     // ... the filter for the Tube_records we want to count
     *   }
     * })
    **/
    count<T extends tube_recordsCountArgs>(
      args?: Subset<T, tube_recordsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_recordsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_recordsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_recordsAggregateArgs>(args: Subset<T, Tube_recordsAggregateArgs>): Prisma.PrismaPromise<GetTube_recordsAggregateType<T>>

    /**
     * Group by Tube_records.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_recordsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_recordsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_recordsGroupByArgs['orderBy'] }
        : { orderBy?: tube_recordsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_recordsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_recordsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_records model
   */
  readonly fields: tube_recordsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_records.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_recordsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    boils<T extends tube_records$boilsArgs<ExtArgs> = {}>(args?: Subset<T, tube_records$boilsArgs<ExtArgs>>): Prisma__boilsClient<$Result.GetResult<Prisma.$boilsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tube_conveyors<T extends tube_records$tube_conveyorsArgs<ExtArgs> = {}>(args?: Subset<T, tube_records$tube_conveyorsArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tube_products<T extends tube_records$tube_productsArgs<ExtArgs> = {}>(args?: Subset<T, tube_records$tube_productsArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_records model
   */
  interface tube_recordsFieldRefs {
    readonly id: FieldRef<"tube_records", 'Int'>
    readonly tube_product_id: FieldRef<"tube_records", 'Int'>
    readonly tube_conveyor_id: FieldRef<"tube_records", 'Int'>
    readonly boil_id: FieldRef<"tube_records", 'Int'>
    readonly plan: FieldRef<"tube_records", 'Int'>
    readonly start_date: FieldRef<"tube_records", 'DateTime'>
    readonly active: FieldRef<"tube_records", 'Boolean'>
    readonly finished: FieldRef<"tube_records", 'Boolean'>
    readonly createdAt: FieldRef<"tube_records", 'DateTime'>
    readonly updatedAt: FieldRef<"tube_records", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tube_records findUnique
   */
  export type tube_recordsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * Filter, which tube_records to fetch.
     */
    where: tube_recordsWhereUniqueInput
  }

  /**
   * tube_records findUniqueOrThrow
   */
  export type tube_recordsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * Filter, which tube_records to fetch.
     */
    where: tube_recordsWhereUniqueInput
  }

  /**
   * tube_records findFirst
   */
  export type tube_recordsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * Filter, which tube_records to fetch.
     */
    where?: tube_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_records to fetch.
     */
    orderBy?: tube_recordsOrderByWithRelationInput | tube_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_records.
     */
    cursor?: tube_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_records.
     */
    distinct?: Tube_recordsScalarFieldEnum | Tube_recordsScalarFieldEnum[]
  }

  /**
   * tube_records findFirstOrThrow
   */
  export type tube_recordsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * Filter, which tube_records to fetch.
     */
    where?: tube_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_records to fetch.
     */
    orderBy?: tube_recordsOrderByWithRelationInput | tube_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_records.
     */
    cursor?: tube_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_records.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_records.
     */
    distinct?: Tube_recordsScalarFieldEnum | Tube_recordsScalarFieldEnum[]
  }

  /**
   * tube_records findMany
   */
  export type tube_recordsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * Filter, which tube_records to fetch.
     */
    where?: tube_recordsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_records to fetch.
     */
    orderBy?: tube_recordsOrderByWithRelationInput | tube_recordsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_records.
     */
    cursor?: tube_recordsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_records from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_records.
     */
    skip?: number
    distinct?: Tube_recordsScalarFieldEnum | Tube_recordsScalarFieldEnum[]
  }

  /**
   * tube_records create
   */
  export type tube_recordsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_records.
     */
    data: XOR<tube_recordsCreateInput, tube_recordsUncheckedCreateInput>
  }

  /**
   * tube_records createMany
   */
  export type tube_recordsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_records.
     */
    data: tube_recordsCreateManyInput | tube_recordsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_records createManyAndReturn
   */
  export type tube_recordsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * The data used to create many tube_records.
     */
    data: tube_recordsCreateManyInput | tube_recordsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_records update
   */
  export type tube_recordsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_records.
     */
    data: XOR<tube_recordsUpdateInput, tube_recordsUncheckedUpdateInput>
    /**
     * Choose, which tube_records to update.
     */
    where: tube_recordsWhereUniqueInput
  }

  /**
   * tube_records updateMany
   */
  export type tube_recordsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_records.
     */
    data: XOR<tube_recordsUpdateManyMutationInput, tube_recordsUncheckedUpdateManyInput>
    /**
     * Filter which tube_records to update
     */
    where?: tube_recordsWhereInput
    /**
     * Limit how many tube_records to update.
     */
    limit?: number
  }

  /**
   * tube_records updateManyAndReturn
   */
  export type tube_recordsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * The data used to update tube_records.
     */
    data: XOR<tube_recordsUpdateManyMutationInput, tube_recordsUncheckedUpdateManyInput>
    /**
     * Filter which tube_records to update
     */
    where?: tube_recordsWhereInput
    /**
     * Limit how many tube_records to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_records upsert
   */
  export type tube_recordsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_records to update in case it exists.
     */
    where: tube_recordsWhereUniqueInput
    /**
     * In case the tube_records found by the `where` argument doesn't exist, create a new tube_records with this data.
     */
    create: XOR<tube_recordsCreateInput, tube_recordsUncheckedCreateInput>
    /**
     * In case the tube_records was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_recordsUpdateInput, tube_recordsUncheckedUpdateInput>
  }

  /**
   * tube_records delete
   */
  export type tube_recordsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
    /**
     * Filter which tube_records to delete.
     */
    where: tube_recordsWhereUniqueInput
  }

  /**
   * tube_records deleteMany
   */
  export type tube_recordsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_records to delete
     */
    where?: tube_recordsWhereInput
    /**
     * Limit how many tube_records to delete.
     */
    limit?: number
  }

  /**
   * tube_records.boils
   */
  export type tube_records$boilsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the boils
     */
    select?: boilsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the boils
     */
    omit?: boilsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: boilsInclude<ExtArgs> | null
    where?: boilsWhereInput
  }

  /**
   * tube_records.tube_conveyors
   */
  export type tube_records$tube_conveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    where?: tube_conveyorsWhereInput
  }

  /**
   * tube_records.tube_products
   */
  export type tube_records$tube_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    where?: tube_productsWhereInput
  }

  /**
   * tube_records without action
   */
  export type tube_recordsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_records
     */
    select?: tube_recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_records
     */
    omit?: tube_recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_recordsInclude<ExtArgs> | null
  }


  /**
   * Model tube_sessions
   */

  export type AggregateTube_sessions = {
    _count: Tube_sessionsCountAggregateOutputType | null
    _avg: Tube_sessionsAvgAggregateOutputType | null
    _sum: Tube_sessionsSumAggregateOutputType | null
    _min: Tube_sessionsMinAggregateOutputType | null
    _max: Tube_sessionsMaxAggregateOutputType | null
  }

  export type Tube_sessionsAvgAggregateOutputType = {
    id: number | null
    conveyor_id: number | null
    employee_id: number | null
  }

  export type Tube_sessionsSumAggregateOutputType = {
    id: number | null
    conveyor_id: number | null
    employee_id: number | null
  }

  export type Tube_sessionsMinAggregateOutputType = {
    id: number | null
    conveyor_id: number | null
    employee_id: number | null
    finished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_sessionsMaxAggregateOutputType = {
    id: number | null
    conveyor_id: number | null
    employee_id: number | null
    finished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_sessionsCountAggregateOutputType = {
    id: number
    conveyor_id: number
    employee_id: number
    finished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tube_sessionsAvgAggregateInputType = {
    id?: true
    conveyor_id?: true
    employee_id?: true
  }

  export type Tube_sessionsSumAggregateInputType = {
    id?: true
    conveyor_id?: true
    employee_id?: true
  }

  export type Tube_sessionsMinAggregateInputType = {
    id?: true
    conveyor_id?: true
    employee_id?: true
    finished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_sessionsMaxAggregateInputType = {
    id?: true
    conveyor_id?: true
    employee_id?: true
    finished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_sessionsCountAggregateInputType = {
    id?: true
    conveyor_id?: true
    employee_id?: true
    finished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tube_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_sessions to aggregate.
     */
    where?: tube_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_sessions to fetch.
     */
    orderBy?: tube_sessionsOrderByWithRelationInput | tube_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_sessions
    **/
    _count?: true | Tube_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_sessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_sessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_sessionsMaxAggregateInputType
  }

  export type GetTube_sessionsAggregateType<T extends Tube_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_sessions[P]>
      : GetScalarType<T[P], AggregateTube_sessions[P]>
  }




  export type tube_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_sessionsWhereInput
    orderBy?: tube_sessionsOrderByWithAggregationInput | tube_sessionsOrderByWithAggregationInput[]
    by: Tube_sessionsScalarFieldEnum[] | Tube_sessionsScalarFieldEnum
    having?: tube_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_sessionsCountAggregateInputType | true
    _avg?: Tube_sessionsAvgAggregateInputType
    _sum?: Tube_sessionsSumAggregateInputType
    _min?: Tube_sessionsMinAggregateInputType
    _max?: Tube_sessionsMaxAggregateInputType
  }

  export type Tube_sessionsGroupByOutputType = {
    id: number
    conveyor_id: number | null
    employee_id: number | null
    finished: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: Tube_sessionsCountAggregateOutputType | null
    _avg: Tube_sessionsAvgAggregateOutputType | null
    _sum: Tube_sessionsSumAggregateOutputType | null
    _min: Tube_sessionsMinAggregateOutputType | null
    _max: Tube_sessionsMaxAggregateOutputType | null
  }

  type GetTube_sessionsGroupByPayload<T extends tube_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type tube_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conveyor_id?: boolean
    employee_id?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_conveyors?: boolean | tube_sessions$tube_conveyorsArgs<ExtArgs>
    employees?: boolean | tube_sessions$employeesArgs<ExtArgs>
  }, ExtArgs["result"]["tube_sessions"]>

  export type tube_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conveyor_id?: boolean
    employee_id?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_conveyors?: boolean | tube_sessions$tube_conveyorsArgs<ExtArgs>
    employees?: boolean | tube_sessions$employeesArgs<ExtArgs>
  }, ExtArgs["result"]["tube_sessions"]>

  export type tube_sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conveyor_id?: boolean
    employee_id?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_conveyors?: boolean | tube_sessions$tube_conveyorsArgs<ExtArgs>
    employees?: boolean | tube_sessions$employeesArgs<ExtArgs>
  }, ExtArgs["result"]["tube_sessions"]>

  export type tube_sessionsSelectScalar = {
    id?: boolean
    conveyor_id?: boolean
    employee_id?: boolean
    finished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tube_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conveyor_id" | "employee_id" | "finished" | "createdAt" | "updatedAt", ExtArgs["result"]["tube_sessions"]>
  export type tube_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_conveyors?: boolean | tube_sessions$tube_conveyorsArgs<ExtArgs>
    employees?: boolean | tube_sessions$employeesArgs<ExtArgs>
  }
  export type tube_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_conveyors?: boolean | tube_sessions$tube_conveyorsArgs<ExtArgs>
    employees?: boolean | tube_sessions$employeesArgs<ExtArgs>
  }
  export type tube_sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_conveyors?: boolean | tube_sessions$tube_conveyorsArgs<ExtArgs>
    employees?: boolean | tube_sessions$employeesArgs<ExtArgs>
  }

  export type $tube_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_sessions"
    objects: {
      tube_conveyors: Prisma.$tube_conveyorsPayload<ExtArgs> | null
      employees: Prisma.$employeesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      conveyor_id: number | null
      employee_id: number | null
      finished: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tube_sessions"]>
    composites: {}
  }

  type tube_sessionsGetPayload<S extends boolean | null | undefined | tube_sessionsDefaultArgs> = $Result.GetResult<Prisma.$tube_sessionsPayload, S>

  type tube_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_sessionsCountAggregateInputType | true
    }

  export interface tube_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_sessions'], meta: { name: 'tube_sessions' } }
    /**
     * Find zero or one Tube_sessions that matches the filter.
     * @param {tube_sessionsFindUniqueArgs} args - Arguments to find a Tube_sessions
     * @example
     * // Get one Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_sessionsFindUniqueArgs>(args: SelectSubset<T, tube_sessionsFindUniqueArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Tube_sessions
     * @example
     * // Get one Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_sessionsFindFirstArgs} args - Arguments to find a Tube_sessions
     * @example
     * // Get one Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_sessionsFindFirstArgs>(args?: SelectSubset<T, tube_sessionsFindFirstArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_sessionsFindFirstOrThrowArgs} args - Arguments to find a Tube_sessions
     * @example
     * // Get one Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.findMany()
     * 
     * // Get first 10 Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_sessionsWithIdOnly = await prisma.tube_sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_sessionsFindManyArgs>(args?: SelectSubset<T, tube_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_sessions.
     * @param {tube_sessionsCreateArgs} args - Arguments to create a Tube_sessions.
     * @example
     * // Create one Tube_sessions
     * const Tube_sessions = await prisma.tube_sessions.create({
     *   data: {
     *     // ... data to create a Tube_sessions
     *   }
     * })
     * 
     */
    create<T extends tube_sessionsCreateArgs>(args: SelectSubset<T, tube_sessionsCreateArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_sessions.
     * @param {tube_sessionsCreateManyArgs} args - Arguments to create many Tube_sessions.
     * @example
     * // Create many Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_sessionsCreateManyArgs>(args?: SelectSubset<T, tube_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_sessions and returns the data saved in the database.
     * @param {tube_sessionsCreateManyAndReturnArgs} args - Arguments to create many Tube_sessions.
     * @example
     * // Create many Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_sessions and only return the `id`
     * const tube_sessionsWithIdOnly = await prisma.tube_sessions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_sessions.
     * @param {tube_sessionsDeleteArgs} args - Arguments to delete one Tube_sessions.
     * @example
     * // Delete one Tube_sessions
     * const Tube_sessions = await prisma.tube_sessions.delete({
     *   where: {
     *     // ... filter to delete one Tube_sessions
     *   }
     * })
     * 
     */
    delete<T extends tube_sessionsDeleteArgs>(args: SelectSubset<T, tube_sessionsDeleteArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_sessions.
     * @param {tube_sessionsUpdateArgs} args - Arguments to update one Tube_sessions.
     * @example
     * // Update one Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_sessionsUpdateArgs>(args: SelectSubset<T, tube_sessionsUpdateArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_sessions.
     * @param {tube_sessionsDeleteManyArgs} args - Arguments to filter Tube_sessions to delete.
     * @example
     * // Delete a few Tube_sessions
     * const { count } = await prisma.tube_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_sessionsDeleteManyArgs>(args?: SelectSubset<T, tube_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_sessionsUpdateManyArgs>(args: SelectSubset<T, tube_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_sessions and returns the data updated in the database.
     * @param {tube_sessionsUpdateManyAndReturnArgs} args - Arguments to update many Tube_sessions.
     * @example
     * // Update many Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_sessions and only return the `id`
     * const tube_sessionsWithIdOnly = await prisma.tube_sessions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_sessions.
     * @param {tube_sessionsUpsertArgs} args - Arguments to update or create a Tube_sessions.
     * @example
     * // Update or create a Tube_sessions
     * const tube_sessions = await prisma.tube_sessions.upsert({
     *   create: {
     *     // ... data to create a Tube_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_sessions we want to update
     *   }
     * })
     */
    upsert<T extends tube_sessionsUpsertArgs>(args: SelectSubset<T, tube_sessionsUpsertArgs<ExtArgs>>): Prisma__tube_sessionsClient<$Result.GetResult<Prisma.$tube_sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_sessionsCountArgs} args - Arguments to filter Tube_sessions to count.
     * @example
     * // Count the number of Tube_sessions
     * const count = await prisma.tube_sessions.count({
     *   where: {
     *     // ... the filter for the Tube_sessions we want to count
     *   }
     * })
    **/
    count<T extends tube_sessionsCountArgs>(
      args?: Subset<T, tube_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_sessionsAggregateArgs>(args: Subset<T, Tube_sessionsAggregateArgs>): Prisma.PrismaPromise<GetTube_sessionsAggregateType<T>>

    /**
     * Group by Tube_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: tube_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_sessions model
   */
  readonly fields: tube_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_conveyors<T extends tube_sessions$tube_conveyorsArgs<ExtArgs> = {}>(args?: Subset<T, tube_sessions$tube_conveyorsArgs<ExtArgs>>): Prisma__tube_conveyorsClient<$Result.GetResult<Prisma.$tube_conveyorsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employees<T extends tube_sessions$employeesArgs<ExtArgs> = {}>(args?: Subset<T, tube_sessions$employeesArgs<ExtArgs>>): Prisma__employeesClient<$Result.GetResult<Prisma.$employeesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_sessions model
   */
  interface tube_sessionsFieldRefs {
    readonly id: FieldRef<"tube_sessions", 'Int'>
    readonly conveyor_id: FieldRef<"tube_sessions", 'Int'>
    readonly employee_id: FieldRef<"tube_sessions", 'Int'>
    readonly finished: FieldRef<"tube_sessions", 'Boolean'>
    readonly createdAt: FieldRef<"tube_sessions", 'DateTime'>
    readonly updatedAt: FieldRef<"tube_sessions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tube_sessions findUnique
   */
  export type tube_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which tube_sessions to fetch.
     */
    where: tube_sessionsWhereUniqueInput
  }

  /**
   * tube_sessions findUniqueOrThrow
   */
  export type tube_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which tube_sessions to fetch.
     */
    where: tube_sessionsWhereUniqueInput
  }

  /**
   * tube_sessions findFirst
   */
  export type tube_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which tube_sessions to fetch.
     */
    where?: tube_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_sessions to fetch.
     */
    orderBy?: tube_sessionsOrderByWithRelationInput | tube_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_sessions.
     */
    cursor?: tube_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_sessions.
     */
    distinct?: Tube_sessionsScalarFieldEnum | Tube_sessionsScalarFieldEnum[]
  }

  /**
   * tube_sessions findFirstOrThrow
   */
  export type tube_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which tube_sessions to fetch.
     */
    where?: tube_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_sessions to fetch.
     */
    orderBy?: tube_sessionsOrderByWithRelationInput | tube_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_sessions.
     */
    cursor?: tube_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_sessions.
     */
    distinct?: Tube_sessionsScalarFieldEnum | Tube_sessionsScalarFieldEnum[]
  }

  /**
   * tube_sessions findMany
   */
  export type tube_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which tube_sessions to fetch.
     */
    where?: tube_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_sessions to fetch.
     */
    orderBy?: tube_sessionsOrderByWithRelationInput | tube_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_sessions.
     */
    cursor?: tube_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_sessions.
     */
    skip?: number
    distinct?: Tube_sessionsScalarFieldEnum | Tube_sessionsScalarFieldEnum[]
  }

  /**
   * tube_sessions create
   */
  export type tube_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_sessions.
     */
    data: XOR<tube_sessionsCreateInput, tube_sessionsUncheckedCreateInput>
  }

  /**
   * tube_sessions createMany
   */
  export type tube_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_sessions.
     */
    data: tube_sessionsCreateManyInput | tube_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_sessions createManyAndReturn
   */
  export type tube_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many tube_sessions.
     */
    data: tube_sessionsCreateManyInput | tube_sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_sessions update
   */
  export type tube_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_sessions.
     */
    data: XOR<tube_sessionsUpdateInput, tube_sessionsUncheckedUpdateInput>
    /**
     * Choose, which tube_sessions to update.
     */
    where: tube_sessionsWhereUniqueInput
  }

  /**
   * tube_sessions updateMany
   */
  export type tube_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_sessions.
     */
    data: XOR<tube_sessionsUpdateManyMutationInput, tube_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which tube_sessions to update
     */
    where?: tube_sessionsWhereInput
    /**
     * Limit how many tube_sessions to update.
     */
    limit?: number
  }

  /**
   * tube_sessions updateManyAndReturn
   */
  export type tube_sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * The data used to update tube_sessions.
     */
    data: XOR<tube_sessionsUpdateManyMutationInput, tube_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which tube_sessions to update
     */
    where?: tube_sessionsWhereInput
    /**
     * Limit how many tube_sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_sessions upsert
   */
  export type tube_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_sessions to update in case it exists.
     */
    where: tube_sessionsWhereUniqueInput
    /**
     * In case the tube_sessions found by the `where` argument doesn't exist, create a new tube_sessions with this data.
     */
    create: XOR<tube_sessionsCreateInput, tube_sessionsUncheckedCreateInput>
    /**
     * In case the tube_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_sessionsUpdateInput, tube_sessionsUncheckedUpdateInput>
  }

  /**
   * tube_sessions delete
   */
  export type tube_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
    /**
     * Filter which tube_sessions to delete.
     */
    where: tube_sessionsWhereUniqueInput
  }

  /**
   * tube_sessions deleteMany
   */
  export type tube_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_sessions to delete
     */
    where?: tube_sessionsWhereInput
    /**
     * Limit how many tube_sessions to delete.
     */
    limit?: number
  }

  /**
   * tube_sessions.tube_conveyors
   */
  export type tube_sessions$tube_conveyorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_conveyors
     */
    select?: tube_conveyorsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_conveyors
     */
    omit?: tube_conveyorsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_conveyorsInclude<ExtArgs> | null
    where?: tube_conveyorsWhereInput
  }

  /**
   * tube_sessions.employees
   */
  export type tube_sessions$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the employees
     */
    select?: employeesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the employees
     */
    omit?: employeesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: employeesInclude<ExtArgs> | null
    where?: employeesWhereInput
  }

  /**
   * tube_sessions without action
   */
  export type tube_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_sessions
     */
    select?: tube_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_sessions
     */
    omit?: tube_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_sessionsInclude<ExtArgs> | null
  }


  /**
   * Model tube_specifications
   */

  export type AggregateTube_specifications = {
    _count: Tube_specificationsCountAggregateOutputType | null
    _avg: Tube_specificationsAvgAggregateOutputType | null
    _sum: Tube_specificationsSumAggregateOutputType | null
    _min: Tube_specificationsMinAggregateOutputType | null
    _max: Tube_specificationsMaxAggregateOutputType | null
  }

  export type Tube_specificationsAvgAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_material_id: number | null
  }

  export type Tube_specificationsSumAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_material_id: number | null
  }

  export type Tube_specificationsMinAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_material_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_specificationsMaxAggregateOutputType = {
    id: number | null
    tube_product_id: number | null
    tube_material_id: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Tube_specificationsCountAggregateOutputType = {
    id: number
    tube_product_id: number
    tube_material_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Tube_specificationsAvgAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_material_id?: true
  }

  export type Tube_specificationsSumAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_material_id?: true
  }

  export type Tube_specificationsMinAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_material_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_specificationsMaxAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_material_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Tube_specificationsCountAggregateInputType = {
    id?: true
    tube_product_id?: true
    tube_material_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Tube_specificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_specifications to aggregate.
     */
    where?: tube_specificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_specifications to fetch.
     */
    orderBy?: tube_specificationsOrderByWithRelationInput | tube_specificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tube_specificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_specifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tube_specifications
    **/
    _count?: true | Tube_specificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tube_specificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tube_specificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tube_specificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tube_specificationsMaxAggregateInputType
  }

  export type GetTube_specificationsAggregateType<T extends Tube_specificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateTube_specifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTube_specifications[P]>
      : GetScalarType<T[P], AggregateTube_specifications[P]>
  }




  export type tube_specificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tube_specificationsWhereInput
    orderBy?: tube_specificationsOrderByWithAggregationInput | tube_specificationsOrderByWithAggregationInput[]
    by: Tube_specificationsScalarFieldEnum[] | Tube_specificationsScalarFieldEnum
    having?: tube_specificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tube_specificationsCountAggregateInputType | true
    _avg?: Tube_specificationsAvgAggregateInputType
    _sum?: Tube_specificationsSumAggregateInputType
    _min?: Tube_specificationsMinAggregateInputType
    _max?: Tube_specificationsMaxAggregateInputType
  }

  export type Tube_specificationsGroupByOutputType = {
    id: number
    tube_product_id: number | null
    tube_material_id: number | null
    createdAt: Date
    updatedAt: Date
    _count: Tube_specificationsCountAggregateOutputType | null
    _avg: Tube_specificationsAvgAggregateOutputType | null
    _sum: Tube_specificationsSumAggregateOutputType | null
    _min: Tube_specificationsMinAggregateOutputType | null
    _max: Tube_specificationsMaxAggregateOutputType | null
  }

  type GetTube_specificationsGroupByPayload<T extends tube_specificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Tube_specificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tube_specificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tube_specificationsGroupByOutputType[P]>
            : GetScalarType<T[P], Tube_specificationsGroupByOutputType[P]>
        }
      >
    >


  export type tube_specificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_product_id?: boolean
    tube_material_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_materials?: boolean | tube_specifications$tube_materialsArgs<ExtArgs>
    tube_products?: boolean | tube_specifications$tube_productsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_specifications"]>

  export type tube_specificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_product_id?: boolean
    tube_material_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_materials?: boolean | tube_specifications$tube_materialsArgs<ExtArgs>
    tube_products?: boolean | tube_specifications$tube_productsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_specifications"]>

  export type tube_specificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tube_product_id?: boolean
    tube_material_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tube_materials?: boolean | tube_specifications$tube_materialsArgs<ExtArgs>
    tube_products?: boolean | tube_specifications$tube_productsArgs<ExtArgs>
  }, ExtArgs["result"]["tube_specifications"]>

  export type tube_specificationsSelectScalar = {
    id?: boolean
    tube_product_id?: boolean
    tube_material_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type tube_specificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tube_product_id" | "tube_material_id" | "createdAt" | "updatedAt", ExtArgs["result"]["tube_specifications"]>
  export type tube_specificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_materials?: boolean | tube_specifications$tube_materialsArgs<ExtArgs>
    tube_products?: boolean | tube_specifications$tube_productsArgs<ExtArgs>
  }
  export type tube_specificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_materials?: boolean | tube_specifications$tube_materialsArgs<ExtArgs>
    tube_products?: boolean | tube_specifications$tube_productsArgs<ExtArgs>
  }
  export type tube_specificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tube_materials?: boolean | tube_specifications$tube_materialsArgs<ExtArgs>
    tube_products?: boolean | tube_specifications$tube_productsArgs<ExtArgs>
  }

  export type $tube_specificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tube_specifications"
    objects: {
      tube_materials: Prisma.$tube_materialsPayload<ExtArgs> | null
      tube_products: Prisma.$tube_productsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tube_product_id: number | null
      tube_material_id: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tube_specifications"]>
    composites: {}
  }

  type tube_specificationsGetPayload<S extends boolean | null | undefined | tube_specificationsDefaultArgs> = $Result.GetResult<Prisma.$tube_specificationsPayload, S>

  type tube_specificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tube_specificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Tube_specificationsCountAggregateInputType | true
    }

  export interface tube_specificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tube_specifications'], meta: { name: 'tube_specifications' } }
    /**
     * Find zero or one Tube_specifications that matches the filter.
     * @param {tube_specificationsFindUniqueArgs} args - Arguments to find a Tube_specifications
     * @example
     * // Get one Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tube_specificationsFindUniqueArgs>(args: SelectSubset<T, tube_specificationsFindUniqueArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tube_specifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tube_specificationsFindUniqueOrThrowArgs} args - Arguments to find a Tube_specifications
     * @example
     * // Get one Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tube_specificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, tube_specificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_specifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_specificationsFindFirstArgs} args - Arguments to find a Tube_specifications
     * @example
     * // Get one Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tube_specificationsFindFirstArgs>(args?: SelectSubset<T, tube_specificationsFindFirstArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tube_specifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_specificationsFindFirstOrThrowArgs} args - Arguments to find a Tube_specifications
     * @example
     * // Get one Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tube_specificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, tube_specificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tube_specifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_specificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.findMany()
     * 
     * // Get first 10 Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tube_specificationsWithIdOnly = await prisma.tube_specifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends tube_specificationsFindManyArgs>(args?: SelectSubset<T, tube_specificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tube_specifications.
     * @param {tube_specificationsCreateArgs} args - Arguments to create a Tube_specifications.
     * @example
     * // Create one Tube_specifications
     * const Tube_specifications = await prisma.tube_specifications.create({
     *   data: {
     *     // ... data to create a Tube_specifications
     *   }
     * })
     * 
     */
    create<T extends tube_specificationsCreateArgs>(args: SelectSubset<T, tube_specificationsCreateArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tube_specifications.
     * @param {tube_specificationsCreateManyArgs} args - Arguments to create many Tube_specifications.
     * @example
     * // Create many Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tube_specificationsCreateManyArgs>(args?: SelectSubset<T, tube_specificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tube_specifications and returns the data saved in the database.
     * @param {tube_specificationsCreateManyAndReturnArgs} args - Arguments to create many Tube_specifications.
     * @example
     * // Create many Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tube_specifications and only return the `id`
     * const tube_specificationsWithIdOnly = await prisma.tube_specifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tube_specificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, tube_specificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tube_specifications.
     * @param {tube_specificationsDeleteArgs} args - Arguments to delete one Tube_specifications.
     * @example
     * // Delete one Tube_specifications
     * const Tube_specifications = await prisma.tube_specifications.delete({
     *   where: {
     *     // ... filter to delete one Tube_specifications
     *   }
     * })
     * 
     */
    delete<T extends tube_specificationsDeleteArgs>(args: SelectSubset<T, tube_specificationsDeleteArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tube_specifications.
     * @param {tube_specificationsUpdateArgs} args - Arguments to update one Tube_specifications.
     * @example
     * // Update one Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tube_specificationsUpdateArgs>(args: SelectSubset<T, tube_specificationsUpdateArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tube_specifications.
     * @param {tube_specificationsDeleteManyArgs} args - Arguments to filter Tube_specifications to delete.
     * @example
     * // Delete a few Tube_specifications
     * const { count } = await prisma.tube_specifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tube_specificationsDeleteManyArgs>(args?: SelectSubset<T, tube_specificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_specifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_specificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tube_specificationsUpdateManyArgs>(args: SelectSubset<T, tube_specificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tube_specifications and returns the data updated in the database.
     * @param {tube_specificationsUpdateManyAndReturnArgs} args - Arguments to update many Tube_specifications.
     * @example
     * // Update many Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tube_specifications and only return the `id`
     * const tube_specificationsWithIdOnly = await prisma.tube_specifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tube_specificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, tube_specificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tube_specifications.
     * @param {tube_specificationsUpsertArgs} args - Arguments to update or create a Tube_specifications.
     * @example
     * // Update or create a Tube_specifications
     * const tube_specifications = await prisma.tube_specifications.upsert({
     *   create: {
     *     // ... data to create a Tube_specifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tube_specifications we want to update
     *   }
     * })
     */
    upsert<T extends tube_specificationsUpsertArgs>(args: SelectSubset<T, tube_specificationsUpsertArgs<ExtArgs>>): Prisma__tube_specificationsClient<$Result.GetResult<Prisma.$tube_specificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tube_specifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_specificationsCountArgs} args - Arguments to filter Tube_specifications to count.
     * @example
     * // Count the number of Tube_specifications
     * const count = await prisma.tube_specifications.count({
     *   where: {
     *     // ... the filter for the Tube_specifications we want to count
     *   }
     * })
    **/
    count<T extends tube_specificationsCountArgs>(
      args?: Subset<T, tube_specificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tube_specificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tube_specifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tube_specificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tube_specificationsAggregateArgs>(args: Subset<T, Tube_specificationsAggregateArgs>): Prisma.PrismaPromise<GetTube_specificationsAggregateType<T>>

    /**
     * Group by Tube_specifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tube_specificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tube_specificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tube_specificationsGroupByArgs['orderBy'] }
        : { orderBy?: tube_specificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tube_specificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTube_specificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tube_specifications model
   */
  readonly fields: tube_specificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tube_specifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tube_specificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tube_materials<T extends tube_specifications$tube_materialsArgs<ExtArgs> = {}>(args?: Subset<T, tube_specifications$tube_materialsArgs<ExtArgs>>): Prisma__tube_materialsClient<$Result.GetResult<Prisma.$tube_materialsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tube_products<T extends tube_specifications$tube_productsArgs<ExtArgs> = {}>(args?: Subset<T, tube_specifications$tube_productsArgs<ExtArgs>>): Prisma__tube_productsClient<$Result.GetResult<Prisma.$tube_productsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tube_specifications model
   */
  interface tube_specificationsFieldRefs {
    readonly id: FieldRef<"tube_specifications", 'Int'>
    readonly tube_product_id: FieldRef<"tube_specifications", 'Int'>
    readonly tube_material_id: FieldRef<"tube_specifications", 'Int'>
    readonly createdAt: FieldRef<"tube_specifications", 'DateTime'>
    readonly updatedAt: FieldRef<"tube_specifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * tube_specifications findUnique
   */
  export type tube_specificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * Filter, which tube_specifications to fetch.
     */
    where: tube_specificationsWhereUniqueInput
  }

  /**
   * tube_specifications findUniqueOrThrow
   */
  export type tube_specificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * Filter, which tube_specifications to fetch.
     */
    where: tube_specificationsWhereUniqueInput
  }

  /**
   * tube_specifications findFirst
   */
  export type tube_specificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * Filter, which tube_specifications to fetch.
     */
    where?: tube_specificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_specifications to fetch.
     */
    orderBy?: tube_specificationsOrderByWithRelationInput | tube_specificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_specifications.
     */
    cursor?: tube_specificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_specifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_specifications.
     */
    distinct?: Tube_specificationsScalarFieldEnum | Tube_specificationsScalarFieldEnum[]
  }

  /**
   * tube_specifications findFirstOrThrow
   */
  export type tube_specificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * Filter, which tube_specifications to fetch.
     */
    where?: tube_specificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_specifications to fetch.
     */
    orderBy?: tube_specificationsOrderByWithRelationInput | tube_specificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tube_specifications.
     */
    cursor?: tube_specificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_specifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tube_specifications.
     */
    distinct?: Tube_specificationsScalarFieldEnum | Tube_specificationsScalarFieldEnum[]
  }

  /**
   * tube_specifications findMany
   */
  export type tube_specificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * Filter, which tube_specifications to fetch.
     */
    where?: tube_specificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tube_specifications to fetch.
     */
    orderBy?: tube_specificationsOrderByWithRelationInput | tube_specificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tube_specifications.
     */
    cursor?: tube_specificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tube_specifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tube_specifications.
     */
    skip?: number
    distinct?: Tube_specificationsScalarFieldEnum | Tube_specificationsScalarFieldEnum[]
  }

  /**
   * tube_specifications create
   */
  export type tube_specificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a tube_specifications.
     */
    data: XOR<tube_specificationsCreateInput, tube_specificationsUncheckedCreateInput>
  }

  /**
   * tube_specifications createMany
   */
  export type tube_specificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tube_specifications.
     */
    data: tube_specificationsCreateManyInput | tube_specificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tube_specifications createManyAndReturn
   */
  export type tube_specificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * The data used to create many tube_specifications.
     */
    data: tube_specificationsCreateManyInput | tube_specificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_specifications update
   */
  export type tube_specificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a tube_specifications.
     */
    data: XOR<tube_specificationsUpdateInput, tube_specificationsUncheckedUpdateInput>
    /**
     * Choose, which tube_specifications to update.
     */
    where: tube_specificationsWhereUniqueInput
  }

  /**
   * tube_specifications updateMany
   */
  export type tube_specificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tube_specifications.
     */
    data: XOR<tube_specificationsUpdateManyMutationInput, tube_specificationsUncheckedUpdateManyInput>
    /**
     * Filter which tube_specifications to update
     */
    where?: tube_specificationsWhereInput
    /**
     * Limit how many tube_specifications to update.
     */
    limit?: number
  }

  /**
   * tube_specifications updateManyAndReturn
   */
  export type tube_specificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * The data used to update tube_specifications.
     */
    data: XOR<tube_specificationsUpdateManyMutationInput, tube_specificationsUncheckedUpdateManyInput>
    /**
     * Filter which tube_specifications to update
     */
    where?: tube_specificationsWhereInput
    /**
     * Limit how many tube_specifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * tube_specifications upsert
   */
  export type tube_specificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the tube_specifications to update in case it exists.
     */
    where: tube_specificationsWhereUniqueInput
    /**
     * In case the tube_specifications found by the `where` argument doesn't exist, create a new tube_specifications with this data.
     */
    create: XOR<tube_specificationsCreateInput, tube_specificationsUncheckedCreateInput>
    /**
     * In case the tube_specifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tube_specificationsUpdateInput, tube_specificationsUncheckedUpdateInput>
  }

  /**
   * tube_specifications delete
   */
  export type tube_specificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
    /**
     * Filter which tube_specifications to delete.
     */
    where: tube_specificationsWhereUniqueInput
  }

  /**
   * tube_specifications deleteMany
   */
  export type tube_specificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tube_specifications to delete
     */
    where?: tube_specificationsWhereInput
    /**
     * Limit how many tube_specifications to delete.
     */
    limit?: number
  }

  /**
   * tube_specifications.tube_materials
   */
  export type tube_specifications$tube_materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_materials
     */
    select?: tube_materialsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_materials
     */
    omit?: tube_materialsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_materialsInclude<ExtArgs> | null
    where?: tube_materialsWhereInput
  }

  /**
   * tube_specifications.tube_products
   */
  export type tube_specifications$tube_productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_products
     */
    select?: tube_productsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_products
     */
    omit?: tube_productsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_productsInclude<ExtArgs> | null
    where?: tube_productsWhereInput
  }

  /**
   * tube_specifications without action
   */
  export type tube_specificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tube_specifications
     */
    select?: tube_specificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tube_specifications
     */
    omit?: tube_specificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tube_specificationsInclude<ExtArgs> | null
  }


  /**
   * Model user_roles
   */

  export type AggregateUser_roles = {
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  export type User_rolesAvgAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
  }

  export type User_rolesSumAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
  }

  export type User_rolesMinAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
  }

  export type User_rolesMaxAggregateOutputType = {
    id: number | null
    roleId: number | null
    userId: number | null
  }

  export type User_rolesCountAggregateOutputType = {
    id: number
    roleId: number
    userId: number
    _all: number
  }


  export type User_rolesAvgAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
  }

  export type User_rolesSumAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
  }

  export type User_rolesMinAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
  }

  export type User_rolesMaxAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
  }

  export type User_rolesCountAggregateInputType = {
    id?: true
    roleId?: true
    userId?: true
    _all?: true
  }

  export type User_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to aggregate.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_roles
    **/
    _count?: true | User_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_rolesMaxAggregateInputType
  }

  export type GetUser_rolesAggregateType<T extends User_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_roles[P]>
      : GetScalarType<T[P], AggregateUser_roles[P]>
  }




  export type user_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithAggregationInput | user_rolesOrderByWithAggregationInput[]
    by: User_rolesScalarFieldEnum[] | User_rolesScalarFieldEnum
    having?: user_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_rolesCountAggregateInputType | true
    _avg?: User_rolesAvgAggregateInputType
    _sum?: User_rolesSumAggregateInputType
    _min?: User_rolesMinAggregateInputType
    _max?: User_rolesMaxAggregateInputType
  }

  export type User_rolesGroupByOutputType = {
    id: number
    roleId: number
    userId: number
    _count: User_rolesCountAggregateOutputType | null
    _avg: User_rolesAvgAggregateOutputType | null
    _sum: User_rolesSumAggregateOutputType | null
    _min: User_rolesMinAggregateOutputType | null
    _max: User_rolesMaxAggregateOutputType | null
  }

  type GetUser_rolesGroupByPayload<T extends user_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], User_rolesGroupByOutputType[P]>
        }
      >
    >


  export type user_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    userId?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    userId?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roleId?: boolean
    userId?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_roles"]>

  export type user_rolesSelectScalar = {
    id?: boolean
    roleId?: boolean
    userId?: boolean
  }

  export type user_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roleId" | "userId", ExtArgs["result"]["user_roles"]>
  export type user_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type user_rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $user_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_roles"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      roleId: number
      userId: number
    }, ExtArgs["result"]["user_roles"]>
    composites: {}
  }

  type user_rolesGetPayload<S extends boolean | null | undefined | user_rolesDefaultArgs> = $Result.GetResult<Prisma.$user_rolesPayload, S>

  type user_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<user_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: User_rolesCountAggregateInputType | true
    }

  export interface user_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_roles'], meta: { name: 'user_roles' } }
    /**
     * Find zero or one User_roles that matches the filter.
     * @param {user_rolesFindUniqueArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_rolesFindUniqueArgs>(args: SelectSubset<T, user_rolesFindUniqueArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User_roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {user_rolesFindUniqueOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, user_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_rolesFindFirstArgs>(args?: SelectSubset<T, user_rolesFindFirstArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindFirstOrThrowArgs} args - Arguments to find a User_roles
     * @example
     * // Get one User_roles
     * const user_roles = await prisma.user_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, user_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more User_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_roles
     * const user_roles = await prisma.user_roles.findMany()
     * 
     * // Get first 10 User_roles
     * const user_roles = await prisma.user_roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_rolesFindManyArgs>(args?: SelectSubset<T, user_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User_roles.
     * @param {user_rolesCreateArgs} args - Arguments to create a User_roles.
     * @example
     * // Create one User_roles
     * const User_roles = await prisma.user_roles.create({
     *   data: {
     *     // ... data to create a User_roles
     *   }
     * })
     * 
     */
    create<T extends user_rolesCreateArgs>(args: SelectSubset<T, user_rolesCreateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many User_roles.
     * @param {user_rolesCreateManyArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_rolesCreateManyArgs>(args?: SelectSubset<T, user_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many User_roles and returns the data saved in the database.
     * @param {user_rolesCreateManyAndReturnArgs} args - Arguments to create many User_roles.
     * @example
     * // Create many User_roles
     * const user_roles = await prisma.user_roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many User_roles and only return the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends user_rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, user_rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User_roles.
     * @param {user_rolesDeleteArgs} args - Arguments to delete one User_roles.
     * @example
     * // Delete one User_roles
     * const User_roles = await prisma.user_roles.delete({
     *   where: {
     *     // ... filter to delete one User_roles
     *   }
     * })
     * 
     */
    delete<T extends user_rolesDeleteArgs>(args: SelectSubset<T, user_rolesDeleteArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User_roles.
     * @param {user_rolesUpdateArgs} args - Arguments to update one User_roles.
     * @example
     * // Update one User_roles
     * const user_roles = await prisma.user_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_rolesUpdateArgs>(args: SelectSubset<T, user_rolesUpdateArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more User_roles.
     * @param {user_rolesDeleteManyArgs} args - Arguments to filter User_roles to delete.
     * @example
     * // Delete a few User_roles
     * const { count } = await prisma.user_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_rolesDeleteManyArgs>(args?: SelectSubset<T, user_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_rolesUpdateManyArgs>(args: SelectSubset<T, user_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_roles and returns the data updated in the database.
     * @param {user_rolesUpdateManyAndReturnArgs} args - Arguments to update many User_roles.
     * @example
     * // Update many User_roles
     * const user_roles = await prisma.user_roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more User_roles and only return the `id`
     * const user_rolesWithIdOnly = await prisma.user_roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends user_rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, user_rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User_roles.
     * @param {user_rolesUpsertArgs} args - Arguments to update or create a User_roles.
     * @example
     * // Update or create a User_roles
     * const user_roles = await prisma.user_roles.upsert({
     *   create: {
     *     // ... data to create a User_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_roles we want to update
     *   }
     * })
     */
    upsert<T extends user_rolesUpsertArgs>(args: SelectSubset<T, user_rolesUpsertArgs<ExtArgs>>): Prisma__user_rolesClient<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesCountArgs} args - Arguments to filter User_roles to count.
     * @example
     * // Count the number of User_roles
     * const count = await prisma.user_roles.count({
     *   where: {
     *     // ... the filter for the User_roles we want to count
     *   }
     * })
    **/
    count<T extends user_rolesCountArgs>(
      args?: Subset<T, user_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_rolesAggregateArgs>(args: Subset<T, User_rolesAggregateArgs>): Prisma.PrismaPromise<GetUser_rolesAggregateType<T>>

    /**
     * Group by User_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_rolesGroupByArgs['orderBy'] }
        : { orderBy?: user_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_roles model
   */
  readonly fields: user_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_roles model
   */
  interface user_rolesFieldRefs {
    readonly id: FieldRef<"user_roles", 'Int'>
    readonly roleId: FieldRef<"user_roles", 'Int'>
    readonly userId: FieldRef<"user_roles", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * user_roles findUnique
   */
  export type user_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findUniqueOrThrow
   */
  export type user_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles findFirst
   */
  export type user_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findFirstOrThrow
   */
  export type user_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_roles.
     */
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles findMany
   */
  export type user_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter, which user_roles to fetch.
     */
    where?: user_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_roles to fetch.
     */
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_roles.
     */
    cursor?: user_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_roles.
     */
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * user_roles create
   */
  export type user_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a user_roles.
     */
    data: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
  }

  /**
   * user_roles createMany
   */
  export type user_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * user_roles createManyAndReturn
   */
  export type user_rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * The data used to create many user_roles.
     */
    data: user_rolesCreateManyInput | user_rolesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_roles update
   */
  export type user_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a user_roles.
     */
    data: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
    /**
     * Choose, which user_roles to update.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles updateMany
   */
  export type user_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
  }

  /**
   * user_roles updateManyAndReturn
   */
  export type user_rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * The data used to update user_roles.
     */
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyInput>
    /**
     * Filter which user_roles to update
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * user_roles upsert
   */
  export type user_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the user_roles to update in case it exists.
     */
    where: user_rolesWhereUniqueInput
    /**
     * In case the user_roles found by the `where` argument doesn't exist, create a new user_roles with this data.
     */
    create: XOR<user_rolesCreateInput, user_rolesUncheckedCreateInput>
    /**
     * In case the user_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_rolesUpdateInput, user_rolesUncheckedUpdateInput>
  }

  /**
   * user_roles delete
   */
  export type user_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    /**
     * Filter which user_roles to delete.
     */
    where: user_rolesWhereUniqueInput
  }

  /**
   * user_roles deleteMany
   */
  export type user_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_roles to delete
     */
    where?: user_rolesWhereInput
    /**
     * Limit how many user_roles to delete.
     */
    limit?: number
  }

  /**
   * user_roles without action
   */
  export type user_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    banned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    password: string | null
    banned: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    banned: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    banned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    banned?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    banned?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: number
    name: string
    email: string
    password: string
    banned: boolean | null
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    banned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    histories?: boolean | users$historiesArgs<ExtArgs>
    tokens?: boolean | users$tokensArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    banned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    banned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    banned?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "banned" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    histories?: boolean | users$historiesArgs<ExtArgs>
    tokens?: boolean | users$tokensArgs<ExtArgs>
    user_roles?: boolean | users$user_rolesArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      histories: Prisma.$historiesPayload<ExtArgs>[]
      tokens: Prisma.$tokensPayload<ExtArgs>[]
      user_roles: Prisma.$user_rolesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      password: string
      banned: boolean | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    histories<T extends users$historiesArgs<ExtArgs> = {}>(args?: Subset<T, users$historiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$historiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tokens<T extends users$tokensArgs<ExtArgs> = {}>(args?: Subset<T, users$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user_roles<T extends users$user_rolesArgs<ExtArgs> = {}>(args?: Subset<T, users$user_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'Int'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly banned: FieldRef<"users", 'Boolean'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.histories
   */
  export type users$historiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the histories
     */
    select?: historiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the histories
     */
    omit?: historiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: historiesInclude<ExtArgs> | null
    where?: historiesWhereInput
    orderBy?: historiesOrderByWithRelationInput | historiesOrderByWithRelationInput[]
    cursor?: historiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistoriesScalarFieldEnum | HistoriesScalarFieldEnum[]
  }

  /**
   * users.tokens
   */
  export type users$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tokens
     */
    select?: tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tokens
     */
    omit?: tokensOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: tokensInclude<ExtArgs> | null
    where?: tokensWhereInput
    orderBy?: tokensOrderByWithRelationInput | tokensOrderByWithRelationInput[]
    cursor?: tokensWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokensScalarFieldEnum | TokensScalarFieldEnum[]
  }

  /**
   * users.user_roles
   */
  export type users$user_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_roles
     */
    select?: user_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the user_roles
     */
    omit?: user_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_rolesInclude<ExtArgs> | null
    where?: user_rolesWhereInput
    orderBy?: user_rolesOrderByWithRelationInput | user_rolesOrderByWithRelationInput[]
    cursor?: user_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_rolesScalarFieldEnum | User_rolesScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model workshops
   */

  export type AggregateWorkshops = {
    _count: WorkshopsCountAggregateOutputType | null
    _avg: WorkshopsAvgAggregateOutputType | null
    _sum: WorkshopsSumAggregateOutputType | null
    _min: WorkshopsMinAggregateOutputType | null
    _max: WorkshopsMaxAggregateOutputType | null
  }

  export type WorkshopsAvgAggregateOutputType = {
    id: number | null
  }

  export type WorkshopsSumAggregateOutputType = {
    id: number | null
  }

  export type WorkshopsMinAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type WorkshopsMaxAggregateOutputType = {
    id: number | null
    value: string | null
  }

  export type WorkshopsCountAggregateOutputType = {
    id: number
    value: number
    _all: number
  }


  export type WorkshopsAvgAggregateInputType = {
    id?: true
  }

  export type WorkshopsSumAggregateInputType = {
    id?: true
  }

  export type WorkshopsMinAggregateInputType = {
    id?: true
    value?: true
  }

  export type WorkshopsMaxAggregateInputType = {
    id?: true
    value?: true
  }

  export type WorkshopsCountAggregateInputType = {
    id?: true
    value?: true
    _all?: true
  }

  export type WorkshopsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workshops to aggregate.
     */
    where?: workshopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workshops to fetch.
     */
    orderBy?: workshopsOrderByWithRelationInput | workshopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: workshopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned workshops
    **/
    _count?: true | WorkshopsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkshopsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkshopsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkshopsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkshopsMaxAggregateInputType
  }

  export type GetWorkshopsAggregateType<T extends WorkshopsAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkshops]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkshops[P]>
      : GetScalarType<T[P], AggregateWorkshops[P]>
  }




  export type workshopsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: workshopsWhereInput
    orderBy?: workshopsOrderByWithAggregationInput | workshopsOrderByWithAggregationInput[]
    by: WorkshopsScalarFieldEnum[] | WorkshopsScalarFieldEnum
    having?: workshopsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkshopsCountAggregateInputType | true
    _avg?: WorkshopsAvgAggregateInputType
    _sum?: WorkshopsSumAggregateInputType
    _min?: WorkshopsMinAggregateInputType
    _max?: WorkshopsMaxAggregateInputType
  }

  export type WorkshopsGroupByOutputType = {
    id: number
    value: string
    _count: WorkshopsCountAggregateOutputType | null
    _avg: WorkshopsAvgAggregateOutputType | null
    _sum: WorkshopsSumAggregateOutputType | null
    _min: WorkshopsMinAggregateOutputType | null
    _max: WorkshopsMaxAggregateOutputType | null
  }

  type GetWorkshopsGroupByPayload<T extends workshopsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkshopsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkshopsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkshopsGroupByOutputType[P]>
            : GetScalarType<T[P], WorkshopsGroupByOutputType[P]>
        }
      >
    >


  export type workshopsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
    records?: boolean | workshops$recordsArgs<ExtArgs>
    _count?: boolean | WorkshopsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workshops"]>

  export type workshopsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["workshops"]>

  export type workshopsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    value?: boolean
  }, ExtArgs["result"]["workshops"]>

  export type workshopsSelectScalar = {
    id?: boolean
    value?: boolean
  }

  export type workshopsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "value", ExtArgs["result"]["workshops"]>
  export type workshopsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    records?: boolean | workshops$recordsArgs<ExtArgs>
    _count?: boolean | WorkshopsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type workshopsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type workshopsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $workshopsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "workshops"
    objects: {
      records: Prisma.$recordsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      value: string
    }, ExtArgs["result"]["workshops"]>
    composites: {}
  }

  type workshopsGetPayload<S extends boolean | null | undefined | workshopsDefaultArgs> = $Result.GetResult<Prisma.$workshopsPayload, S>

  type workshopsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<workshopsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkshopsCountAggregateInputType | true
    }

  export interface workshopsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['workshops'], meta: { name: 'workshops' } }
    /**
     * Find zero or one Workshops that matches the filter.
     * @param {workshopsFindUniqueArgs} args - Arguments to find a Workshops
     * @example
     * // Get one Workshops
     * const workshops = await prisma.workshops.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends workshopsFindUniqueArgs>(args: SelectSubset<T, workshopsFindUniqueArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workshops that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {workshopsFindUniqueOrThrowArgs} args - Arguments to find a Workshops
     * @example
     * // Get one Workshops
     * const workshops = await prisma.workshops.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends workshopsFindUniqueOrThrowArgs>(args: SelectSubset<T, workshopsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workshopsFindFirstArgs} args - Arguments to find a Workshops
     * @example
     * // Get one Workshops
     * const workshops = await prisma.workshops.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends workshopsFindFirstArgs>(args?: SelectSubset<T, workshopsFindFirstArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workshops that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workshopsFindFirstOrThrowArgs} args - Arguments to find a Workshops
     * @example
     * // Get one Workshops
     * const workshops = await prisma.workshops.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends workshopsFindFirstOrThrowArgs>(args?: SelectSubset<T, workshopsFindFirstOrThrowArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workshops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workshopsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workshops
     * const workshops = await prisma.workshops.findMany()
     * 
     * // Get first 10 Workshops
     * const workshops = await prisma.workshops.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workshopsWithIdOnly = await prisma.workshops.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends workshopsFindManyArgs>(args?: SelectSubset<T, workshopsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workshops.
     * @param {workshopsCreateArgs} args - Arguments to create a Workshops.
     * @example
     * // Create one Workshops
     * const Workshops = await prisma.workshops.create({
     *   data: {
     *     // ... data to create a Workshops
     *   }
     * })
     * 
     */
    create<T extends workshopsCreateArgs>(args: SelectSubset<T, workshopsCreateArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workshops.
     * @param {workshopsCreateManyArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshops = await prisma.workshops.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends workshopsCreateManyArgs>(args?: SelectSubset<T, workshopsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workshops and returns the data saved in the database.
     * @param {workshopsCreateManyAndReturnArgs} args - Arguments to create many Workshops.
     * @example
     * // Create many Workshops
     * const workshops = await prisma.workshops.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workshops and only return the `id`
     * const workshopsWithIdOnly = await prisma.workshops.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends workshopsCreateManyAndReturnArgs>(args?: SelectSubset<T, workshopsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workshops.
     * @param {workshopsDeleteArgs} args - Arguments to delete one Workshops.
     * @example
     * // Delete one Workshops
     * const Workshops = await prisma.workshops.delete({
     *   where: {
     *     // ... filter to delete one Workshops
     *   }
     * })
     * 
     */
    delete<T extends workshopsDeleteArgs>(args: SelectSubset<T, workshopsDeleteArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workshops.
     * @param {workshopsUpdateArgs} args - Arguments to update one Workshops.
     * @example
     * // Update one Workshops
     * const workshops = await prisma.workshops.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends workshopsUpdateArgs>(args: SelectSubset<T, workshopsUpdateArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workshops.
     * @param {workshopsDeleteManyArgs} args - Arguments to filter Workshops to delete.
     * @example
     * // Delete a few Workshops
     * const { count } = await prisma.workshops.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends workshopsDeleteManyArgs>(args?: SelectSubset<T, workshopsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workshopsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workshops
     * const workshops = await prisma.workshops.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends workshopsUpdateManyArgs>(args: SelectSubset<T, workshopsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workshops and returns the data updated in the database.
     * @param {workshopsUpdateManyAndReturnArgs} args - Arguments to update many Workshops.
     * @example
     * // Update many Workshops
     * const workshops = await prisma.workshops.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workshops and only return the `id`
     * const workshopsWithIdOnly = await prisma.workshops.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends workshopsUpdateManyAndReturnArgs>(args: SelectSubset<T, workshopsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workshops.
     * @param {workshopsUpsertArgs} args - Arguments to update or create a Workshops.
     * @example
     * // Update or create a Workshops
     * const workshops = await prisma.workshops.upsert({
     *   create: {
     *     // ... data to create a Workshops
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workshops we want to update
     *   }
     * })
     */
    upsert<T extends workshopsUpsertArgs>(args: SelectSubset<T, workshopsUpsertArgs<ExtArgs>>): Prisma__workshopsClient<$Result.GetResult<Prisma.$workshopsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workshopsCountArgs} args - Arguments to filter Workshops to count.
     * @example
     * // Count the number of Workshops
     * const count = await prisma.workshops.count({
     *   where: {
     *     // ... the filter for the Workshops we want to count
     *   }
     * })
    **/
    count<T extends workshopsCountArgs>(
      args?: Subset<T, workshopsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkshopsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkshopsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkshopsAggregateArgs>(args: Subset<T, WorkshopsAggregateArgs>): Prisma.PrismaPromise<GetWorkshopsAggregateType<T>>

    /**
     * Group by Workshops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {workshopsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends workshopsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: workshopsGroupByArgs['orderBy'] }
        : { orderBy?: workshopsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, workshopsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkshopsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the workshops model
   */
  readonly fields: workshopsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for workshops.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__workshopsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    records<T extends workshops$recordsArgs<ExtArgs> = {}>(args?: Subset<T, workshops$recordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$recordsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the workshops model
   */
  interface workshopsFieldRefs {
    readonly id: FieldRef<"workshops", 'Int'>
    readonly value: FieldRef<"workshops", 'String'>
  }
    

  // Custom InputTypes
  /**
   * workshops findUnique
   */
  export type workshopsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * Filter, which workshops to fetch.
     */
    where: workshopsWhereUniqueInput
  }

  /**
   * workshops findUniqueOrThrow
   */
  export type workshopsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * Filter, which workshops to fetch.
     */
    where: workshopsWhereUniqueInput
  }

  /**
   * workshops findFirst
   */
  export type workshopsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * Filter, which workshops to fetch.
     */
    where?: workshopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workshops to fetch.
     */
    orderBy?: workshopsOrderByWithRelationInput | workshopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workshops.
     */
    cursor?: workshopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workshops.
     */
    distinct?: WorkshopsScalarFieldEnum | WorkshopsScalarFieldEnum[]
  }

  /**
   * workshops findFirstOrThrow
   */
  export type workshopsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * Filter, which workshops to fetch.
     */
    where?: workshopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workshops to fetch.
     */
    orderBy?: workshopsOrderByWithRelationInput | workshopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for workshops.
     */
    cursor?: workshopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workshops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of workshops.
     */
    distinct?: WorkshopsScalarFieldEnum | WorkshopsScalarFieldEnum[]
  }

  /**
   * workshops findMany
   */
  export type workshopsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * Filter, which workshops to fetch.
     */
    where?: workshopsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of workshops to fetch.
     */
    orderBy?: workshopsOrderByWithRelationInput | workshopsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing workshops.
     */
    cursor?: workshopsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` workshops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` workshops.
     */
    skip?: number
    distinct?: WorkshopsScalarFieldEnum | WorkshopsScalarFieldEnum[]
  }

  /**
   * workshops create
   */
  export type workshopsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * The data needed to create a workshops.
     */
    data: XOR<workshopsCreateInput, workshopsUncheckedCreateInput>
  }

  /**
   * workshops createMany
   */
  export type workshopsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many workshops.
     */
    data: workshopsCreateManyInput | workshopsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * workshops createManyAndReturn
   */
  export type workshopsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * The data used to create many workshops.
     */
    data: workshopsCreateManyInput | workshopsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * workshops update
   */
  export type workshopsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * The data needed to update a workshops.
     */
    data: XOR<workshopsUpdateInput, workshopsUncheckedUpdateInput>
    /**
     * Choose, which workshops to update.
     */
    where: workshopsWhereUniqueInput
  }

  /**
   * workshops updateMany
   */
  export type workshopsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update workshops.
     */
    data: XOR<workshopsUpdateManyMutationInput, workshopsUncheckedUpdateManyInput>
    /**
     * Filter which workshops to update
     */
    where?: workshopsWhereInput
    /**
     * Limit how many workshops to update.
     */
    limit?: number
  }

  /**
   * workshops updateManyAndReturn
   */
  export type workshopsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * The data used to update workshops.
     */
    data: XOR<workshopsUpdateManyMutationInput, workshopsUncheckedUpdateManyInput>
    /**
     * Filter which workshops to update
     */
    where?: workshopsWhereInput
    /**
     * Limit how many workshops to update.
     */
    limit?: number
  }

  /**
   * workshops upsert
   */
  export type workshopsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * The filter to search for the workshops to update in case it exists.
     */
    where: workshopsWhereUniqueInput
    /**
     * In case the workshops found by the `where` argument doesn't exist, create a new workshops with this data.
     */
    create: XOR<workshopsCreateInput, workshopsUncheckedCreateInput>
    /**
     * In case the workshops was found with the provided `where` argument, update it with this data.
     */
    update: XOR<workshopsUpdateInput, workshopsUncheckedUpdateInput>
  }

  /**
   * workshops delete
   */
  export type workshopsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
    /**
     * Filter which workshops to delete.
     */
    where: workshopsWhereUniqueInput
  }

  /**
   * workshops deleteMany
   */
  export type workshopsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which workshops to delete
     */
    where?: workshopsWhereInput
    /**
     * Limit how many workshops to delete.
     */
    limit?: number
  }

  /**
   * workshops.records
   */
  export type workshops$recordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the records
     */
    select?: recordsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the records
     */
    omit?: recordsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: recordsInclude<ExtArgs> | null
    where?: recordsWhereInput
    orderBy?: recordsOrderByWithRelationInput | recordsOrderByWithRelationInput[]
    cursor?: recordsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RecordsScalarFieldEnum | RecordsScalarFieldEnum[]
  }

  /**
   * workshops without action
   */
  export type workshopsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the workshops
     */
    select?: workshopsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the workshops
     */
    omit?: workshopsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: workshopsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BatchsScalarFieldEnum: {
    BatchPK: 'BatchPK',
    BatchName: 'BatchName',
    BatchDate: 'BatchDate',
    Plant: 'Plant',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchsScalarFieldEnum = (typeof BatchsScalarFieldEnum)[keyof typeof BatchsScalarFieldEnum]


  export const TraceBatchesScalarFieldEnum: {
    id: 'id',
    BatchPK: 'BatchPK',
    BatchName: 'BatchName',
    BatchDate: 'BatchDate',
    Plant: 'Plant',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TraceBatchesScalarFieldEnum = (typeof TraceBatchesScalarFieldEnum)[keyof typeof TraceBatchesScalarFieldEnum]


  export const Api_errorsScalarFieldEnum: {
    id: 'id',
    dto: 'dto',
    message: 'message',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Api_errorsScalarFieldEnum = (typeof Api_errorsScalarFieldEnum)[keyof typeof Api_errorsScalarFieldEnum]


  export const ApparatusesScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type ApparatusesScalarFieldEnum = (typeof ApparatusesScalarFieldEnum)[keyof typeof ApparatusesScalarFieldEnum]


  export const BasesScalarFieldEnum: {
    id: 'id',
    code: 'code',
    marking: 'marking'
  };

  export type BasesScalarFieldEnum = (typeof BasesScalarFieldEnum)[keyof typeof BasesScalarFieldEnum]


  export const BatchsScalarFieldEnum: {
    BatchPK: 'BatchPK',
    BatchName: 'BatchName',
    BatchDate: 'BatchDate',
    Plant: 'Plant',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BatchsScalarFieldEnum = (typeof BatchsScalarFieldEnum)[keyof typeof BatchsScalarFieldEnum]


  export const BoilsScalarFieldEnum: {
    id: 'id',
    value: 'value',
    base_id: 'base_id',
    letter: 'letter',
    year: 'year',
    number: 'number',
    plant_id: 'plant_id'
  };

  export type BoilsScalarFieldEnum = (typeof BoilsScalarFieldEnum)[keyof typeof BoilsScalarFieldEnum]


  export const CansScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type CansScalarFieldEnum = (typeof CansScalarFieldEnum)[keyof typeof CansScalarFieldEnum]


  export const ConveyorsScalarFieldEnum: {
    id: 'id',
    value: 'value',
    barcode: 'barcode'
  };

  export type ConveyorsScalarFieldEnum = (typeof ConveyorsScalarFieldEnum)[keyof typeof ConveyorsScalarFieldEnum]


  export const Dbo_BatchsScalarFieldEnum: {
    BatchPK: 'BatchPK',
    BatchName: 'BatchName',
    BatchDate: 'BatchDate',
    Plant: 'Plant',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Dbo_BatchsScalarFieldEnum = (typeof Dbo_BatchsScalarFieldEnum)[keyof typeof Dbo_BatchsScalarFieldEnum]


  export const DocsScalarFieldEnum: {
    id: 'id',
    plantId: 'plantId',
    date: 'date',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocsScalarFieldEnum = (typeof DocsScalarFieldEnum)[keyof typeof DocsScalarFieldEnum]


  export const EmployeesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    barcode: 'barcode',
    occupationId: 'occupationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeesScalarFieldEnum = (typeof EmployeesScalarFieldEnum)[keyof typeof EmployeesScalarFieldEnum]


  export const HistoriesScalarFieldEnum: {
    id: 'id',
    record_id: 'record_id',
    boil_id: 'boil_id',
    historyTypeId: 'historyTypeId',
    userId: 'userId',
    employeeId: 'employeeId',
    note: 'note',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    note_id: 'note_id',
    plant_id: 'plant_id'
  };

  export type HistoriesScalarFieldEnum = (typeof HistoriesScalarFieldEnum)[keyof typeof HistoriesScalarFieldEnum]


  export const History_typesScalarFieldEnum: {
    id: 'id',
    value: 'value',
    description: 'description',
    for_boil: 'for_boil'
  };

  export type History_typesScalarFieldEnum = (typeof History_typesScalarFieldEnum)[keyof typeof History_typesScalarFieldEnum]


  export const Marking_sampleScalarFieldEnum: {
    id: 'id',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Marking_sampleScalarFieldEnum = (typeof Marking_sampleScalarFieldEnum)[keyof typeof Marking_sampleScalarFieldEnum]


  export const NotesScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type NotesScalarFieldEnum = (typeof NotesScalarFieldEnum)[keyof typeof NotesScalarFieldEnum]


  export const OccupationsScalarFieldEnum: {
    id: 'id',
    value: 'value',
    description: 'description'
  };

  export type OccupationsScalarFieldEnum = (typeof OccupationsScalarFieldEnum)[keyof typeof OccupationsScalarFieldEnum]


  export const PlantsScalarFieldEnum: {
    id: 'id',
    value: 'value',
    abb: 'abb'
  };

  export type PlantsScalarFieldEnum = (typeof PlantsScalarFieldEnum)[keyof typeof PlantsScalarFieldEnum]


  export const ProductsScalarFieldEnum: {
    id: 'id',
    code1C: 'code1C',
    marking: 'marking',
    name: 'name',
    serieId: 'serieId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductsScalarFieldEnum = (typeof ProductsScalarFieldEnum)[keyof typeof ProductsScalarFieldEnum]


  export const Record_regulationsScalarFieldEnum: {
    id: 'id',
    record_id: 'record_id',
    org_base_min_weight: 'org_base_min_weight',
    org_base_max_weight: 'org_base_max_weight',
    water_base_min_weight: 'water_base_min_weight',
    water_base_max_weight: 'water_base_max_weight',
    per_box: 'per_box',
    box_per_row: 'box_per_row',
    row_on_pallet: 'row_on_pallet',
    gasket: 'gasket',
    seal: 'seal',
    technician_note: 'technician_note',
    packaging_note: 'packaging_note',
    marking_sample_id: 'marking_sample_id',
    inc_color: 'inc_color',
    marking_feature: 'marking_feature',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Record_regulationsScalarFieldEnum = (typeof Record_regulationsScalarFieldEnum)[keyof typeof Record_regulationsScalarFieldEnum]


  export const RecordsScalarFieldEnum: {
    id: 'id',
    doc_id: 'doc_id',
    productId: 'productId',
    boilId: 'boilId',
    apparatusId: 'apparatusId',
    canId: 'canId',
    conveyorId: 'conveyorId',
    plan: 'plan',
    bbf: 'bbf',
    note: 'note',
    workshopId: 'workshopId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isSet: 'isSet',
    organic_base_id: 'organic_base_id',
    water_base_id: 'water_base_id',
    dm: 'dm'
  };

  export type RecordsScalarFieldEnum = (typeof RecordsScalarFieldEnum)[keyof typeof RecordsScalarFieldEnum]


  export const RegulationsScalarFieldEnum: {
    id: 'id',
    product_id: 'product_id',
    water_base_min_weight: 'water_base_min_weight',
    water_base_max_weight: 'water_base_max_weight',
    per_box: 'per_box',
    box_per_row: 'box_per_row',
    row_on_pallet: 'row_on_pallet',
    gasket: 'gasket',
    seal: 'seal',
    technician_note: 'technician_note',
    packaging_note: 'packaging_note',
    marking_sample_id: 'marking_sample_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RegulationsScalarFieldEnum = (typeof RegulationsScalarFieldEnum)[keyof typeof RegulationsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    value: 'value',
    description: 'description'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const Semi_productsScalarFieldEnum: {
    id: 'id',
    record_id: 'record_id',
    product_id: 'product_id',
    boil_id: 'boil_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Semi_productsScalarFieldEnum = (typeof Semi_productsScalarFieldEnum)[keyof typeof Semi_productsScalarFieldEnum]


  export const SeriesScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type SeriesScalarFieldEnum = (typeof SeriesScalarFieldEnum)[keyof typeof SeriesScalarFieldEnum]


  export const SignalsScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type SignalsScalarFieldEnum = (typeof SignalsScalarFieldEnum)[keyof typeof SignalsScalarFieldEnum]


  export const TokensScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokensScalarFieldEnum = (typeof TokensScalarFieldEnum)[keyof typeof TokensScalarFieldEnum]


  export const Tube_assemblyScalarFieldEnum: {
    id: 'id',
    tube_record_id: 'tube_record_id',
    tube_material_id: 'tube_material_id',
    tube_conveyor_post_id: 'tube_conveyor_post_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tube_assemblyScalarFieldEnum = (typeof Tube_assemblyScalarFieldEnum)[keyof typeof Tube_assemblyScalarFieldEnum]


  export const Tube_conveyor_postsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type Tube_conveyor_postsScalarFieldEnum = (typeof Tube_conveyor_postsScalarFieldEnum)[keyof typeof Tube_conveyor_postsScalarFieldEnum]


  export const Tube_conveyorsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    barcode: 'barcode'
  };

  export type Tube_conveyorsScalarFieldEnum = (typeof Tube_conveyorsScalarFieldEnum)[keyof typeof Tube_conveyorsScalarFieldEnum]


  export const Tube_historiesScalarFieldEnum: {
    id: 'id',
    tube_record_id: 'tube_record_id',
    tube_history_type_id: 'tube_history_type_id',
    employee_id: 'employee_id',
    note: 'note',
    tube_history_note_id: 'tube_history_note_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tube_historiesScalarFieldEnum = (typeof Tube_historiesScalarFieldEnum)[keyof typeof Tube_historiesScalarFieldEnum]


  export const Tube_histories_notesScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type Tube_histories_notesScalarFieldEnum = (typeof Tube_histories_notesScalarFieldEnum)[keyof typeof Tube_histories_notesScalarFieldEnum]


  export const Tube_history_typesScalarFieldEnum: {
    id: 'id',
    value: 'value',
    description: 'description'
  };

  export type Tube_history_typesScalarFieldEnum = (typeof Tube_history_typesScalarFieldEnum)[keyof typeof Tube_history_typesScalarFieldEnum]


  export const Tube_materialsScalarFieldEnum: {
    id: 'id',
    code_1C: 'code_1C',
    name: 'name'
  };

  export type Tube_materialsScalarFieldEnum = (typeof Tube_materialsScalarFieldEnum)[keyof typeof Tube_materialsScalarFieldEnum]


  export const Tube_parametersScalarFieldEnum: {
    id: 'id',
    tube_record_id: 'tube_record_id',
    press_speed_min: 'press_speed_min',
    press_speed_max: 'press_speed_max',
    molding_time_min: 'molding_time_min',
    molding_time_max: 'molding_time_max',
    turning_automate_speed_min: 'turning_automate_speed_min',
    turning_automate_speed_max: 'turning_automate_speed_max',
    annealing_furnace_temp_min: 'annealing_furnace_temp_min',
    annealing_furnace_temp_max: 'annealing_furnace_temp_max',
    cap_machine_speed_min: 'cap_machine_speed_min',
    cap_machine_speed_max: 'cap_machine_speed_max',
    cap_machine_air_pressure_min: 'cap_machine_air_pressure_min',
    cap_machine_air_pressure_max: 'cap_machine_air_pressure_max',
    grips_forward_min: 'grips_forward_min',
    grips_forward_max: 'grips_forward_max',
    grips_opening_left_min: 'grips_opening_left_min',
    grips_opening_left_max: 'grips_opening_left_max',
    grips_opening_right_min: 'grips_opening_right_min',
    grips_opening_right_max: 'grips_opening_right_max',
    grips_closing_min: 'grips_closing_min',
    grips_closing_max: 'grips_closing_max',
    injection_start_min: 'injection_start_min',
    injection_start_max: 'injection_start_max',
    injection_end_min: 'injection_end_min',
    injection_end_max: 'injection_end_max',
    tube_start_position_min: 'tube_start_position_min',
    tube_start_position_max: 'tube_start_position_max',
    tube_end_position_min: 'tube_end_position_min',
    tube_end_position_max: 'tube_end_position_max',
    padding_machine_speed_min: 'padding_machine_speed_min',
    padding_machine_speed_max: 'padding_machine_speed_max',
    padding_machine_air_pressure_min: 'padding_machine_air_pressure_min',
    padding_machine_air_pressure_max: 'padding_machine_air_pressure_max',
    padding_furnace_temp_min: 'padding_furnace_temp_min',
    padding_furnace_temp_max: 'padding_furnace_temp_max',
    offset_furnace_temp_min: 'offset_furnace_temp_min',
    offset_furnace_temp_max: 'offset_furnace_temp_max',
    printer_motor_speed_min: 'printer_motor_speed_min',
    printer_motor_speed_max: 'printer_motor_speed_max',
    holders_motor_speed_min: 'holders_motor_speed_min',
    holders_motor_speed_max: 'holders_motor_speed_max',
    station_motor_speed_min: 'station_motor_speed_min',
    station_motor_speed_max: 'station_motor_speed_max',
    ink_injection_time_min: 'ink_injection_time_min',
    ink_injection_time_max: 'ink_injection_time_max',
    lacquer_machine_speed_min: 'lacquer_machine_speed_min',
    lacquer_machine_speed_max: 'lacquer_machine_speed_max',
    lacquer_machine_air_pressure_min: 'lacquer_machine_air_pressure_min',
    lacquer_machine_air_pressure_max: 'lacquer_machine_air_pressure_max',
    feed_can_air_pressure_min: 'feed_can_air_pressure_min',
    feed_can_air_pressure_max: 'feed_can_air_pressure_max',
    nozzle_regulator_air_pressure_min: 'nozzle_regulator_air_pressure_min',
    nozzle_regulator_air_pressure_max: 'nozzle_regulator_air_pressure_max',
    cells_speed_min: 'cells_speed_min',
    cells_speed_max: 'cells_speed_max',
    injection_AB_start_position_min: 'injection_AB_start_position_min',
    injection_AB_start_position_max: 'injection_AB_start_position_max',
    injection_CD_start_position_min: 'injection_CD_start_position_min',
    injection_CD_start_position_max: 'injection_CD_start_position_max',
    injection_ABCD_end_position_min: 'injection_ABCD_end_position_min',
    injection_ABCD_end_position_max: 'injection_ABCD_end_position_max',
    tube_molding_start_position_min: 'tube_molding_start_position_min',
    tube_molding_start_position_max: 'tube_molding_start_position_max',
    tube_molding_end_position_min: 'tube_molding_end_position_min',
    tube_molding_end_position_max: 'tube_molding_end_position_max',
    polimerization_furnace_temperature_min: 'polimerization_furnace_temperature_min',
    polimerization_furnace_temperature_max: 'polimerization_furnace_temperature_max'
  };

  export type Tube_parametersScalarFieldEnum = (typeof Tube_parametersScalarFieldEnum)[keyof typeof Tube_parametersScalarFieldEnum]


  export const Tube_productsScalarFieldEnum: {
    id: 'id',
    code_1C: 'code_1C',
    marking: 'marking',
    name: 'name'
  };

  export type Tube_productsScalarFieldEnum = (typeof Tube_productsScalarFieldEnum)[keyof typeof Tube_productsScalarFieldEnum]


  export const Tube_recordsScalarFieldEnum: {
    id: 'id',
    tube_product_id: 'tube_product_id',
    tube_conveyor_id: 'tube_conveyor_id',
    boil_id: 'boil_id',
    plan: 'plan',
    start_date: 'start_date',
    active: 'active',
    finished: 'finished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tube_recordsScalarFieldEnum = (typeof Tube_recordsScalarFieldEnum)[keyof typeof Tube_recordsScalarFieldEnum]


  export const Tube_sessionsScalarFieldEnum: {
    id: 'id',
    conveyor_id: 'conveyor_id',
    employee_id: 'employee_id',
    finished: 'finished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tube_sessionsScalarFieldEnum = (typeof Tube_sessionsScalarFieldEnum)[keyof typeof Tube_sessionsScalarFieldEnum]


  export const Tube_specificationsScalarFieldEnum: {
    id: 'id',
    tube_product_id: 'tube_product_id',
    tube_material_id: 'tube_material_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Tube_specificationsScalarFieldEnum = (typeof Tube_specificationsScalarFieldEnum)[keyof typeof Tube_specificationsScalarFieldEnum]


  export const User_rolesScalarFieldEnum: {
    id: 'id',
    roleId: 'roleId',
    userId: 'userId'
  };

  export type User_rolesScalarFieldEnum = (typeof User_rolesScalarFieldEnum)[keyof typeof User_rolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    banned: 'banned',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const WorkshopsScalarFieldEnum: {
    id: 'id',
    value: 'value'
  };

  export type WorkshopsScalarFieldEnum = (typeof WorkshopsScalarFieldEnum)[keyof typeof WorkshopsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type BatchsWhereInput = {
    AND?: BatchsWhereInput | BatchsWhereInput[]
    OR?: BatchsWhereInput[]
    NOT?: BatchsWhereInput | BatchsWhereInput[]
    BatchPK?: IntFilter<"Batchs"> | number
    BatchName?: StringFilter<"Batchs"> | string
    BatchDate?: DateTimeNullableFilter<"Batchs"> | Date | string | null
    Plant?: StringFilter<"Batchs"> | string
    createdAt?: DateTimeFilter<"Batchs"> | Date | string
    updatedAt?: DateTimeFilter<"Batchs"> | Date | string
  }

  export type BatchsOrderByWithRelationInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchsWhereUniqueInput = Prisma.AtLeast<{
    BatchPK?: number
    BatchName?: string
    AND?: BatchsWhereInput | BatchsWhereInput[]
    OR?: BatchsWhereInput[]
    NOT?: BatchsWhereInput | BatchsWhereInput[]
    BatchDate?: DateTimeNullableFilter<"Batchs"> | Date | string | null
    Plant?: StringFilter<"Batchs"> | string
    createdAt?: DateTimeFilter<"Batchs"> | Date | string
    updatedAt?: DateTimeFilter<"Batchs"> | Date | string
  }, "BatchPK" | "BatchName">

  export type BatchsOrderByWithAggregationInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BatchsCountOrderByAggregateInput
    _avg?: BatchsAvgOrderByAggregateInput
    _max?: BatchsMaxOrderByAggregateInput
    _min?: BatchsMinOrderByAggregateInput
    _sum?: BatchsSumOrderByAggregateInput
  }

  export type BatchsScalarWhereWithAggregatesInput = {
    AND?: BatchsScalarWhereWithAggregatesInput | BatchsScalarWhereWithAggregatesInput[]
    OR?: BatchsScalarWhereWithAggregatesInput[]
    NOT?: BatchsScalarWhereWithAggregatesInput | BatchsScalarWhereWithAggregatesInput[]
    BatchPK?: IntWithAggregatesFilter<"Batchs"> | number
    BatchName?: StringWithAggregatesFilter<"Batchs"> | string
    BatchDate?: DateTimeNullableWithAggregatesFilter<"Batchs"> | Date | string | null
    Plant?: StringWithAggregatesFilter<"Batchs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Batchs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Batchs"> | Date | string
  }

  export type TraceBatchesWhereInput = {
    AND?: TraceBatchesWhereInput | TraceBatchesWhereInput[]
    OR?: TraceBatchesWhereInput[]
    NOT?: TraceBatchesWhereInput | TraceBatchesWhereInput[]
    id?: IntFilter<"TraceBatches"> | number
    BatchPK?: IntNullableFilter<"TraceBatches"> | number | null
    BatchName?: StringNullableFilter<"TraceBatches"> | string | null
    BatchDate?: DateTimeNullableFilter<"TraceBatches"> | Date | string | null
    Plant?: StringNullableFilter<"TraceBatches"> | string | null
    createdAt?: DateTimeFilter<"TraceBatches"> | Date | string
    updatedAt?: DateTimeFilter<"TraceBatches"> | Date | string
  }

  export type TraceBatchesOrderByWithRelationInput = {
    id?: SortOrder
    BatchPK?: SortOrderInput | SortOrder
    BatchName?: SortOrderInput | SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TraceBatchesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TraceBatchesWhereInput | TraceBatchesWhereInput[]
    OR?: TraceBatchesWhereInput[]
    NOT?: TraceBatchesWhereInput | TraceBatchesWhereInput[]
    BatchPK?: IntNullableFilter<"TraceBatches"> | number | null
    BatchName?: StringNullableFilter<"TraceBatches"> | string | null
    BatchDate?: DateTimeNullableFilter<"TraceBatches"> | Date | string | null
    Plant?: StringNullableFilter<"TraceBatches"> | string | null
    createdAt?: DateTimeFilter<"TraceBatches"> | Date | string
    updatedAt?: DateTimeFilter<"TraceBatches"> | Date | string
  }, "id">

  export type TraceBatchesOrderByWithAggregationInput = {
    id?: SortOrder
    BatchPK?: SortOrderInput | SortOrder
    BatchName?: SortOrderInput | SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TraceBatchesCountOrderByAggregateInput
    _avg?: TraceBatchesAvgOrderByAggregateInput
    _max?: TraceBatchesMaxOrderByAggregateInput
    _min?: TraceBatchesMinOrderByAggregateInput
    _sum?: TraceBatchesSumOrderByAggregateInput
  }

  export type TraceBatchesScalarWhereWithAggregatesInput = {
    AND?: TraceBatchesScalarWhereWithAggregatesInput | TraceBatchesScalarWhereWithAggregatesInput[]
    OR?: TraceBatchesScalarWhereWithAggregatesInput[]
    NOT?: TraceBatchesScalarWhereWithAggregatesInput | TraceBatchesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TraceBatches"> | number
    BatchPK?: IntNullableWithAggregatesFilter<"TraceBatches"> | number | null
    BatchName?: StringNullableWithAggregatesFilter<"TraceBatches"> | string | null
    BatchDate?: DateTimeNullableWithAggregatesFilter<"TraceBatches"> | Date | string | null
    Plant?: StringNullableWithAggregatesFilter<"TraceBatches"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TraceBatches"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TraceBatches"> | Date | string
  }

  export type api_errorsWhereInput = {
    AND?: api_errorsWhereInput | api_errorsWhereInput[]
    OR?: api_errorsWhereInput[]
    NOT?: api_errorsWhereInput | api_errorsWhereInput[]
    id?: IntFilter<"api_errors"> | number
    dto?: StringNullableFilter<"api_errors"> | string | null
    message?: StringNullableFilter<"api_errors"> | string | null
    createdAt?: DateTimeFilter<"api_errors"> | Date | string
    updatedAt?: DateTimeFilter<"api_errors"> | Date | string
  }

  export type api_errorsOrderByWithRelationInput = {
    id?: SortOrder
    dto?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type api_errorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: api_errorsWhereInput | api_errorsWhereInput[]
    OR?: api_errorsWhereInput[]
    NOT?: api_errorsWhereInput | api_errorsWhereInput[]
    dto?: StringNullableFilter<"api_errors"> | string | null
    message?: StringNullableFilter<"api_errors"> | string | null
    createdAt?: DateTimeFilter<"api_errors"> | Date | string
    updatedAt?: DateTimeFilter<"api_errors"> | Date | string
  }, "id">

  export type api_errorsOrderByWithAggregationInput = {
    id?: SortOrder
    dto?: SortOrderInput | SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: api_errorsCountOrderByAggregateInput
    _avg?: api_errorsAvgOrderByAggregateInput
    _max?: api_errorsMaxOrderByAggregateInput
    _min?: api_errorsMinOrderByAggregateInput
    _sum?: api_errorsSumOrderByAggregateInput
  }

  export type api_errorsScalarWhereWithAggregatesInput = {
    AND?: api_errorsScalarWhereWithAggregatesInput | api_errorsScalarWhereWithAggregatesInput[]
    OR?: api_errorsScalarWhereWithAggregatesInput[]
    NOT?: api_errorsScalarWhereWithAggregatesInput | api_errorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"api_errors"> | number
    dto?: StringNullableWithAggregatesFilter<"api_errors"> | string | null
    message?: StringNullableWithAggregatesFilter<"api_errors"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"api_errors"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"api_errors"> | Date | string
  }

  export type apparatusesWhereInput = {
    AND?: apparatusesWhereInput | apparatusesWhereInput[]
    OR?: apparatusesWhereInput[]
    NOT?: apparatusesWhereInput | apparatusesWhereInput[]
    id?: IntFilter<"apparatuses"> | number
    value?: StringFilter<"apparatuses"> | string
    records?: RecordsListRelationFilter
  }

  export type apparatusesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    records?: recordsOrderByRelationAggregateInput
  }

  export type apparatusesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: apparatusesWhereInput | apparatusesWhereInput[]
    OR?: apparatusesWhereInput[]
    NOT?: apparatusesWhereInput | apparatusesWhereInput[]
    records?: RecordsListRelationFilter
  }, "id" | "value">

  export type apparatusesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    _count?: apparatusesCountOrderByAggregateInput
    _avg?: apparatusesAvgOrderByAggregateInput
    _max?: apparatusesMaxOrderByAggregateInput
    _min?: apparatusesMinOrderByAggregateInput
    _sum?: apparatusesSumOrderByAggregateInput
  }

  export type apparatusesScalarWhereWithAggregatesInput = {
    AND?: apparatusesScalarWhereWithAggregatesInput | apparatusesScalarWhereWithAggregatesInput[]
    OR?: apparatusesScalarWhereWithAggregatesInput[]
    NOT?: apparatusesScalarWhereWithAggregatesInput | apparatusesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"apparatuses"> | number
    value?: StringWithAggregatesFilter<"apparatuses"> | string
  }

  export type basesWhereInput = {
    AND?: basesWhereInput | basesWhereInput[]
    OR?: basesWhereInput[]
    NOT?: basesWhereInput | basesWhereInput[]
    id?: IntFilter<"bases"> | number
    code?: StringFilter<"bases"> | string
    marking?: StringNullableFilter<"bases"> | string | null
    boils?: BoilsListRelationFilter
  }

  export type basesOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    marking?: SortOrderInput | SortOrder
    boils?: boilsOrderByRelationAggregateInput
  }

  export type basesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: basesWhereInput | basesWhereInput[]
    OR?: basesWhereInput[]
    NOT?: basesWhereInput | basesWhereInput[]
    marking?: StringNullableFilter<"bases"> | string | null
    boils?: BoilsListRelationFilter
  }, "id" | "code">

  export type basesOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    marking?: SortOrderInput | SortOrder
    _count?: basesCountOrderByAggregateInput
    _avg?: basesAvgOrderByAggregateInput
    _max?: basesMaxOrderByAggregateInput
    _min?: basesMinOrderByAggregateInput
    _sum?: basesSumOrderByAggregateInput
  }

  export type basesScalarWhereWithAggregatesInput = {
    AND?: basesScalarWhereWithAggregatesInput | basesScalarWhereWithAggregatesInput[]
    OR?: basesScalarWhereWithAggregatesInput[]
    NOT?: basesScalarWhereWithAggregatesInput | basesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"bases"> | number
    code?: StringWithAggregatesFilter<"bases"> | string
    marking?: StringNullableWithAggregatesFilter<"bases"> | string | null
  }

  export type batchsWhereInput = {
    AND?: batchsWhereInput | batchsWhereInput[]
    OR?: batchsWhereInput[]
    NOT?: batchsWhereInput | batchsWhereInput[]
    BatchPK?: IntFilter<"batchs"> | number
    BatchName?: StringFilter<"batchs"> | string
    BatchDate?: DateTimeNullableFilter<"batchs"> | Date | string | null
    Plant?: StringFilter<"batchs"> | string
    createdAt?: DateTimeFilter<"batchs"> | Date | string
    updatedAt?: DateTimeFilter<"batchs"> | Date | string
  }

  export type batchsOrderByWithRelationInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type batchsWhereUniqueInput = Prisma.AtLeast<{
    BatchPK?: number
    BatchName?: string
    AND?: batchsWhereInput | batchsWhereInput[]
    OR?: batchsWhereInput[]
    NOT?: batchsWhereInput | batchsWhereInput[]
    BatchDate?: DateTimeNullableFilter<"batchs"> | Date | string | null
    Plant?: StringFilter<"batchs"> | string
    createdAt?: DateTimeFilter<"batchs"> | Date | string
    updatedAt?: DateTimeFilter<"batchs"> | Date | string
  }, "BatchPK" | "BatchName">

  export type batchsOrderByWithAggregationInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: batchsCountOrderByAggregateInput
    _avg?: batchsAvgOrderByAggregateInput
    _max?: batchsMaxOrderByAggregateInput
    _min?: batchsMinOrderByAggregateInput
    _sum?: batchsSumOrderByAggregateInput
  }

  export type batchsScalarWhereWithAggregatesInput = {
    AND?: batchsScalarWhereWithAggregatesInput | batchsScalarWhereWithAggregatesInput[]
    OR?: batchsScalarWhereWithAggregatesInput[]
    NOT?: batchsScalarWhereWithAggregatesInput | batchsScalarWhereWithAggregatesInput[]
    BatchPK?: IntWithAggregatesFilter<"batchs"> | number
    BatchName?: StringWithAggregatesFilter<"batchs"> | string
    BatchDate?: DateTimeNullableWithAggregatesFilter<"batchs"> | Date | string | null
    Plant?: StringWithAggregatesFilter<"batchs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"batchs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"batchs"> | Date | string
  }

  export type boilsWhereInput = {
    AND?: boilsWhereInput | boilsWhereInput[]
    OR?: boilsWhereInput[]
    NOT?: boilsWhereInput | boilsWhereInput[]
    id?: IntFilter<"boils"> | number
    value?: StringFilter<"boils"> | string
    base_id?: IntNullableFilter<"boils"> | number | null
    letter?: StringNullableFilter<"boils"> | string | null
    year?: DecimalNullableFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    number?: DecimalNullableFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    plant_id?: IntNullableFilter<"boils"> | number | null
    bases?: XOR<BasesNullableScalarRelationFilter, basesWhereInput> | null
    semi_products?: Semi_productsListRelationFilter
    tube_records?: Tube_recordsListRelationFilter
    records?: RecordsListRelationFilter
  }

  export type boilsOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    base_id?: SortOrderInput | SortOrder
    letter?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    plant_id?: SortOrderInput | SortOrder
    bases?: basesOrderByWithRelationInput
    semi_products?: semi_productsOrderByRelationAggregateInput
    tube_records?: tube_recordsOrderByRelationAggregateInput
    records?: recordsOrderByRelationAggregateInput
  }

  export type boilsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: boilsWhereInput | boilsWhereInput[]
    OR?: boilsWhereInput[]
    NOT?: boilsWhereInput | boilsWhereInput[]
    base_id?: IntNullableFilter<"boils"> | number | null
    letter?: StringNullableFilter<"boils"> | string | null
    year?: DecimalNullableFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    number?: DecimalNullableFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    plant_id?: IntNullableFilter<"boils"> | number | null
    bases?: XOR<BasesNullableScalarRelationFilter, basesWhereInput> | null
    semi_products?: Semi_productsListRelationFilter
    tube_records?: Tube_recordsListRelationFilter
    records?: RecordsListRelationFilter
  }, "id" | "value">

  export type boilsOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    base_id?: SortOrderInput | SortOrder
    letter?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    number?: SortOrderInput | SortOrder
    plant_id?: SortOrderInput | SortOrder
    _count?: boilsCountOrderByAggregateInput
    _avg?: boilsAvgOrderByAggregateInput
    _max?: boilsMaxOrderByAggregateInput
    _min?: boilsMinOrderByAggregateInput
    _sum?: boilsSumOrderByAggregateInput
  }

  export type boilsScalarWhereWithAggregatesInput = {
    AND?: boilsScalarWhereWithAggregatesInput | boilsScalarWhereWithAggregatesInput[]
    OR?: boilsScalarWhereWithAggregatesInput[]
    NOT?: boilsScalarWhereWithAggregatesInput | boilsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"boils"> | number
    value?: StringWithAggregatesFilter<"boils"> | string
    base_id?: IntNullableWithAggregatesFilter<"boils"> | number | null
    letter?: StringNullableWithAggregatesFilter<"boils"> | string | null
    year?: DecimalNullableWithAggregatesFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    number?: DecimalNullableWithAggregatesFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    plant_id?: IntNullableWithAggregatesFilter<"boils"> | number | null
  }

  export type cansWhereInput = {
    AND?: cansWhereInput | cansWhereInput[]
    OR?: cansWhereInput[]
    NOT?: cansWhereInput | cansWhereInput[]
    id?: IntFilter<"cans"> | number
    value?: StringFilter<"cans"> | string
    records?: RecordsListRelationFilter
  }

  export type cansOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    records?: recordsOrderByRelationAggregateInput
  }

  export type cansWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: cansWhereInput | cansWhereInput[]
    OR?: cansWhereInput[]
    NOT?: cansWhereInput | cansWhereInput[]
    records?: RecordsListRelationFilter
  }, "id" | "value">

  export type cansOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    _count?: cansCountOrderByAggregateInput
    _avg?: cansAvgOrderByAggregateInput
    _max?: cansMaxOrderByAggregateInput
    _min?: cansMinOrderByAggregateInput
    _sum?: cansSumOrderByAggregateInput
  }

  export type cansScalarWhereWithAggregatesInput = {
    AND?: cansScalarWhereWithAggregatesInput | cansScalarWhereWithAggregatesInput[]
    OR?: cansScalarWhereWithAggregatesInput[]
    NOT?: cansScalarWhereWithAggregatesInput | cansScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cans"> | number
    value?: StringWithAggregatesFilter<"cans"> | string
  }

  export type conveyorsWhereInput = {
    AND?: conveyorsWhereInput | conveyorsWhereInput[]
    OR?: conveyorsWhereInput[]
    NOT?: conveyorsWhereInput | conveyorsWhereInput[]
    id?: IntFilter<"conveyors"> | number
    value?: StringFilter<"conveyors"> | string
    barcode?: StringNullableFilter<"conveyors"> | string | null
    records?: RecordsListRelationFilter
  }

  export type conveyorsOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    barcode?: SortOrderInput | SortOrder
    records?: recordsOrderByRelationAggregateInput
  }

  export type conveyorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: conveyorsWhereInput | conveyorsWhereInput[]
    OR?: conveyorsWhereInput[]
    NOT?: conveyorsWhereInput | conveyorsWhereInput[]
    barcode?: StringNullableFilter<"conveyors"> | string | null
    records?: RecordsListRelationFilter
  }, "id" | "value">

  export type conveyorsOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    barcode?: SortOrderInput | SortOrder
    _count?: conveyorsCountOrderByAggregateInput
    _avg?: conveyorsAvgOrderByAggregateInput
    _max?: conveyorsMaxOrderByAggregateInput
    _min?: conveyorsMinOrderByAggregateInput
    _sum?: conveyorsSumOrderByAggregateInput
  }

  export type conveyorsScalarWhereWithAggregatesInput = {
    AND?: conveyorsScalarWhereWithAggregatesInput | conveyorsScalarWhereWithAggregatesInput[]
    OR?: conveyorsScalarWhereWithAggregatesInput[]
    NOT?: conveyorsScalarWhereWithAggregatesInput | conveyorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"conveyors"> | number
    value?: StringWithAggregatesFilter<"conveyors"> | string
    barcode?: StringNullableWithAggregatesFilter<"conveyors"> | string | null
  }

  export type dbo_BatchsWhereInput = {
    AND?: dbo_BatchsWhereInput | dbo_BatchsWhereInput[]
    OR?: dbo_BatchsWhereInput[]
    NOT?: dbo_BatchsWhereInput | dbo_BatchsWhereInput[]
    BatchPK?: IntFilter<"dbo_Batchs"> | number
    BatchName?: StringFilter<"dbo_Batchs"> | string
    BatchDate?: DateTimeNullableFilter<"dbo_Batchs"> | Date | string | null
    Plant?: StringFilter<"dbo_Batchs"> | string
    createdAt?: DateTimeFilter<"dbo_Batchs"> | Date | string
    updatedAt?: DateTimeFilter<"dbo_Batchs"> | Date | string
  }

  export type dbo_BatchsOrderByWithRelationInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dbo_BatchsWhereUniqueInput = Prisma.AtLeast<{
    BatchPK?: number
    BatchName?: string
    AND?: dbo_BatchsWhereInput | dbo_BatchsWhereInput[]
    OR?: dbo_BatchsWhereInput[]
    NOT?: dbo_BatchsWhereInput | dbo_BatchsWhereInput[]
    BatchDate?: DateTimeNullableFilter<"dbo_Batchs"> | Date | string | null
    Plant?: StringFilter<"dbo_Batchs"> | string
    createdAt?: DateTimeFilter<"dbo_Batchs"> | Date | string
    updatedAt?: DateTimeFilter<"dbo_Batchs"> | Date | string
  }, "BatchPK" | "BatchName">

  export type dbo_BatchsOrderByWithAggregationInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrderInput | SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: dbo_BatchsCountOrderByAggregateInput
    _avg?: dbo_BatchsAvgOrderByAggregateInput
    _max?: dbo_BatchsMaxOrderByAggregateInput
    _min?: dbo_BatchsMinOrderByAggregateInput
    _sum?: dbo_BatchsSumOrderByAggregateInput
  }

  export type dbo_BatchsScalarWhereWithAggregatesInput = {
    AND?: dbo_BatchsScalarWhereWithAggregatesInput | dbo_BatchsScalarWhereWithAggregatesInput[]
    OR?: dbo_BatchsScalarWhereWithAggregatesInput[]
    NOT?: dbo_BatchsScalarWhereWithAggregatesInput | dbo_BatchsScalarWhereWithAggregatesInput[]
    BatchPK?: IntWithAggregatesFilter<"dbo_Batchs"> | number
    BatchName?: StringWithAggregatesFilter<"dbo_Batchs"> | string
    BatchDate?: DateTimeNullableWithAggregatesFilter<"dbo_Batchs"> | Date | string | null
    Plant?: StringWithAggregatesFilter<"dbo_Batchs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"dbo_Batchs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"dbo_Batchs"> | Date | string
  }

  export type docsWhereInput = {
    AND?: docsWhereInput | docsWhereInput[]
    OR?: docsWhereInput[]
    NOT?: docsWhereInput | docsWhereInput[]
    id?: IntFilter<"docs"> | number
    plantId?: IntNullableFilter<"docs"> | number | null
    date?: DateTimeFilter<"docs"> | Date | string
    createdAt?: DateTimeFilter<"docs"> | Date | string
    updatedAt?: DateTimeFilter<"docs"> | Date | string
    plants?: XOR<PlantsNullableScalarRelationFilter, plantsWhereInput> | null
    records?: RecordsListRelationFilter
  }

  export type docsOrderByWithRelationInput = {
    id?: SortOrder
    plantId?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plants?: plantsOrderByWithRelationInput
    records?: recordsOrderByRelationAggregateInput
  }

  export type docsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: docsWhereInput | docsWhereInput[]
    OR?: docsWhereInput[]
    NOT?: docsWhereInput | docsWhereInput[]
    plantId?: IntNullableFilter<"docs"> | number | null
    date?: DateTimeFilter<"docs"> | Date | string
    createdAt?: DateTimeFilter<"docs"> | Date | string
    updatedAt?: DateTimeFilter<"docs"> | Date | string
    plants?: XOR<PlantsNullableScalarRelationFilter, plantsWhereInput> | null
    records?: RecordsListRelationFilter
  }, "id">

  export type docsOrderByWithAggregationInput = {
    id?: SortOrder
    plantId?: SortOrderInput | SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: docsCountOrderByAggregateInput
    _avg?: docsAvgOrderByAggregateInput
    _max?: docsMaxOrderByAggregateInput
    _min?: docsMinOrderByAggregateInput
    _sum?: docsSumOrderByAggregateInput
  }

  export type docsScalarWhereWithAggregatesInput = {
    AND?: docsScalarWhereWithAggregatesInput | docsScalarWhereWithAggregatesInput[]
    OR?: docsScalarWhereWithAggregatesInput[]
    NOT?: docsScalarWhereWithAggregatesInput | docsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"docs"> | number
    plantId?: IntNullableWithAggregatesFilter<"docs"> | number | null
    date?: DateTimeWithAggregatesFilter<"docs"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"docs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"docs"> | Date | string
  }

  export type employeesWhereInput = {
    AND?: employeesWhereInput | employeesWhereInput[]
    OR?: employeesWhereInput[]
    NOT?: employeesWhereInput | employeesWhereInput[]
    id?: IntFilter<"employees"> | number
    name?: StringFilter<"employees"> | string
    barcode?: StringFilter<"employees"> | string
    occupationId?: IntNullableFilter<"employees"> | number | null
    createdAt?: DateTimeFilter<"employees"> | Date | string
    updatedAt?: DateTimeFilter<"employees"> | Date | string
    occupations?: XOR<OccupationsNullableScalarRelationFilter, occupationsWhereInput> | null
    histories?: HistoriesListRelationFilter
    tube_histories?: Tube_historiesListRelationFilter
    tube_sessions?: Tube_sessionsListRelationFilter
  }

  export type employeesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    occupationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    occupations?: occupationsOrderByWithRelationInput
    histories?: historiesOrderByRelationAggregateInput
    tube_histories?: tube_historiesOrderByRelationAggregateInput
    tube_sessions?: tube_sessionsOrderByRelationAggregateInput
  }

  export type employeesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    barcode?: string
    AND?: employeesWhereInput | employeesWhereInput[]
    OR?: employeesWhereInput[]
    NOT?: employeesWhereInput | employeesWhereInput[]
    occupationId?: IntNullableFilter<"employees"> | number | null
    createdAt?: DateTimeFilter<"employees"> | Date | string
    updatedAt?: DateTimeFilter<"employees"> | Date | string
    occupations?: XOR<OccupationsNullableScalarRelationFilter, occupationsWhereInput> | null
    histories?: HistoriesListRelationFilter
    tube_histories?: Tube_historiesListRelationFilter
    tube_sessions?: Tube_sessionsListRelationFilter
  }, "id" | "name" | "barcode">

  export type employeesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    occupationId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: employeesCountOrderByAggregateInput
    _avg?: employeesAvgOrderByAggregateInput
    _max?: employeesMaxOrderByAggregateInput
    _min?: employeesMinOrderByAggregateInput
    _sum?: employeesSumOrderByAggregateInput
  }

  export type employeesScalarWhereWithAggregatesInput = {
    AND?: employeesScalarWhereWithAggregatesInput | employeesScalarWhereWithAggregatesInput[]
    OR?: employeesScalarWhereWithAggregatesInput[]
    NOT?: employeesScalarWhereWithAggregatesInput | employeesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"employees"> | number
    name?: StringWithAggregatesFilter<"employees"> | string
    barcode?: StringWithAggregatesFilter<"employees"> | string
    occupationId?: IntNullableWithAggregatesFilter<"employees"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"employees"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"employees"> | Date | string
  }

  export type historiesWhereInput = {
    AND?: historiesWhereInput | historiesWhereInput[]
    OR?: historiesWhereInput[]
    NOT?: historiesWhereInput | historiesWhereInput[]
    id?: IntFilter<"histories"> | number
    record_id?: IntNullableFilter<"histories"> | number | null
    boil_id?: IntNullableFilter<"histories"> | number | null
    historyTypeId?: IntNullableFilter<"histories"> | number | null
    userId?: IntNullableFilter<"histories"> | number | null
    employeeId?: IntNullableFilter<"histories"> | number | null
    note?: StringNullableFilter<"histories"> | string | null
    createdAt?: DateTimeFilter<"histories"> | Date | string
    updatedAt?: DateTimeFilter<"histories"> | Date | string
    note_id?: IntNullableFilter<"histories"> | number | null
    plant_id?: IntNullableFilter<"histories"> | number | null
    employees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
    history_types?: XOR<History_typesNullableScalarRelationFilter, history_typesWhereInput> | null
    records?: XOR<RecordsNullableScalarRelationFilter, recordsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type historiesOrderByWithRelationInput = {
    id?: SortOrder
    record_id?: SortOrderInput | SortOrder
    boil_id?: SortOrderInput | SortOrder
    historyTypeId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note_id?: SortOrderInput | SortOrder
    plant_id?: SortOrderInput | SortOrder
    employees?: employeesOrderByWithRelationInput
    history_types?: history_typesOrderByWithRelationInput
    records?: recordsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type historiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: historiesWhereInput | historiesWhereInput[]
    OR?: historiesWhereInput[]
    NOT?: historiesWhereInput | historiesWhereInput[]
    record_id?: IntNullableFilter<"histories"> | number | null
    boil_id?: IntNullableFilter<"histories"> | number | null
    historyTypeId?: IntNullableFilter<"histories"> | number | null
    userId?: IntNullableFilter<"histories"> | number | null
    employeeId?: IntNullableFilter<"histories"> | number | null
    note?: StringNullableFilter<"histories"> | string | null
    createdAt?: DateTimeFilter<"histories"> | Date | string
    updatedAt?: DateTimeFilter<"histories"> | Date | string
    note_id?: IntNullableFilter<"histories"> | number | null
    plant_id?: IntNullableFilter<"histories"> | number | null
    employees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
    history_types?: XOR<History_typesNullableScalarRelationFilter, history_typesWhereInput> | null
    records?: XOR<RecordsNullableScalarRelationFilter, recordsWhereInput> | null
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id">

  export type historiesOrderByWithAggregationInput = {
    id?: SortOrder
    record_id?: SortOrderInput | SortOrder
    boil_id?: SortOrderInput | SortOrder
    historyTypeId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note_id?: SortOrderInput | SortOrder
    plant_id?: SortOrderInput | SortOrder
    _count?: historiesCountOrderByAggregateInput
    _avg?: historiesAvgOrderByAggregateInput
    _max?: historiesMaxOrderByAggregateInput
    _min?: historiesMinOrderByAggregateInput
    _sum?: historiesSumOrderByAggregateInput
  }

  export type historiesScalarWhereWithAggregatesInput = {
    AND?: historiesScalarWhereWithAggregatesInput | historiesScalarWhereWithAggregatesInput[]
    OR?: historiesScalarWhereWithAggregatesInput[]
    NOT?: historiesScalarWhereWithAggregatesInput | historiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"histories"> | number
    record_id?: IntNullableWithAggregatesFilter<"histories"> | number | null
    boil_id?: IntNullableWithAggregatesFilter<"histories"> | number | null
    historyTypeId?: IntNullableWithAggregatesFilter<"histories"> | number | null
    userId?: IntNullableWithAggregatesFilter<"histories"> | number | null
    employeeId?: IntNullableWithAggregatesFilter<"histories"> | number | null
    note?: StringNullableWithAggregatesFilter<"histories"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"histories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"histories"> | Date | string
    note_id?: IntNullableWithAggregatesFilter<"histories"> | number | null
    plant_id?: IntNullableWithAggregatesFilter<"histories"> | number | null
  }

  export type history_typesWhereInput = {
    AND?: history_typesWhereInput | history_typesWhereInput[]
    OR?: history_typesWhereInput[]
    NOT?: history_typesWhereInput | history_typesWhereInput[]
    id?: IntFilter<"history_types"> | number
    value?: StringFilter<"history_types"> | string
    description?: StringFilter<"history_types"> | string
    for_boil?: BoolNullableFilter<"history_types"> | boolean | null
    histories?: HistoriesListRelationFilter
  }

  export type history_typesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    for_boil?: SortOrderInput | SortOrder
    histories?: historiesOrderByRelationAggregateInput
  }

  export type history_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    description?: string
    AND?: history_typesWhereInput | history_typesWhereInput[]
    OR?: history_typesWhereInput[]
    NOT?: history_typesWhereInput | history_typesWhereInput[]
    for_boil?: BoolNullableFilter<"history_types"> | boolean | null
    histories?: HistoriesListRelationFilter
  }, "id" | "value" | "description">

  export type history_typesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    for_boil?: SortOrderInput | SortOrder
    _count?: history_typesCountOrderByAggregateInput
    _avg?: history_typesAvgOrderByAggregateInput
    _max?: history_typesMaxOrderByAggregateInput
    _min?: history_typesMinOrderByAggregateInput
    _sum?: history_typesSumOrderByAggregateInput
  }

  export type history_typesScalarWhereWithAggregatesInput = {
    AND?: history_typesScalarWhereWithAggregatesInput | history_typesScalarWhereWithAggregatesInput[]
    OR?: history_typesScalarWhereWithAggregatesInput[]
    NOT?: history_typesScalarWhereWithAggregatesInput | history_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"history_types"> | number
    value?: StringWithAggregatesFilter<"history_types"> | string
    description?: StringWithAggregatesFilter<"history_types"> | string
    for_boil?: BoolNullableWithAggregatesFilter<"history_types"> | boolean | null
  }

  export type marking_sampleWhereInput = {
    AND?: marking_sampleWhereInput | marking_sampleWhereInput[]
    OR?: marking_sampleWhereInput[]
    NOT?: marking_sampleWhereInput | marking_sampleWhereInput[]
    id?: IntFilter<"marking_sample"> | number
    value?: StringNullableFilter<"marking_sample"> | string | null
    createdAt?: DateTimeFilter<"marking_sample"> | Date | string
    updatedAt?: DateTimeFilter<"marking_sample"> | Date | string
    record_regulations?: Record_regulationsListRelationFilter
    regulations?: RegulationsListRelationFilter
  }

  export type marking_sampleOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    record_regulations?: record_regulationsOrderByRelationAggregateInput
    regulations?: regulationsOrderByRelationAggregateInput
  }

  export type marking_sampleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: marking_sampleWhereInput | marking_sampleWhereInput[]
    OR?: marking_sampleWhereInput[]
    NOT?: marking_sampleWhereInput | marking_sampleWhereInput[]
    value?: StringNullableFilter<"marking_sample"> | string | null
    createdAt?: DateTimeFilter<"marking_sample"> | Date | string
    updatedAt?: DateTimeFilter<"marking_sample"> | Date | string
    record_regulations?: Record_regulationsListRelationFilter
    regulations?: RegulationsListRelationFilter
  }, "id">

  export type marking_sampleOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: marking_sampleCountOrderByAggregateInput
    _avg?: marking_sampleAvgOrderByAggregateInput
    _max?: marking_sampleMaxOrderByAggregateInput
    _min?: marking_sampleMinOrderByAggregateInput
    _sum?: marking_sampleSumOrderByAggregateInput
  }

  export type marking_sampleScalarWhereWithAggregatesInput = {
    AND?: marking_sampleScalarWhereWithAggregatesInput | marking_sampleScalarWhereWithAggregatesInput[]
    OR?: marking_sampleScalarWhereWithAggregatesInput[]
    NOT?: marking_sampleScalarWhereWithAggregatesInput | marking_sampleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"marking_sample"> | number
    value?: StringNullableWithAggregatesFilter<"marking_sample"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"marking_sample"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"marking_sample"> | Date | string
  }

  export type notesWhereInput = {
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    id?: IntFilter<"notes"> | number
    value?: StringNullableFilter<"notes"> | string | null
  }

  export type notesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
  }

  export type notesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: notesWhereInput | notesWhereInput[]
    OR?: notesWhereInput[]
    NOT?: notesWhereInput | notesWhereInput[]
    value?: StringNullableFilter<"notes"> | string | null
  }, "id">

  export type notesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    _count?: notesCountOrderByAggregateInput
    _avg?: notesAvgOrderByAggregateInput
    _max?: notesMaxOrderByAggregateInput
    _min?: notesMinOrderByAggregateInput
    _sum?: notesSumOrderByAggregateInput
  }

  export type notesScalarWhereWithAggregatesInput = {
    AND?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    OR?: notesScalarWhereWithAggregatesInput[]
    NOT?: notesScalarWhereWithAggregatesInput | notesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"notes"> | number
    value?: StringNullableWithAggregatesFilter<"notes"> | string | null
  }

  export type occupationsWhereInput = {
    AND?: occupationsWhereInput | occupationsWhereInput[]
    OR?: occupationsWhereInput[]
    NOT?: occupationsWhereInput | occupationsWhereInput[]
    id?: IntFilter<"occupations"> | number
    value?: StringFilter<"occupations"> | string
    description?: StringFilter<"occupations"> | string
    employees?: EmployeesListRelationFilter
  }

  export type occupationsOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    employees?: employeesOrderByRelationAggregateInput
  }

  export type occupationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    description?: string
    AND?: occupationsWhereInput | occupationsWhereInput[]
    OR?: occupationsWhereInput[]
    NOT?: occupationsWhereInput | occupationsWhereInput[]
    employees?: EmployeesListRelationFilter
  }, "id" | "value" | "description">

  export type occupationsOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    _count?: occupationsCountOrderByAggregateInput
    _avg?: occupationsAvgOrderByAggregateInput
    _max?: occupationsMaxOrderByAggregateInput
    _min?: occupationsMinOrderByAggregateInput
    _sum?: occupationsSumOrderByAggregateInput
  }

  export type occupationsScalarWhereWithAggregatesInput = {
    AND?: occupationsScalarWhereWithAggregatesInput | occupationsScalarWhereWithAggregatesInput[]
    OR?: occupationsScalarWhereWithAggregatesInput[]
    NOT?: occupationsScalarWhereWithAggregatesInput | occupationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"occupations"> | number
    value?: StringWithAggregatesFilter<"occupations"> | string
    description?: StringWithAggregatesFilter<"occupations"> | string
  }

  export type plantsWhereInput = {
    AND?: plantsWhereInput | plantsWhereInput[]
    OR?: plantsWhereInput[]
    NOT?: plantsWhereInput | plantsWhereInput[]
    id?: IntFilter<"plants"> | number
    value?: StringFilter<"plants"> | string
    abb?: StringNullableFilter<"plants"> | string | null
    docs?: DocsListRelationFilter
  }

  export type plantsOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    abb?: SortOrderInput | SortOrder
    docs?: docsOrderByRelationAggregateInput
  }

  export type plantsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: plantsWhereInput | plantsWhereInput[]
    OR?: plantsWhereInput[]
    NOT?: plantsWhereInput | plantsWhereInput[]
    abb?: StringNullableFilter<"plants"> | string | null
    docs?: DocsListRelationFilter
  }, "id" | "value">

  export type plantsOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    abb?: SortOrderInput | SortOrder
    _count?: plantsCountOrderByAggregateInput
    _avg?: plantsAvgOrderByAggregateInput
    _max?: plantsMaxOrderByAggregateInput
    _min?: plantsMinOrderByAggregateInput
    _sum?: plantsSumOrderByAggregateInput
  }

  export type plantsScalarWhereWithAggregatesInput = {
    AND?: plantsScalarWhereWithAggregatesInput | plantsScalarWhereWithAggregatesInput[]
    OR?: plantsScalarWhereWithAggregatesInput[]
    NOT?: plantsScalarWhereWithAggregatesInput | plantsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"plants"> | number
    value?: StringWithAggregatesFilter<"plants"> | string
    abb?: StringNullableWithAggregatesFilter<"plants"> | string | null
  }

  export type productsWhereInput = {
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    id?: IntFilter<"products"> | number
    code1C?: StringFilter<"products"> | string
    marking?: StringFilter<"products"> | string
    name?: StringNullableFilter<"products"> | string | null
    serieId?: IntNullableFilter<"products"> | number | null
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    series?: XOR<SeriesNullableScalarRelationFilter, seriesWhereInput> | null
    records?: RecordsListRelationFilter
    regulations?: RegulationsListRelationFilter
    semi_products?: Semi_productsListRelationFilter
  }

  export type productsOrderByWithRelationInput = {
    id?: SortOrder
    code1C?: SortOrder
    marking?: SortOrder
    name?: SortOrderInput | SortOrder
    serieId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    series?: seriesOrderByWithRelationInput
    records?: recordsOrderByRelationAggregateInput
    regulations?: regulationsOrderByRelationAggregateInput
    semi_products?: semi_productsOrderByRelationAggregateInput
  }

  export type productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code1C?: string
    AND?: productsWhereInput | productsWhereInput[]
    OR?: productsWhereInput[]
    NOT?: productsWhereInput | productsWhereInput[]
    marking?: StringFilter<"products"> | string
    name?: StringNullableFilter<"products"> | string | null
    serieId?: IntNullableFilter<"products"> | number | null
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
    series?: XOR<SeriesNullableScalarRelationFilter, seriesWhereInput> | null
    records?: RecordsListRelationFilter
    regulations?: RegulationsListRelationFilter
    semi_products?: Semi_productsListRelationFilter
  }, "id" | "code1C">

  export type productsOrderByWithAggregationInput = {
    id?: SortOrder
    code1C?: SortOrder
    marking?: SortOrder
    name?: SortOrderInput | SortOrder
    serieId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: productsCountOrderByAggregateInput
    _avg?: productsAvgOrderByAggregateInput
    _max?: productsMaxOrderByAggregateInput
    _min?: productsMinOrderByAggregateInput
    _sum?: productsSumOrderByAggregateInput
  }

  export type productsScalarWhereWithAggregatesInput = {
    AND?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    OR?: productsScalarWhereWithAggregatesInput[]
    NOT?: productsScalarWhereWithAggregatesInput | productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"products"> | number
    code1C?: StringWithAggregatesFilter<"products"> | string
    marking?: StringWithAggregatesFilter<"products"> | string
    name?: StringNullableWithAggregatesFilter<"products"> | string | null
    serieId?: IntNullableWithAggregatesFilter<"products"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"products"> | Date | string
  }

  export type record_regulationsWhereInput = {
    AND?: record_regulationsWhereInput | record_regulationsWhereInput[]
    OR?: record_regulationsWhereInput[]
    NOT?: record_regulationsWhereInput | record_regulationsWhereInput[]
    id?: IntFilter<"record_regulations"> | number
    record_id?: IntNullableFilter<"record_regulations"> | number | null
    org_base_min_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableFilter<"record_regulations"> | number | null
    box_per_row?: IntNullableFilter<"record_regulations"> | number | null
    row_on_pallet?: IntNullableFilter<"record_regulations"> | number | null
    gasket?: StringNullableFilter<"record_regulations"> | string | null
    seal?: BoolNullableFilter<"record_regulations"> | boolean | null
    technician_note?: StringNullableFilter<"record_regulations"> | string | null
    packaging_note?: StringNullableFilter<"record_regulations"> | string | null
    marking_sample_id?: IntNullableFilter<"record_regulations"> | number | null
    inc_color?: StringNullableFilter<"record_regulations"> | string | null
    marking_feature?: StringNullableFilter<"record_regulations"> | string | null
    createdAt?: DateTimeFilter<"record_regulations"> | Date | string
    updatedAt?: DateTimeFilter<"record_regulations"> | Date | string
    marking_sample?: XOR<Marking_sampleNullableScalarRelationFilter, marking_sampleWhereInput> | null
    records?: XOR<RecordsNullableScalarRelationFilter, recordsWhereInput> | null
  }

  export type record_regulationsOrderByWithRelationInput = {
    id?: SortOrder
    record_id?: SortOrderInput | SortOrder
    org_base_min_weight?: SortOrderInput | SortOrder
    org_base_max_weight?: SortOrderInput | SortOrder
    water_base_min_weight?: SortOrderInput | SortOrder
    water_base_max_weight?: SortOrderInput | SortOrder
    per_box?: SortOrderInput | SortOrder
    box_per_row?: SortOrderInput | SortOrder
    row_on_pallet?: SortOrderInput | SortOrder
    gasket?: SortOrderInput | SortOrder
    seal?: SortOrderInput | SortOrder
    technician_note?: SortOrderInput | SortOrder
    packaging_note?: SortOrderInput | SortOrder
    marking_sample_id?: SortOrderInput | SortOrder
    inc_color?: SortOrderInput | SortOrder
    marking_feature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marking_sample?: marking_sampleOrderByWithRelationInput
    records?: recordsOrderByWithRelationInput
  }

  export type record_regulationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: record_regulationsWhereInput | record_regulationsWhereInput[]
    OR?: record_regulationsWhereInput[]
    NOT?: record_regulationsWhereInput | record_regulationsWhereInput[]
    record_id?: IntNullableFilter<"record_regulations"> | number | null
    org_base_min_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableFilter<"record_regulations"> | number | null
    box_per_row?: IntNullableFilter<"record_regulations"> | number | null
    row_on_pallet?: IntNullableFilter<"record_regulations"> | number | null
    gasket?: StringNullableFilter<"record_regulations"> | string | null
    seal?: BoolNullableFilter<"record_regulations"> | boolean | null
    technician_note?: StringNullableFilter<"record_regulations"> | string | null
    packaging_note?: StringNullableFilter<"record_regulations"> | string | null
    marking_sample_id?: IntNullableFilter<"record_regulations"> | number | null
    inc_color?: StringNullableFilter<"record_regulations"> | string | null
    marking_feature?: StringNullableFilter<"record_regulations"> | string | null
    createdAt?: DateTimeFilter<"record_regulations"> | Date | string
    updatedAt?: DateTimeFilter<"record_regulations"> | Date | string
    marking_sample?: XOR<Marking_sampleNullableScalarRelationFilter, marking_sampleWhereInput> | null
    records?: XOR<RecordsNullableScalarRelationFilter, recordsWhereInput> | null
  }, "id">

  export type record_regulationsOrderByWithAggregationInput = {
    id?: SortOrder
    record_id?: SortOrderInput | SortOrder
    org_base_min_weight?: SortOrderInput | SortOrder
    org_base_max_weight?: SortOrderInput | SortOrder
    water_base_min_weight?: SortOrderInput | SortOrder
    water_base_max_weight?: SortOrderInput | SortOrder
    per_box?: SortOrderInput | SortOrder
    box_per_row?: SortOrderInput | SortOrder
    row_on_pallet?: SortOrderInput | SortOrder
    gasket?: SortOrderInput | SortOrder
    seal?: SortOrderInput | SortOrder
    technician_note?: SortOrderInput | SortOrder
    packaging_note?: SortOrderInput | SortOrder
    marking_sample_id?: SortOrderInput | SortOrder
    inc_color?: SortOrderInput | SortOrder
    marking_feature?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: record_regulationsCountOrderByAggregateInput
    _avg?: record_regulationsAvgOrderByAggregateInput
    _max?: record_regulationsMaxOrderByAggregateInput
    _min?: record_regulationsMinOrderByAggregateInput
    _sum?: record_regulationsSumOrderByAggregateInput
  }

  export type record_regulationsScalarWhereWithAggregatesInput = {
    AND?: record_regulationsScalarWhereWithAggregatesInput | record_regulationsScalarWhereWithAggregatesInput[]
    OR?: record_regulationsScalarWhereWithAggregatesInput[]
    NOT?: record_regulationsScalarWhereWithAggregatesInput | record_regulationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"record_regulations"> | number
    record_id?: IntNullableWithAggregatesFilter<"record_regulations"> | number | null
    org_base_min_weight?: DecimalNullableWithAggregatesFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: DecimalNullableWithAggregatesFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: DecimalNullableWithAggregatesFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableWithAggregatesFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableWithAggregatesFilter<"record_regulations"> | number | null
    box_per_row?: IntNullableWithAggregatesFilter<"record_regulations"> | number | null
    row_on_pallet?: IntNullableWithAggregatesFilter<"record_regulations"> | number | null
    gasket?: StringNullableWithAggregatesFilter<"record_regulations"> | string | null
    seal?: BoolNullableWithAggregatesFilter<"record_regulations"> | boolean | null
    technician_note?: StringNullableWithAggregatesFilter<"record_regulations"> | string | null
    packaging_note?: StringNullableWithAggregatesFilter<"record_regulations"> | string | null
    marking_sample_id?: IntNullableWithAggregatesFilter<"record_regulations"> | number | null
    inc_color?: StringNullableWithAggregatesFilter<"record_regulations"> | string | null
    marking_feature?: StringNullableWithAggregatesFilter<"record_regulations"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"record_regulations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"record_regulations"> | Date | string
  }

  export type recordsWhereInput = {
    AND?: recordsWhereInput | recordsWhereInput[]
    OR?: recordsWhereInput[]
    NOT?: recordsWhereInput | recordsWhereInput[]
    id?: IntFilter<"records"> | number
    doc_id?: IntNullableFilter<"records"> | number | null
    productId?: IntNullableFilter<"records"> | number | null
    boilId?: IntNullableFilter<"records"> | number | null
    apparatusId?: IntNullableFilter<"records"> | number | null
    canId?: IntNullableFilter<"records"> | number | null
    conveyorId?: IntNullableFilter<"records"> | number | null
    plan?: IntFilter<"records"> | number
    bbf?: StringFilter<"records"> | string
    note?: StringFilter<"records"> | string
    workshopId?: IntNullableFilter<"records"> | number | null
    createdAt?: DateTimeFilter<"records"> | Date | string
    updatedAt?: DateTimeFilter<"records"> | Date | string
    isSet?: BoolNullableFilter<"records"> | boolean | null
    organic_base_id?: IntNullableFilter<"records"> | number | null
    water_base_id?: IntNullableFilter<"records"> | number | null
    dm?: StringFilter<"records"> | string
    histories?: HistoriesListRelationFilter
    record_regulations?: Record_regulationsListRelationFilter
    apparatuses?: XOR<ApparatusesNullableScalarRelationFilter, apparatusesWhereInput> | null
    cans?: XOR<CansNullableScalarRelationFilter, cansWhereInput> | null
    conveyors?: XOR<ConveyorsNullableScalarRelationFilter, conveyorsWhereInput> | null
    docs?: XOR<DocsNullableScalarRelationFilter, docsWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
    workshops?: XOR<WorkshopsNullableScalarRelationFilter, workshopsWhereInput> | null
    boils?: XOR<BoilsNullableScalarRelationFilter, boilsWhereInput> | null
    semi_products?: Semi_productsListRelationFilter
  }

  export type recordsOrderByWithRelationInput = {
    id?: SortOrder
    doc_id?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    boilId?: SortOrderInput | SortOrder
    apparatusId?: SortOrderInput | SortOrder
    canId?: SortOrderInput | SortOrder
    conveyorId?: SortOrderInput | SortOrder
    plan?: SortOrder
    bbf?: SortOrder
    note?: SortOrder
    workshopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSet?: SortOrderInput | SortOrder
    organic_base_id?: SortOrderInput | SortOrder
    water_base_id?: SortOrderInput | SortOrder
    dm?: SortOrder
    histories?: historiesOrderByRelationAggregateInput
    record_regulations?: record_regulationsOrderByRelationAggregateInput
    apparatuses?: apparatusesOrderByWithRelationInput
    cans?: cansOrderByWithRelationInput
    conveyors?: conveyorsOrderByWithRelationInput
    docs?: docsOrderByWithRelationInput
    products?: productsOrderByWithRelationInput
    workshops?: workshopsOrderByWithRelationInput
    boils?: boilsOrderByWithRelationInput
    semi_products?: semi_productsOrderByRelationAggregateInput
  }

  export type recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: recordsWhereInput | recordsWhereInput[]
    OR?: recordsWhereInput[]
    NOT?: recordsWhereInput | recordsWhereInput[]
    doc_id?: IntNullableFilter<"records"> | number | null
    productId?: IntNullableFilter<"records"> | number | null
    boilId?: IntNullableFilter<"records"> | number | null
    apparatusId?: IntNullableFilter<"records"> | number | null
    canId?: IntNullableFilter<"records"> | number | null
    conveyorId?: IntNullableFilter<"records"> | number | null
    plan?: IntFilter<"records"> | number
    bbf?: StringFilter<"records"> | string
    note?: StringFilter<"records"> | string
    workshopId?: IntNullableFilter<"records"> | number | null
    createdAt?: DateTimeFilter<"records"> | Date | string
    updatedAt?: DateTimeFilter<"records"> | Date | string
    isSet?: BoolNullableFilter<"records"> | boolean | null
    organic_base_id?: IntNullableFilter<"records"> | number | null
    water_base_id?: IntNullableFilter<"records"> | number | null
    dm?: StringFilter<"records"> | string
    histories?: HistoriesListRelationFilter
    record_regulations?: Record_regulationsListRelationFilter
    apparatuses?: XOR<ApparatusesNullableScalarRelationFilter, apparatusesWhereInput> | null
    cans?: XOR<CansNullableScalarRelationFilter, cansWhereInput> | null
    conveyors?: XOR<ConveyorsNullableScalarRelationFilter, conveyorsWhereInput> | null
    docs?: XOR<DocsNullableScalarRelationFilter, docsWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
    workshops?: XOR<WorkshopsNullableScalarRelationFilter, workshopsWhereInput> | null
    boils?: XOR<BoilsNullableScalarRelationFilter, boilsWhereInput> | null
    semi_products?: Semi_productsListRelationFilter
  }, "id">

  export type recordsOrderByWithAggregationInput = {
    id?: SortOrder
    doc_id?: SortOrderInput | SortOrder
    productId?: SortOrderInput | SortOrder
    boilId?: SortOrderInput | SortOrder
    apparatusId?: SortOrderInput | SortOrder
    canId?: SortOrderInput | SortOrder
    conveyorId?: SortOrderInput | SortOrder
    plan?: SortOrder
    bbf?: SortOrder
    note?: SortOrder
    workshopId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSet?: SortOrderInput | SortOrder
    organic_base_id?: SortOrderInput | SortOrder
    water_base_id?: SortOrderInput | SortOrder
    dm?: SortOrder
    _count?: recordsCountOrderByAggregateInput
    _avg?: recordsAvgOrderByAggregateInput
    _max?: recordsMaxOrderByAggregateInput
    _min?: recordsMinOrderByAggregateInput
    _sum?: recordsSumOrderByAggregateInput
  }

  export type recordsScalarWhereWithAggregatesInput = {
    AND?: recordsScalarWhereWithAggregatesInput | recordsScalarWhereWithAggregatesInput[]
    OR?: recordsScalarWhereWithAggregatesInput[]
    NOT?: recordsScalarWhereWithAggregatesInput | recordsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"records"> | number
    doc_id?: IntNullableWithAggregatesFilter<"records"> | number | null
    productId?: IntNullableWithAggregatesFilter<"records"> | number | null
    boilId?: IntNullableWithAggregatesFilter<"records"> | number | null
    apparatusId?: IntNullableWithAggregatesFilter<"records"> | number | null
    canId?: IntNullableWithAggregatesFilter<"records"> | number | null
    conveyorId?: IntNullableWithAggregatesFilter<"records"> | number | null
    plan?: IntWithAggregatesFilter<"records"> | number
    bbf?: StringWithAggregatesFilter<"records"> | string
    note?: StringWithAggregatesFilter<"records"> | string
    workshopId?: IntNullableWithAggregatesFilter<"records"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"records"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"records"> | Date | string
    isSet?: BoolNullableWithAggregatesFilter<"records"> | boolean | null
    organic_base_id?: IntNullableWithAggregatesFilter<"records"> | number | null
    water_base_id?: IntNullableWithAggregatesFilter<"records"> | number | null
    dm?: StringWithAggregatesFilter<"records"> | string
  }

  export type regulationsWhereInput = {
    AND?: regulationsWhereInput | regulationsWhereInput[]
    OR?: regulationsWhereInput[]
    NOT?: regulationsWhereInput | regulationsWhereInput[]
    id?: IntFilter<"regulations"> | number
    product_id?: IntNullableFilter<"regulations"> | number | null
    water_base_min_weight?: DecimalNullableFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableFilter<"regulations"> | number | null
    box_per_row?: IntNullableFilter<"regulations"> | number | null
    row_on_pallet?: IntNullableFilter<"regulations"> | number | null
    gasket?: StringNullableFilter<"regulations"> | string | null
    seal?: BoolNullableFilter<"regulations"> | boolean | null
    technician_note?: StringNullableFilter<"regulations"> | string | null
    packaging_note?: StringNullableFilter<"regulations"> | string | null
    marking_sample_id?: IntNullableFilter<"regulations"> | number | null
    createdAt?: DateTimeFilter<"regulations"> | Date | string
    updatedAt?: DateTimeFilter<"regulations"> | Date | string
    marking_sample?: XOR<Marking_sampleNullableScalarRelationFilter, marking_sampleWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
  }

  export type regulationsOrderByWithRelationInput = {
    id?: SortOrder
    product_id?: SortOrderInput | SortOrder
    water_base_min_weight?: SortOrderInput | SortOrder
    water_base_max_weight?: SortOrderInput | SortOrder
    per_box?: SortOrderInput | SortOrder
    box_per_row?: SortOrderInput | SortOrder
    row_on_pallet?: SortOrderInput | SortOrder
    gasket?: SortOrderInput | SortOrder
    seal?: SortOrderInput | SortOrder
    technician_note?: SortOrderInput | SortOrder
    packaging_note?: SortOrderInput | SortOrder
    marking_sample_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    marking_sample?: marking_sampleOrderByWithRelationInput
    products?: productsOrderByWithRelationInput
  }

  export type regulationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: regulationsWhereInput | regulationsWhereInput[]
    OR?: regulationsWhereInput[]
    NOT?: regulationsWhereInput | regulationsWhereInput[]
    product_id?: IntNullableFilter<"regulations"> | number | null
    water_base_min_weight?: DecimalNullableFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableFilter<"regulations"> | number | null
    box_per_row?: IntNullableFilter<"regulations"> | number | null
    row_on_pallet?: IntNullableFilter<"regulations"> | number | null
    gasket?: StringNullableFilter<"regulations"> | string | null
    seal?: BoolNullableFilter<"regulations"> | boolean | null
    technician_note?: StringNullableFilter<"regulations"> | string | null
    packaging_note?: StringNullableFilter<"regulations"> | string | null
    marking_sample_id?: IntNullableFilter<"regulations"> | number | null
    createdAt?: DateTimeFilter<"regulations"> | Date | string
    updatedAt?: DateTimeFilter<"regulations"> | Date | string
    marking_sample?: XOR<Marking_sampleNullableScalarRelationFilter, marking_sampleWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
  }, "id">

  export type regulationsOrderByWithAggregationInput = {
    id?: SortOrder
    product_id?: SortOrderInput | SortOrder
    water_base_min_weight?: SortOrderInput | SortOrder
    water_base_max_weight?: SortOrderInput | SortOrder
    per_box?: SortOrderInput | SortOrder
    box_per_row?: SortOrderInput | SortOrder
    row_on_pallet?: SortOrderInput | SortOrder
    gasket?: SortOrderInput | SortOrder
    seal?: SortOrderInput | SortOrder
    technician_note?: SortOrderInput | SortOrder
    packaging_note?: SortOrderInput | SortOrder
    marking_sample_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: regulationsCountOrderByAggregateInput
    _avg?: regulationsAvgOrderByAggregateInput
    _max?: regulationsMaxOrderByAggregateInput
    _min?: regulationsMinOrderByAggregateInput
    _sum?: regulationsSumOrderByAggregateInput
  }

  export type regulationsScalarWhereWithAggregatesInput = {
    AND?: regulationsScalarWhereWithAggregatesInput | regulationsScalarWhereWithAggregatesInput[]
    OR?: regulationsScalarWhereWithAggregatesInput[]
    NOT?: regulationsScalarWhereWithAggregatesInput | regulationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"regulations"> | number
    product_id?: IntNullableWithAggregatesFilter<"regulations"> | number | null
    water_base_min_weight?: DecimalNullableWithAggregatesFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableWithAggregatesFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableWithAggregatesFilter<"regulations"> | number | null
    box_per_row?: IntNullableWithAggregatesFilter<"regulations"> | number | null
    row_on_pallet?: IntNullableWithAggregatesFilter<"regulations"> | number | null
    gasket?: StringNullableWithAggregatesFilter<"regulations"> | string | null
    seal?: BoolNullableWithAggregatesFilter<"regulations"> | boolean | null
    technician_note?: StringNullableWithAggregatesFilter<"regulations"> | string | null
    packaging_note?: StringNullableWithAggregatesFilter<"regulations"> | string | null
    marking_sample_id?: IntNullableWithAggregatesFilter<"regulations"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"regulations"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"regulations"> | Date | string
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    value?: StringFilter<"roles"> | string
    description?: StringFilter<"roles"> | string
    user_roles?: User_rolesListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    user_roles?: user_rolesOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    description?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    user_roles?: User_rolesListRelationFilter
  }, "id" | "value" | "description">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    value?: StringWithAggregatesFilter<"roles"> | string
    description?: StringWithAggregatesFilter<"roles"> | string
  }

  export type semi_productsWhereInput = {
    AND?: semi_productsWhereInput | semi_productsWhereInput[]
    OR?: semi_productsWhereInput[]
    NOT?: semi_productsWhereInput | semi_productsWhereInput[]
    id?: IntFilter<"semi_products"> | number
    record_id?: IntNullableFilter<"semi_products"> | number | null
    product_id?: IntNullableFilter<"semi_products"> | number | null
    boil_id?: IntNullableFilter<"semi_products"> | number | null
    createdAt?: DateTimeFilter<"semi_products"> | Date | string
    updatedAt?: DateTimeFilter<"semi_products"> | Date | string
    boils?: XOR<BoilsNullableScalarRelationFilter, boilsWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
    records?: XOR<RecordsNullableScalarRelationFilter, recordsWhereInput> | null
  }

  export type semi_productsOrderByWithRelationInput = {
    id?: SortOrder
    record_id?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    boil_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boils?: boilsOrderByWithRelationInput
    products?: productsOrderByWithRelationInput
    records?: recordsOrderByWithRelationInput
  }

  export type semi_productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: semi_productsWhereInput | semi_productsWhereInput[]
    OR?: semi_productsWhereInput[]
    NOT?: semi_productsWhereInput | semi_productsWhereInput[]
    record_id?: IntNullableFilter<"semi_products"> | number | null
    product_id?: IntNullableFilter<"semi_products"> | number | null
    boil_id?: IntNullableFilter<"semi_products"> | number | null
    createdAt?: DateTimeFilter<"semi_products"> | Date | string
    updatedAt?: DateTimeFilter<"semi_products"> | Date | string
    boils?: XOR<BoilsNullableScalarRelationFilter, boilsWhereInput> | null
    products?: XOR<ProductsNullableScalarRelationFilter, productsWhereInput> | null
    records?: XOR<RecordsNullableScalarRelationFilter, recordsWhereInput> | null
  }, "id">

  export type semi_productsOrderByWithAggregationInput = {
    id?: SortOrder
    record_id?: SortOrderInput | SortOrder
    product_id?: SortOrderInput | SortOrder
    boil_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: semi_productsCountOrderByAggregateInput
    _avg?: semi_productsAvgOrderByAggregateInput
    _max?: semi_productsMaxOrderByAggregateInput
    _min?: semi_productsMinOrderByAggregateInput
    _sum?: semi_productsSumOrderByAggregateInput
  }

  export type semi_productsScalarWhereWithAggregatesInput = {
    AND?: semi_productsScalarWhereWithAggregatesInput | semi_productsScalarWhereWithAggregatesInput[]
    OR?: semi_productsScalarWhereWithAggregatesInput[]
    NOT?: semi_productsScalarWhereWithAggregatesInput | semi_productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"semi_products"> | number
    record_id?: IntNullableWithAggregatesFilter<"semi_products"> | number | null
    product_id?: IntNullableWithAggregatesFilter<"semi_products"> | number | null
    boil_id?: IntNullableWithAggregatesFilter<"semi_products"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"semi_products"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"semi_products"> | Date | string
  }

  export type seriesWhereInput = {
    AND?: seriesWhereInput | seriesWhereInput[]
    OR?: seriesWhereInput[]
    NOT?: seriesWhereInput | seriesWhereInput[]
    id?: IntFilter<"series"> | number
    value?: StringFilter<"series"> | string
    products?: ProductsListRelationFilter
  }

  export type seriesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    products?: productsOrderByRelationAggregateInput
  }

  export type seriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: seriesWhereInput | seriesWhereInput[]
    OR?: seriesWhereInput[]
    NOT?: seriesWhereInput | seriesWhereInput[]
    products?: ProductsListRelationFilter
  }, "id" | "value">

  export type seriesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    _count?: seriesCountOrderByAggregateInput
    _avg?: seriesAvgOrderByAggregateInput
    _max?: seriesMaxOrderByAggregateInput
    _min?: seriesMinOrderByAggregateInput
    _sum?: seriesSumOrderByAggregateInput
  }

  export type seriesScalarWhereWithAggregatesInput = {
    AND?: seriesScalarWhereWithAggregatesInput | seriesScalarWhereWithAggregatesInput[]
    OR?: seriesScalarWhereWithAggregatesInput[]
    NOT?: seriesScalarWhereWithAggregatesInput | seriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"series"> | number
    value?: StringWithAggregatesFilter<"series"> | string
  }

  export type signalsWhereInput = {
    AND?: signalsWhereInput | signalsWhereInput[]
    OR?: signalsWhereInput[]
    NOT?: signalsWhereInput | signalsWhereInput[]
    id?: IntFilter<"signals"> | number
    value?: StringFilter<"signals"> | string
  }

  export type signalsOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type signalsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: signalsWhereInput | signalsWhereInput[]
    OR?: signalsWhereInput[]
    NOT?: signalsWhereInput | signalsWhereInput[]
  }, "id" | "value">

  export type signalsOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    _count?: signalsCountOrderByAggregateInput
    _avg?: signalsAvgOrderByAggregateInput
    _max?: signalsMaxOrderByAggregateInput
    _min?: signalsMinOrderByAggregateInput
    _sum?: signalsSumOrderByAggregateInput
  }

  export type signalsScalarWhereWithAggregatesInput = {
    AND?: signalsScalarWhereWithAggregatesInput | signalsScalarWhereWithAggregatesInput[]
    OR?: signalsScalarWhereWithAggregatesInput[]
    NOT?: signalsScalarWhereWithAggregatesInput | signalsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"signals"> | number
    value?: StringWithAggregatesFilter<"signals"> | string
  }

  export type tokensWhereInput = {
    AND?: tokensWhereInput | tokensWhereInput[]
    OR?: tokensWhereInput[]
    NOT?: tokensWhereInput | tokensWhereInput[]
    id?: IntFilter<"tokens"> | number
    userId?: IntNullableFilter<"tokens"> | number | null
    token?: StringFilter<"tokens"> | string
    createdAt?: DateTimeFilter<"tokens"> | Date | string
    updatedAt?: DateTimeFilter<"tokens"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }

  export type tokensOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type tokensWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: tokensWhereInput | tokensWhereInput[]
    OR?: tokensWhereInput[]
    NOT?: tokensWhereInput | tokensWhereInput[]
    userId?: IntNullableFilter<"tokens"> | number | null
    createdAt?: DateTimeFilter<"tokens"> | Date | string
    updatedAt?: DateTimeFilter<"tokens"> | Date | string
    users?: XOR<UsersNullableScalarRelationFilter, usersWhereInput> | null
  }, "id" | "token">

  export type tokensOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tokensCountOrderByAggregateInput
    _avg?: tokensAvgOrderByAggregateInput
    _max?: tokensMaxOrderByAggregateInput
    _min?: tokensMinOrderByAggregateInput
    _sum?: tokensSumOrderByAggregateInput
  }

  export type tokensScalarWhereWithAggregatesInput = {
    AND?: tokensScalarWhereWithAggregatesInput | tokensScalarWhereWithAggregatesInput[]
    OR?: tokensScalarWhereWithAggregatesInput[]
    NOT?: tokensScalarWhereWithAggregatesInput | tokensScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tokens"> | number
    userId?: IntNullableWithAggregatesFilter<"tokens"> | number | null
    token?: StringWithAggregatesFilter<"tokens"> | string
    createdAt?: DateTimeWithAggregatesFilter<"tokens"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tokens"> | Date | string
  }

  export type tube_assemblyWhereInput = {
    AND?: tube_assemblyWhereInput | tube_assemblyWhereInput[]
    OR?: tube_assemblyWhereInput[]
    NOT?: tube_assemblyWhereInput | tube_assemblyWhereInput[]
    id?: IntFilter<"tube_assembly"> | number
    tube_record_id?: IntNullableFilter<"tube_assembly"> | number | null
    tube_material_id?: IntNullableFilter<"tube_assembly"> | number | null
    tube_conveyor_post_id?: IntNullableFilter<"tube_assembly"> | number | null
    createdAt?: DateTimeFilter<"tube_assembly"> | Date | string
    updatedAt?: DateTimeFilter<"tube_assembly"> | Date | string
    tube_conveyor_posts?: XOR<Tube_conveyor_postsNullableScalarRelationFilter, tube_conveyor_postsWhereInput> | null
    tube_materials?: XOR<Tube_materialsNullableScalarRelationFilter, tube_materialsWhereInput> | null
  }

  export type tube_assemblyOrderByWithRelationInput = {
    id?: SortOrder
    tube_record_id?: SortOrderInput | SortOrder
    tube_material_id?: SortOrderInput | SortOrder
    tube_conveyor_post_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tube_conveyor_posts?: tube_conveyor_postsOrderByWithRelationInput
    tube_materials?: tube_materialsOrderByWithRelationInput
  }

  export type tube_assemblyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tube_assemblyWhereInput | tube_assemblyWhereInput[]
    OR?: tube_assemblyWhereInput[]
    NOT?: tube_assemblyWhereInput | tube_assemblyWhereInput[]
    tube_record_id?: IntNullableFilter<"tube_assembly"> | number | null
    tube_material_id?: IntNullableFilter<"tube_assembly"> | number | null
    tube_conveyor_post_id?: IntNullableFilter<"tube_assembly"> | number | null
    createdAt?: DateTimeFilter<"tube_assembly"> | Date | string
    updatedAt?: DateTimeFilter<"tube_assembly"> | Date | string
    tube_conveyor_posts?: XOR<Tube_conveyor_postsNullableScalarRelationFilter, tube_conveyor_postsWhereInput> | null
    tube_materials?: XOR<Tube_materialsNullableScalarRelationFilter, tube_materialsWhereInput> | null
  }, "id">

  export type tube_assemblyOrderByWithAggregationInput = {
    id?: SortOrder
    tube_record_id?: SortOrderInput | SortOrder
    tube_material_id?: SortOrderInput | SortOrder
    tube_conveyor_post_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tube_assemblyCountOrderByAggregateInput
    _avg?: tube_assemblyAvgOrderByAggregateInput
    _max?: tube_assemblyMaxOrderByAggregateInput
    _min?: tube_assemblyMinOrderByAggregateInput
    _sum?: tube_assemblySumOrderByAggregateInput
  }

  export type tube_assemblyScalarWhereWithAggregatesInput = {
    AND?: tube_assemblyScalarWhereWithAggregatesInput | tube_assemblyScalarWhereWithAggregatesInput[]
    OR?: tube_assemblyScalarWhereWithAggregatesInput[]
    NOT?: tube_assemblyScalarWhereWithAggregatesInput | tube_assemblyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_assembly"> | number
    tube_record_id?: IntNullableWithAggregatesFilter<"tube_assembly"> | number | null
    tube_material_id?: IntNullableWithAggregatesFilter<"tube_assembly"> | number | null
    tube_conveyor_post_id?: IntNullableWithAggregatesFilter<"tube_assembly"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"tube_assembly"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tube_assembly"> | Date | string
  }

  export type tube_conveyor_postsWhereInput = {
    AND?: tube_conveyor_postsWhereInput | tube_conveyor_postsWhereInput[]
    OR?: tube_conveyor_postsWhereInput[]
    NOT?: tube_conveyor_postsWhereInput | tube_conveyor_postsWhereInput[]
    id?: IntFilter<"tube_conveyor_posts"> | number
    name?: StringFilter<"tube_conveyor_posts"> | string
    tube_assembly?: Tube_assemblyListRelationFilter
  }

  export type tube_conveyor_postsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    tube_assembly?: tube_assemblyOrderByRelationAggregateInput
  }

  export type tube_conveyor_postsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    AND?: tube_conveyor_postsWhereInput | tube_conveyor_postsWhereInput[]
    OR?: tube_conveyor_postsWhereInput[]
    NOT?: tube_conveyor_postsWhereInput | tube_conveyor_postsWhereInput[]
    tube_assembly?: Tube_assemblyListRelationFilter
  }, "id" | "name">

  export type tube_conveyor_postsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: tube_conveyor_postsCountOrderByAggregateInput
    _avg?: tube_conveyor_postsAvgOrderByAggregateInput
    _max?: tube_conveyor_postsMaxOrderByAggregateInput
    _min?: tube_conveyor_postsMinOrderByAggregateInput
    _sum?: tube_conveyor_postsSumOrderByAggregateInput
  }

  export type tube_conveyor_postsScalarWhereWithAggregatesInput = {
    AND?: tube_conveyor_postsScalarWhereWithAggregatesInput | tube_conveyor_postsScalarWhereWithAggregatesInput[]
    OR?: tube_conveyor_postsScalarWhereWithAggregatesInput[]
    NOT?: tube_conveyor_postsScalarWhereWithAggregatesInput | tube_conveyor_postsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_conveyor_posts"> | number
    name?: StringWithAggregatesFilter<"tube_conveyor_posts"> | string
  }

  export type tube_conveyorsWhereInput = {
    AND?: tube_conveyorsWhereInput | tube_conveyorsWhereInput[]
    OR?: tube_conveyorsWhereInput[]
    NOT?: tube_conveyorsWhereInput | tube_conveyorsWhereInput[]
    id?: IntFilter<"tube_conveyors"> | number
    name?: StringNullableFilter<"tube_conveyors"> | string | null
    barcode?: StringNullableFilter<"tube_conveyors"> | string | null
    tube_records?: Tube_recordsListRelationFilter
    tube_sessions?: Tube_sessionsListRelationFilter
  }

  export type tube_conveyorsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    tube_records?: tube_recordsOrderByRelationAggregateInput
    tube_sessions?: tube_sessionsOrderByRelationAggregateInput
  }

  export type tube_conveyorsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    barcode?: string
    AND?: tube_conveyorsWhereInput | tube_conveyorsWhereInput[]
    OR?: tube_conveyorsWhereInput[]
    NOT?: tube_conveyorsWhereInput | tube_conveyorsWhereInput[]
    name?: StringNullableFilter<"tube_conveyors"> | string | null
    tube_records?: Tube_recordsListRelationFilter
    tube_sessions?: Tube_sessionsListRelationFilter
  }, "id" | "barcode">

  export type tube_conveyorsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    barcode?: SortOrderInput | SortOrder
    _count?: tube_conveyorsCountOrderByAggregateInput
    _avg?: tube_conveyorsAvgOrderByAggregateInput
    _max?: tube_conveyorsMaxOrderByAggregateInput
    _min?: tube_conveyorsMinOrderByAggregateInput
    _sum?: tube_conveyorsSumOrderByAggregateInput
  }

  export type tube_conveyorsScalarWhereWithAggregatesInput = {
    AND?: tube_conveyorsScalarWhereWithAggregatesInput | tube_conveyorsScalarWhereWithAggregatesInput[]
    OR?: tube_conveyorsScalarWhereWithAggregatesInput[]
    NOT?: tube_conveyorsScalarWhereWithAggregatesInput | tube_conveyorsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_conveyors"> | number
    name?: StringNullableWithAggregatesFilter<"tube_conveyors"> | string | null
    barcode?: StringNullableWithAggregatesFilter<"tube_conveyors"> | string | null
  }

  export type tube_historiesWhereInput = {
    AND?: tube_historiesWhereInput | tube_historiesWhereInput[]
    OR?: tube_historiesWhereInput[]
    NOT?: tube_historiesWhereInput | tube_historiesWhereInput[]
    id?: IntFilter<"tube_histories"> | number
    tube_record_id?: IntNullableFilter<"tube_histories"> | number | null
    tube_history_type_id?: IntNullableFilter<"tube_histories"> | number | null
    employee_id?: IntNullableFilter<"tube_histories"> | number | null
    note?: StringNullableFilter<"tube_histories"> | string | null
    tube_history_note_id?: IntNullableFilter<"tube_histories"> | number | null
    createdAt?: DateTimeFilter<"tube_histories"> | Date | string
    updatedAt?: DateTimeFilter<"tube_histories"> | Date | string
    employees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
    tube_histories_notes?: XOR<Tube_histories_notesNullableScalarRelationFilter, tube_histories_notesWhereInput> | null
    tube_history_types?: XOR<Tube_history_typesNullableScalarRelationFilter, tube_history_typesWhereInput> | null
  }

  export type tube_historiesOrderByWithRelationInput = {
    id?: SortOrder
    tube_record_id?: SortOrderInput | SortOrder
    tube_history_type_id?: SortOrderInput | SortOrder
    employee_id?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    tube_history_note_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employees?: employeesOrderByWithRelationInput
    tube_histories_notes?: tube_histories_notesOrderByWithRelationInput
    tube_history_types?: tube_history_typesOrderByWithRelationInput
  }

  export type tube_historiesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tube_historiesWhereInput | tube_historiesWhereInput[]
    OR?: tube_historiesWhereInput[]
    NOT?: tube_historiesWhereInput | tube_historiesWhereInput[]
    tube_record_id?: IntNullableFilter<"tube_histories"> | number | null
    tube_history_type_id?: IntNullableFilter<"tube_histories"> | number | null
    employee_id?: IntNullableFilter<"tube_histories"> | number | null
    note?: StringNullableFilter<"tube_histories"> | string | null
    tube_history_note_id?: IntNullableFilter<"tube_histories"> | number | null
    createdAt?: DateTimeFilter<"tube_histories"> | Date | string
    updatedAt?: DateTimeFilter<"tube_histories"> | Date | string
    employees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
    tube_histories_notes?: XOR<Tube_histories_notesNullableScalarRelationFilter, tube_histories_notesWhereInput> | null
    tube_history_types?: XOR<Tube_history_typesNullableScalarRelationFilter, tube_history_typesWhereInput> | null
  }, "id">

  export type tube_historiesOrderByWithAggregationInput = {
    id?: SortOrder
    tube_record_id?: SortOrderInput | SortOrder
    tube_history_type_id?: SortOrderInput | SortOrder
    employee_id?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    tube_history_note_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tube_historiesCountOrderByAggregateInput
    _avg?: tube_historiesAvgOrderByAggregateInput
    _max?: tube_historiesMaxOrderByAggregateInput
    _min?: tube_historiesMinOrderByAggregateInput
    _sum?: tube_historiesSumOrderByAggregateInput
  }

  export type tube_historiesScalarWhereWithAggregatesInput = {
    AND?: tube_historiesScalarWhereWithAggregatesInput | tube_historiesScalarWhereWithAggregatesInput[]
    OR?: tube_historiesScalarWhereWithAggregatesInput[]
    NOT?: tube_historiesScalarWhereWithAggregatesInput | tube_historiesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_histories"> | number
    tube_record_id?: IntNullableWithAggregatesFilter<"tube_histories"> | number | null
    tube_history_type_id?: IntNullableWithAggregatesFilter<"tube_histories"> | number | null
    employee_id?: IntNullableWithAggregatesFilter<"tube_histories"> | number | null
    note?: StringNullableWithAggregatesFilter<"tube_histories"> | string | null
    tube_history_note_id?: IntNullableWithAggregatesFilter<"tube_histories"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"tube_histories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tube_histories"> | Date | string
  }

  export type tube_histories_notesWhereInput = {
    AND?: tube_histories_notesWhereInput | tube_histories_notesWhereInput[]
    OR?: tube_histories_notesWhereInput[]
    NOT?: tube_histories_notesWhereInput | tube_histories_notesWhereInput[]
    id?: IntFilter<"tube_histories_notes"> | number
    value?: StringNullableFilter<"tube_histories_notes"> | string | null
    tube_histories?: Tube_historiesListRelationFilter
  }

  export type tube_histories_notesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    tube_histories?: tube_historiesOrderByRelationAggregateInput
  }

  export type tube_histories_notesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tube_histories_notesWhereInput | tube_histories_notesWhereInput[]
    OR?: tube_histories_notesWhereInput[]
    NOT?: tube_histories_notesWhereInput | tube_histories_notesWhereInput[]
    value?: StringNullableFilter<"tube_histories_notes"> | string | null
    tube_histories?: Tube_historiesListRelationFilter
  }, "id">

  export type tube_histories_notesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrderInput | SortOrder
    _count?: tube_histories_notesCountOrderByAggregateInput
    _avg?: tube_histories_notesAvgOrderByAggregateInput
    _max?: tube_histories_notesMaxOrderByAggregateInput
    _min?: tube_histories_notesMinOrderByAggregateInput
    _sum?: tube_histories_notesSumOrderByAggregateInput
  }

  export type tube_histories_notesScalarWhereWithAggregatesInput = {
    AND?: tube_histories_notesScalarWhereWithAggregatesInput | tube_histories_notesScalarWhereWithAggregatesInput[]
    OR?: tube_histories_notesScalarWhereWithAggregatesInput[]
    NOT?: tube_histories_notesScalarWhereWithAggregatesInput | tube_histories_notesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_histories_notes"> | number
    value?: StringNullableWithAggregatesFilter<"tube_histories_notes"> | string | null
  }

  export type tube_history_typesWhereInput = {
    AND?: tube_history_typesWhereInput | tube_history_typesWhereInput[]
    OR?: tube_history_typesWhereInput[]
    NOT?: tube_history_typesWhereInput | tube_history_typesWhereInput[]
    id?: IntFilter<"tube_history_types"> | number
    value?: StringFilter<"tube_history_types"> | string
    description?: StringFilter<"tube_history_types"> | string
    tube_histories?: Tube_historiesListRelationFilter
  }

  export type tube_history_typesOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    tube_histories?: tube_historiesOrderByRelationAggregateInput
  }

  export type tube_history_typesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    description?: string
    AND?: tube_history_typesWhereInput | tube_history_typesWhereInput[]
    OR?: tube_history_typesWhereInput[]
    NOT?: tube_history_typesWhereInput | tube_history_typesWhereInput[]
    tube_histories?: Tube_historiesListRelationFilter
  }, "id" | "value" | "description">

  export type tube_history_typesOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    _count?: tube_history_typesCountOrderByAggregateInput
    _avg?: tube_history_typesAvgOrderByAggregateInput
    _max?: tube_history_typesMaxOrderByAggregateInput
    _min?: tube_history_typesMinOrderByAggregateInput
    _sum?: tube_history_typesSumOrderByAggregateInput
  }

  export type tube_history_typesScalarWhereWithAggregatesInput = {
    AND?: tube_history_typesScalarWhereWithAggregatesInput | tube_history_typesScalarWhereWithAggregatesInput[]
    OR?: tube_history_typesScalarWhereWithAggregatesInput[]
    NOT?: tube_history_typesScalarWhereWithAggregatesInput | tube_history_typesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_history_types"> | number
    value?: StringWithAggregatesFilter<"tube_history_types"> | string
    description?: StringWithAggregatesFilter<"tube_history_types"> | string
  }

  export type tube_materialsWhereInput = {
    AND?: tube_materialsWhereInput | tube_materialsWhereInput[]
    OR?: tube_materialsWhereInput[]
    NOT?: tube_materialsWhereInput | tube_materialsWhereInput[]
    id?: IntFilter<"tube_materials"> | number
    code_1C?: StringNullableFilter<"tube_materials"> | string | null
    name?: StringNullableFilter<"tube_materials"> | string | null
    tube_assembly?: Tube_assemblyListRelationFilter
    tube_specifications?: Tube_specificationsListRelationFilter
  }

  export type tube_materialsOrderByWithRelationInput = {
    id?: SortOrder
    code_1C?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    tube_assembly?: tube_assemblyOrderByRelationAggregateInput
    tube_specifications?: tube_specificationsOrderByRelationAggregateInput
  }

  export type tube_materialsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code_1C?: string
    AND?: tube_materialsWhereInput | tube_materialsWhereInput[]
    OR?: tube_materialsWhereInput[]
    NOT?: tube_materialsWhereInput | tube_materialsWhereInput[]
    name?: StringNullableFilter<"tube_materials"> | string | null
    tube_assembly?: Tube_assemblyListRelationFilter
    tube_specifications?: Tube_specificationsListRelationFilter
  }, "id" | "code_1C">

  export type tube_materialsOrderByWithAggregationInput = {
    id?: SortOrder
    code_1C?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    _count?: tube_materialsCountOrderByAggregateInput
    _avg?: tube_materialsAvgOrderByAggregateInput
    _max?: tube_materialsMaxOrderByAggregateInput
    _min?: tube_materialsMinOrderByAggregateInput
    _sum?: tube_materialsSumOrderByAggregateInput
  }

  export type tube_materialsScalarWhereWithAggregatesInput = {
    AND?: tube_materialsScalarWhereWithAggregatesInput | tube_materialsScalarWhereWithAggregatesInput[]
    OR?: tube_materialsScalarWhereWithAggregatesInput[]
    NOT?: tube_materialsScalarWhereWithAggregatesInput | tube_materialsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_materials"> | number
    code_1C?: StringNullableWithAggregatesFilter<"tube_materials"> | string | null
    name?: StringNullableWithAggregatesFilter<"tube_materials"> | string | null
  }

  export type tube_parametersWhereInput = {
    AND?: tube_parametersWhereInput | tube_parametersWhereInput[]
    OR?: tube_parametersWhereInput[]
    NOT?: tube_parametersWhereInput | tube_parametersWhereInput[]
    id?: IntFilter<"tube_parameters"> | number
    tube_record_id?: IntNullableFilter<"tube_parameters"> | number | null
    press_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    press_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    molding_time_min?: IntNullableFilter<"tube_parameters"> | number | null
    molding_time_max?: IntNullableFilter<"tube_parameters"> | number | null
    turning_automate_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    turning_automate_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    annealing_furnace_temp_min?: IntNullableFilter<"tube_parameters"> | number | null
    annealing_furnace_temp_max?: IntNullableFilter<"tube_parameters"> | number | null
    cap_machine_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    cap_machine_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    cap_machine_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    cap_machine_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    grips_forward_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_forward_max?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_left_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_left_max?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_right_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_right_max?: IntNullableFilter<"tube_parameters"> | number | null
    grips_closing_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_closing_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_start_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_start_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_end_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_end_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_end_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_end_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    padding_machine_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    padding_machine_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    padding_machine_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    padding_machine_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    padding_furnace_temp_min?: IntNullableFilter<"tube_parameters"> | number | null
    padding_furnace_temp_max?: IntNullableFilter<"tube_parameters"> | number | null
    offset_furnace_temp_min?: IntNullableFilter<"tube_parameters"> | number | null
    offset_furnace_temp_max?: IntNullableFilter<"tube_parameters"> | number | null
    printer_motor_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    printer_motor_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    holders_motor_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    holders_motor_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    station_motor_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    station_motor_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    ink_injection_time_min?: FloatNullableFilter<"tube_parameters"> | number | null
    ink_injection_time_max?: FloatNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    feed_can_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    feed_can_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    nozzle_regulator_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    nozzle_regulator_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    cells_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    cells_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_AB_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_AB_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_CD_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_CD_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_ABCD_end_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_ABCD_end_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_end_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_end_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    polimerization_furnace_temperature_min?: IntNullableFilter<"tube_parameters"> | number | null
    polimerization_furnace_temperature_max?: IntNullableFilter<"tube_parameters"> | number | null
  }

  export type tube_parametersOrderByWithRelationInput = {
    id?: SortOrder
    tube_record_id?: SortOrderInput | SortOrder
    press_speed_min?: SortOrderInput | SortOrder
    press_speed_max?: SortOrderInput | SortOrder
    molding_time_min?: SortOrderInput | SortOrder
    molding_time_max?: SortOrderInput | SortOrder
    turning_automate_speed_min?: SortOrderInput | SortOrder
    turning_automate_speed_max?: SortOrderInput | SortOrder
    annealing_furnace_temp_min?: SortOrderInput | SortOrder
    annealing_furnace_temp_max?: SortOrderInput | SortOrder
    cap_machine_speed_min?: SortOrderInput | SortOrder
    cap_machine_speed_max?: SortOrderInput | SortOrder
    cap_machine_air_pressure_min?: SortOrderInput | SortOrder
    cap_machine_air_pressure_max?: SortOrderInput | SortOrder
    grips_forward_min?: SortOrderInput | SortOrder
    grips_forward_max?: SortOrderInput | SortOrder
    grips_opening_left_min?: SortOrderInput | SortOrder
    grips_opening_left_max?: SortOrderInput | SortOrder
    grips_opening_right_min?: SortOrderInput | SortOrder
    grips_opening_right_max?: SortOrderInput | SortOrder
    grips_closing_min?: SortOrderInput | SortOrder
    grips_closing_max?: SortOrderInput | SortOrder
    injection_start_min?: SortOrderInput | SortOrder
    injection_start_max?: SortOrderInput | SortOrder
    injection_end_min?: SortOrderInput | SortOrder
    injection_end_max?: SortOrderInput | SortOrder
    tube_start_position_min?: SortOrderInput | SortOrder
    tube_start_position_max?: SortOrderInput | SortOrder
    tube_end_position_min?: SortOrderInput | SortOrder
    tube_end_position_max?: SortOrderInput | SortOrder
    padding_machine_speed_min?: SortOrderInput | SortOrder
    padding_machine_speed_max?: SortOrderInput | SortOrder
    padding_machine_air_pressure_min?: SortOrderInput | SortOrder
    padding_machine_air_pressure_max?: SortOrderInput | SortOrder
    padding_furnace_temp_min?: SortOrderInput | SortOrder
    padding_furnace_temp_max?: SortOrderInput | SortOrder
    offset_furnace_temp_min?: SortOrderInput | SortOrder
    offset_furnace_temp_max?: SortOrderInput | SortOrder
    printer_motor_speed_min?: SortOrderInput | SortOrder
    printer_motor_speed_max?: SortOrderInput | SortOrder
    holders_motor_speed_min?: SortOrderInput | SortOrder
    holders_motor_speed_max?: SortOrderInput | SortOrder
    station_motor_speed_min?: SortOrderInput | SortOrder
    station_motor_speed_max?: SortOrderInput | SortOrder
    ink_injection_time_min?: SortOrderInput | SortOrder
    ink_injection_time_max?: SortOrderInput | SortOrder
    lacquer_machine_speed_min?: SortOrderInput | SortOrder
    lacquer_machine_speed_max?: SortOrderInput | SortOrder
    lacquer_machine_air_pressure_min?: SortOrderInput | SortOrder
    lacquer_machine_air_pressure_max?: SortOrderInput | SortOrder
    feed_can_air_pressure_min?: SortOrderInput | SortOrder
    feed_can_air_pressure_max?: SortOrderInput | SortOrder
    nozzle_regulator_air_pressure_min?: SortOrderInput | SortOrder
    nozzle_regulator_air_pressure_max?: SortOrderInput | SortOrder
    cells_speed_min?: SortOrderInput | SortOrder
    cells_speed_max?: SortOrderInput | SortOrder
    injection_AB_start_position_min?: SortOrderInput | SortOrder
    injection_AB_start_position_max?: SortOrderInput | SortOrder
    injection_CD_start_position_min?: SortOrderInput | SortOrder
    injection_CD_start_position_max?: SortOrderInput | SortOrder
    injection_ABCD_end_position_min?: SortOrderInput | SortOrder
    injection_ABCD_end_position_max?: SortOrderInput | SortOrder
    tube_molding_start_position_min?: SortOrderInput | SortOrder
    tube_molding_start_position_max?: SortOrderInput | SortOrder
    tube_molding_end_position_min?: SortOrderInput | SortOrder
    tube_molding_end_position_max?: SortOrderInput | SortOrder
    polimerization_furnace_temperature_min?: SortOrderInput | SortOrder
    polimerization_furnace_temperature_max?: SortOrderInput | SortOrder
  }

  export type tube_parametersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tube_parametersWhereInput | tube_parametersWhereInput[]
    OR?: tube_parametersWhereInput[]
    NOT?: tube_parametersWhereInput | tube_parametersWhereInput[]
    tube_record_id?: IntNullableFilter<"tube_parameters"> | number | null
    press_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    press_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    molding_time_min?: IntNullableFilter<"tube_parameters"> | number | null
    molding_time_max?: IntNullableFilter<"tube_parameters"> | number | null
    turning_automate_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    turning_automate_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    annealing_furnace_temp_min?: IntNullableFilter<"tube_parameters"> | number | null
    annealing_furnace_temp_max?: IntNullableFilter<"tube_parameters"> | number | null
    cap_machine_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    cap_machine_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    cap_machine_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    cap_machine_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    grips_forward_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_forward_max?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_left_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_left_max?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_right_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_opening_right_max?: IntNullableFilter<"tube_parameters"> | number | null
    grips_closing_min?: IntNullableFilter<"tube_parameters"> | number | null
    grips_closing_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_start_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_start_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_end_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_end_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_end_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_end_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    padding_machine_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    padding_machine_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    padding_machine_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    padding_machine_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    padding_furnace_temp_min?: IntNullableFilter<"tube_parameters"> | number | null
    padding_furnace_temp_max?: IntNullableFilter<"tube_parameters"> | number | null
    offset_furnace_temp_min?: IntNullableFilter<"tube_parameters"> | number | null
    offset_furnace_temp_max?: IntNullableFilter<"tube_parameters"> | number | null
    printer_motor_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    printer_motor_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    holders_motor_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    holders_motor_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    station_motor_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    station_motor_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    ink_injection_time_min?: FloatNullableFilter<"tube_parameters"> | number | null
    ink_injection_time_max?: FloatNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    lacquer_machine_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    feed_can_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    feed_can_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    nozzle_regulator_air_pressure_min?: FloatNullableFilter<"tube_parameters"> | number | null
    nozzle_regulator_air_pressure_max?: FloatNullableFilter<"tube_parameters"> | number | null
    cells_speed_min?: IntNullableFilter<"tube_parameters"> | number | null
    cells_speed_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_AB_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_AB_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_CD_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_CD_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    injection_ABCD_end_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    injection_ABCD_end_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_start_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_start_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_end_position_min?: IntNullableFilter<"tube_parameters"> | number | null
    tube_molding_end_position_max?: IntNullableFilter<"tube_parameters"> | number | null
    polimerization_furnace_temperature_min?: IntNullableFilter<"tube_parameters"> | number | null
    polimerization_furnace_temperature_max?: IntNullableFilter<"tube_parameters"> | number | null
  }, "id">

  export type tube_parametersOrderByWithAggregationInput = {
    id?: SortOrder
    tube_record_id?: SortOrderInput | SortOrder
    press_speed_min?: SortOrderInput | SortOrder
    press_speed_max?: SortOrderInput | SortOrder
    molding_time_min?: SortOrderInput | SortOrder
    molding_time_max?: SortOrderInput | SortOrder
    turning_automate_speed_min?: SortOrderInput | SortOrder
    turning_automate_speed_max?: SortOrderInput | SortOrder
    annealing_furnace_temp_min?: SortOrderInput | SortOrder
    annealing_furnace_temp_max?: SortOrderInput | SortOrder
    cap_machine_speed_min?: SortOrderInput | SortOrder
    cap_machine_speed_max?: SortOrderInput | SortOrder
    cap_machine_air_pressure_min?: SortOrderInput | SortOrder
    cap_machine_air_pressure_max?: SortOrderInput | SortOrder
    grips_forward_min?: SortOrderInput | SortOrder
    grips_forward_max?: SortOrderInput | SortOrder
    grips_opening_left_min?: SortOrderInput | SortOrder
    grips_opening_left_max?: SortOrderInput | SortOrder
    grips_opening_right_min?: SortOrderInput | SortOrder
    grips_opening_right_max?: SortOrderInput | SortOrder
    grips_closing_min?: SortOrderInput | SortOrder
    grips_closing_max?: SortOrderInput | SortOrder
    injection_start_min?: SortOrderInput | SortOrder
    injection_start_max?: SortOrderInput | SortOrder
    injection_end_min?: SortOrderInput | SortOrder
    injection_end_max?: SortOrderInput | SortOrder
    tube_start_position_min?: SortOrderInput | SortOrder
    tube_start_position_max?: SortOrderInput | SortOrder
    tube_end_position_min?: SortOrderInput | SortOrder
    tube_end_position_max?: SortOrderInput | SortOrder
    padding_machine_speed_min?: SortOrderInput | SortOrder
    padding_machine_speed_max?: SortOrderInput | SortOrder
    padding_machine_air_pressure_min?: SortOrderInput | SortOrder
    padding_machine_air_pressure_max?: SortOrderInput | SortOrder
    padding_furnace_temp_min?: SortOrderInput | SortOrder
    padding_furnace_temp_max?: SortOrderInput | SortOrder
    offset_furnace_temp_min?: SortOrderInput | SortOrder
    offset_furnace_temp_max?: SortOrderInput | SortOrder
    printer_motor_speed_min?: SortOrderInput | SortOrder
    printer_motor_speed_max?: SortOrderInput | SortOrder
    holders_motor_speed_min?: SortOrderInput | SortOrder
    holders_motor_speed_max?: SortOrderInput | SortOrder
    station_motor_speed_min?: SortOrderInput | SortOrder
    station_motor_speed_max?: SortOrderInput | SortOrder
    ink_injection_time_min?: SortOrderInput | SortOrder
    ink_injection_time_max?: SortOrderInput | SortOrder
    lacquer_machine_speed_min?: SortOrderInput | SortOrder
    lacquer_machine_speed_max?: SortOrderInput | SortOrder
    lacquer_machine_air_pressure_min?: SortOrderInput | SortOrder
    lacquer_machine_air_pressure_max?: SortOrderInput | SortOrder
    feed_can_air_pressure_min?: SortOrderInput | SortOrder
    feed_can_air_pressure_max?: SortOrderInput | SortOrder
    nozzle_regulator_air_pressure_min?: SortOrderInput | SortOrder
    nozzle_regulator_air_pressure_max?: SortOrderInput | SortOrder
    cells_speed_min?: SortOrderInput | SortOrder
    cells_speed_max?: SortOrderInput | SortOrder
    injection_AB_start_position_min?: SortOrderInput | SortOrder
    injection_AB_start_position_max?: SortOrderInput | SortOrder
    injection_CD_start_position_min?: SortOrderInput | SortOrder
    injection_CD_start_position_max?: SortOrderInput | SortOrder
    injection_ABCD_end_position_min?: SortOrderInput | SortOrder
    injection_ABCD_end_position_max?: SortOrderInput | SortOrder
    tube_molding_start_position_min?: SortOrderInput | SortOrder
    tube_molding_start_position_max?: SortOrderInput | SortOrder
    tube_molding_end_position_min?: SortOrderInput | SortOrder
    tube_molding_end_position_max?: SortOrderInput | SortOrder
    polimerization_furnace_temperature_min?: SortOrderInput | SortOrder
    polimerization_furnace_temperature_max?: SortOrderInput | SortOrder
    _count?: tube_parametersCountOrderByAggregateInput
    _avg?: tube_parametersAvgOrderByAggregateInput
    _max?: tube_parametersMaxOrderByAggregateInput
    _min?: tube_parametersMinOrderByAggregateInput
    _sum?: tube_parametersSumOrderByAggregateInput
  }

  export type tube_parametersScalarWhereWithAggregatesInput = {
    AND?: tube_parametersScalarWhereWithAggregatesInput | tube_parametersScalarWhereWithAggregatesInput[]
    OR?: tube_parametersScalarWhereWithAggregatesInput[]
    NOT?: tube_parametersScalarWhereWithAggregatesInput | tube_parametersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_parameters"> | number
    tube_record_id?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    press_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    press_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    molding_time_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    molding_time_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    turning_automate_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    turning_automate_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    annealing_furnace_temp_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    annealing_furnace_temp_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    cap_machine_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    cap_machine_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    cap_machine_air_pressure_min?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    cap_machine_air_pressure_max?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_forward_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_forward_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_opening_left_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_opening_left_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_opening_right_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_opening_right_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_closing_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    grips_closing_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_start_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_start_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_end_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_end_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_start_position_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_start_position_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_end_position_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_end_position_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    padding_machine_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    padding_machine_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    padding_machine_air_pressure_min?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    padding_machine_air_pressure_max?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    padding_furnace_temp_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    padding_furnace_temp_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    offset_furnace_temp_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    offset_furnace_temp_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    printer_motor_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    printer_motor_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    holders_motor_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    holders_motor_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    station_motor_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    station_motor_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    ink_injection_time_min?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    ink_injection_time_max?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    lacquer_machine_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    lacquer_machine_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    lacquer_machine_air_pressure_min?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    lacquer_machine_air_pressure_max?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    feed_can_air_pressure_min?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    feed_can_air_pressure_max?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    nozzle_regulator_air_pressure_min?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    nozzle_regulator_air_pressure_max?: FloatNullableWithAggregatesFilter<"tube_parameters"> | number | null
    cells_speed_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    cells_speed_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_AB_start_position_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_AB_start_position_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_CD_start_position_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_CD_start_position_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_ABCD_end_position_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    injection_ABCD_end_position_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_molding_start_position_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_molding_start_position_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_molding_end_position_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    tube_molding_end_position_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    polimerization_furnace_temperature_min?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
    polimerization_furnace_temperature_max?: IntNullableWithAggregatesFilter<"tube_parameters"> | number | null
  }

  export type tube_productsWhereInput = {
    AND?: tube_productsWhereInput | tube_productsWhereInput[]
    OR?: tube_productsWhereInput[]
    NOT?: tube_productsWhereInput | tube_productsWhereInput[]
    id?: IntFilter<"tube_products"> | number
    code_1C?: StringNullableFilter<"tube_products"> | string | null
    marking?: StringNullableFilter<"tube_products"> | string | null
    name?: StringNullableFilter<"tube_products"> | string | null
    tube_records?: Tube_recordsListRelationFilter
    tube_specifications?: Tube_specificationsListRelationFilter
  }

  export type tube_productsOrderByWithRelationInput = {
    id?: SortOrder
    code_1C?: SortOrderInput | SortOrder
    marking?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    tube_records?: tube_recordsOrderByRelationAggregateInput
    tube_specifications?: tube_specificationsOrderByRelationAggregateInput
  }

  export type tube_productsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code_1C?: string
    AND?: tube_productsWhereInput | tube_productsWhereInput[]
    OR?: tube_productsWhereInput[]
    NOT?: tube_productsWhereInput | tube_productsWhereInput[]
    marking?: StringNullableFilter<"tube_products"> | string | null
    name?: StringNullableFilter<"tube_products"> | string | null
    tube_records?: Tube_recordsListRelationFilter
    tube_specifications?: Tube_specificationsListRelationFilter
  }, "id" | "code_1C">

  export type tube_productsOrderByWithAggregationInput = {
    id?: SortOrder
    code_1C?: SortOrderInput | SortOrder
    marking?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    _count?: tube_productsCountOrderByAggregateInput
    _avg?: tube_productsAvgOrderByAggregateInput
    _max?: tube_productsMaxOrderByAggregateInput
    _min?: tube_productsMinOrderByAggregateInput
    _sum?: tube_productsSumOrderByAggregateInput
  }

  export type tube_productsScalarWhereWithAggregatesInput = {
    AND?: tube_productsScalarWhereWithAggregatesInput | tube_productsScalarWhereWithAggregatesInput[]
    OR?: tube_productsScalarWhereWithAggregatesInput[]
    NOT?: tube_productsScalarWhereWithAggregatesInput | tube_productsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_products"> | number
    code_1C?: StringNullableWithAggregatesFilter<"tube_products"> | string | null
    marking?: StringNullableWithAggregatesFilter<"tube_products"> | string | null
    name?: StringNullableWithAggregatesFilter<"tube_products"> | string | null
  }

  export type tube_recordsWhereInput = {
    AND?: tube_recordsWhereInput | tube_recordsWhereInput[]
    OR?: tube_recordsWhereInput[]
    NOT?: tube_recordsWhereInput | tube_recordsWhereInput[]
    id?: IntFilter<"tube_records"> | number
    tube_product_id?: IntNullableFilter<"tube_records"> | number | null
    tube_conveyor_id?: IntNullableFilter<"tube_records"> | number | null
    boil_id?: IntNullableFilter<"tube_records"> | number | null
    plan?: IntFilter<"tube_records"> | number
    start_date?: DateTimeNullableFilter<"tube_records"> | Date | string | null
    active?: BoolNullableFilter<"tube_records"> | boolean | null
    finished?: BoolNullableFilter<"tube_records"> | boolean | null
    createdAt?: DateTimeFilter<"tube_records"> | Date | string
    updatedAt?: DateTimeFilter<"tube_records"> | Date | string
    boils?: XOR<BoilsNullableScalarRelationFilter, boilsWhereInput> | null
    tube_conveyors?: XOR<Tube_conveyorsNullableScalarRelationFilter, tube_conveyorsWhereInput> | null
    tube_products?: XOR<Tube_productsNullableScalarRelationFilter, tube_productsWhereInput> | null
  }

  export type tube_recordsOrderByWithRelationInput = {
    id?: SortOrder
    tube_product_id?: SortOrderInput | SortOrder
    tube_conveyor_id?: SortOrderInput | SortOrder
    boil_id?: SortOrderInput | SortOrder
    plan?: SortOrder
    start_date?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    finished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    boils?: boilsOrderByWithRelationInput
    tube_conveyors?: tube_conveyorsOrderByWithRelationInput
    tube_products?: tube_productsOrderByWithRelationInput
  }

  export type tube_recordsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tube_recordsWhereInput | tube_recordsWhereInput[]
    OR?: tube_recordsWhereInput[]
    NOT?: tube_recordsWhereInput | tube_recordsWhereInput[]
    tube_product_id?: IntNullableFilter<"tube_records"> | number | null
    tube_conveyor_id?: IntNullableFilter<"tube_records"> | number | null
    boil_id?: IntNullableFilter<"tube_records"> | number | null
    plan?: IntFilter<"tube_records"> | number
    start_date?: DateTimeNullableFilter<"tube_records"> | Date | string | null
    active?: BoolNullableFilter<"tube_records"> | boolean | null
    finished?: BoolNullableFilter<"tube_records"> | boolean | null
    createdAt?: DateTimeFilter<"tube_records"> | Date | string
    updatedAt?: DateTimeFilter<"tube_records"> | Date | string
    boils?: XOR<BoilsNullableScalarRelationFilter, boilsWhereInput> | null
    tube_conveyors?: XOR<Tube_conveyorsNullableScalarRelationFilter, tube_conveyorsWhereInput> | null
    tube_products?: XOR<Tube_productsNullableScalarRelationFilter, tube_productsWhereInput> | null
  }, "id">

  export type tube_recordsOrderByWithAggregationInput = {
    id?: SortOrder
    tube_product_id?: SortOrderInput | SortOrder
    tube_conveyor_id?: SortOrderInput | SortOrder
    boil_id?: SortOrderInput | SortOrder
    plan?: SortOrder
    start_date?: SortOrderInput | SortOrder
    active?: SortOrderInput | SortOrder
    finished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tube_recordsCountOrderByAggregateInput
    _avg?: tube_recordsAvgOrderByAggregateInput
    _max?: tube_recordsMaxOrderByAggregateInput
    _min?: tube_recordsMinOrderByAggregateInput
    _sum?: tube_recordsSumOrderByAggregateInput
  }

  export type tube_recordsScalarWhereWithAggregatesInput = {
    AND?: tube_recordsScalarWhereWithAggregatesInput | tube_recordsScalarWhereWithAggregatesInput[]
    OR?: tube_recordsScalarWhereWithAggregatesInput[]
    NOT?: tube_recordsScalarWhereWithAggregatesInput | tube_recordsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_records"> | number
    tube_product_id?: IntNullableWithAggregatesFilter<"tube_records"> | number | null
    tube_conveyor_id?: IntNullableWithAggregatesFilter<"tube_records"> | number | null
    boil_id?: IntNullableWithAggregatesFilter<"tube_records"> | number | null
    plan?: IntWithAggregatesFilter<"tube_records"> | number
    start_date?: DateTimeNullableWithAggregatesFilter<"tube_records"> | Date | string | null
    active?: BoolNullableWithAggregatesFilter<"tube_records"> | boolean | null
    finished?: BoolNullableWithAggregatesFilter<"tube_records"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"tube_records"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tube_records"> | Date | string
  }

  export type tube_sessionsWhereInput = {
    AND?: tube_sessionsWhereInput | tube_sessionsWhereInput[]
    OR?: tube_sessionsWhereInput[]
    NOT?: tube_sessionsWhereInput | tube_sessionsWhereInput[]
    id?: IntFilter<"tube_sessions"> | number
    conveyor_id?: IntNullableFilter<"tube_sessions"> | number | null
    employee_id?: IntNullableFilter<"tube_sessions"> | number | null
    finished?: BoolNullableFilter<"tube_sessions"> | boolean | null
    createdAt?: DateTimeFilter<"tube_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"tube_sessions"> | Date | string
    tube_conveyors?: XOR<Tube_conveyorsNullableScalarRelationFilter, tube_conveyorsWhereInput> | null
    employees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
  }

  export type tube_sessionsOrderByWithRelationInput = {
    id?: SortOrder
    conveyor_id?: SortOrderInput | SortOrder
    employee_id?: SortOrderInput | SortOrder
    finished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tube_conveyors?: tube_conveyorsOrderByWithRelationInput
    employees?: employeesOrderByWithRelationInput
  }

  export type tube_sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tube_sessionsWhereInput | tube_sessionsWhereInput[]
    OR?: tube_sessionsWhereInput[]
    NOT?: tube_sessionsWhereInput | tube_sessionsWhereInput[]
    conveyor_id?: IntNullableFilter<"tube_sessions"> | number | null
    employee_id?: IntNullableFilter<"tube_sessions"> | number | null
    finished?: BoolNullableFilter<"tube_sessions"> | boolean | null
    createdAt?: DateTimeFilter<"tube_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"tube_sessions"> | Date | string
    tube_conveyors?: XOR<Tube_conveyorsNullableScalarRelationFilter, tube_conveyorsWhereInput> | null
    employees?: XOR<EmployeesNullableScalarRelationFilter, employeesWhereInput> | null
  }, "id">

  export type tube_sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    conveyor_id?: SortOrderInput | SortOrder
    employee_id?: SortOrderInput | SortOrder
    finished?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tube_sessionsCountOrderByAggregateInput
    _avg?: tube_sessionsAvgOrderByAggregateInput
    _max?: tube_sessionsMaxOrderByAggregateInput
    _min?: tube_sessionsMinOrderByAggregateInput
    _sum?: tube_sessionsSumOrderByAggregateInput
  }

  export type tube_sessionsScalarWhereWithAggregatesInput = {
    AND?: tube_sessionsScalarWhereWithAggregatesInput | tube_sessionsScalarWhereWithAggregatesInput[]
    OR?: tube_sessionsScalarWhereWithAggregatesInput[]
    NOT?: tube_sessionsScalarWhereWithAggregatesInput | tube_sessionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_sessions"> | number
    conveyor_id?: IntNullableWithAggregatesFilter<"tube_sessions"> | number | null
    employee_id?: IntNullableWithAggregatesFilter<"tube_sessions"> | number | null
    finished?: BoolNullableWithAggregatesFilter<"tube_sessions"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"tube_sessions"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tube_sessions"> | Date | string
  }

  export type tube_specificationsWhereInput = {
    AND?: tube_specificationsWhereInput | tube_specificationsWhereInput[]
    OR?: tube_specificationsWhereInput[]
    NOT?: tube_specificationsWhereInput | tube_specificationsWhereInput[]
    id?: IntFilter<"tube_specifications"> | number
    tube_product_id?: IntNullableFilter<"tube_specifications"> | number | null
    tube_material_id?: IntNullableFilter<"tube_specifications"> | number | null
    createdAt?: DateTimeFilter<"tube_specifications"> | Date | string
    updatedAt?: DateTimeFilter<"tube_specifications"> | Date | string
    tube_materials?: XOR<Tube_materialsNullableScalarRelationFilter, tube_materialsWhereInput> | null
    tube_products?: XOR<Tube_productsNullableScalarRelationFilter, tube_productsWhereInput> | null
  }

  export type tube_specificationsOrderByWithRelationInput = {
    id?: SortOrder
    tube_product_id?: SortOrderInput | SortOrder
    tube_material_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tube_materials?: tube_materialsOrderByWithRelationInput
    tube_products?: tube_productsOrderByWithRelationInput
  }

  export type tube_specificationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: tube_specificationsWhereInput | tube_specificationsWhereInput[]
    OR?: tube_specificationsWhereInput[]
    NOT?: tube_specificationsWhereInput | tube_specificationsWhereInput[]
    tube_product_id?: IntNullableFilter<"tube_specifications"> | number | null
    tube_material_id?: IntNullableFilter<"tube_specifications"> | number | null
    createdAt?: DateTimeFilter<"tube_specifications"> | Date | string
    updatedAt?: DateTimeFilter<"tube_specifications"> | Date | string
    tube_materials?: XOR<Tube_materialsNullableScalarRelationFilter, tube_materialsWhereInput> | null
    tube_products?: XOR<Tube_productsNullableScalarRelationFilter, tube_productsWhereInput> | null
  }, "id">

  export type tube_specificationsOrderByWithAggregationInput = {
    id?: SortOrder
    tube_product_id?: SortOrderInput | SortOrder
    tube_material_id?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: tube_specificationsCountOrderByAggregateInput
    _avg?: tube_specificationsAvgOrderByAggregateInput
    _max?: tube_specificationsMaxOrderByAggregateInput
    _min?: tube_specificationsMinOrderByAggregateInput
    _sum?: tube_specificationsSumOrderByAggregateInput
  }

  export type tube_specificationsScalarWhereWithAggregatesInput = {
    AND?: tube_specificationsScalarWhereWithAggregatesInput | tube_specificationsScalarWhereWithAggregatesInput[]
    OR?: tube_specificationsScalarWhereWithAggregatesInput[]
    NOT?: tube_specificationsScalarWhereWithAggregatesInput | tube_specificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"tube_specifications"> | number
    tube_product_id?: IntNullableWithAggregatesFilter<"tube_specifications"> | number | null
    tube_material_id?: IntNullableWithAggregatesFilter<"tube_specifications"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"tube_specifications"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"tube_specifications"> | Date | string
  }

  export type user_rolesWhereInput = {
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    id?: IntFilter<"user_roles"> | number
    roleId?: IntFilter<"user_roles"> | number
    userId?: IntFilter<"user_roles"> | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type user_rolesOrderByWithRelationInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    roles?: rolesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type user_rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    roleId_userId?: user_rolesRoleIdUserIdCompoundUniqueInput
    AND?: user_rolesWhereInput | user_rolesWhereInput[]
    OR?: user_rolesWhereInput[]
    NOT?: user_rolesWhereInput | user_rolesWhereInput[]
    roleId?: IntFilter<"user_roles"> | number
    userId?: IntFilter<"user_roles"> | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "roleId_userId">

  export type user_rolesOrderByWithAggregationInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
    _count?: user_rolesCountOrderByAggregateInput
    _avg?: user_rolesAvgOrderByAggregateInput
    _max?: user_rolesMaxOrderByAggregateInput
    _min?: user_rolesMinOrderByAggregateInput
    _sum?: user_rolesSumOrderByAggregateInput
  }

  export type user_rolesScalarWhereWithAggregatesInput = {
    AND?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    OR?: user_rolesScalarWhereWithAggregatesInput[]
    NOT?: user_rolesScalarWhereWithAggregatesInput | user_rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"user_roles"> | number
    roleId?: IntWithAggregatesFilter<"user_roles"> | number
    userId?: IntWithAggregatesFilter<"user_roles"> | number
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: IntFilter<"users"> | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    banned?: BoolNullableFilter<"users"> | boolean | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    histories?: HistoriesListRelationFilter
    tokens?: TokensListRelationFilter
    user_roles?: User_rolesListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    banned?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    histories?: historiesOrderByRelationAggregateInput
    tokens?: tokensOrderByRelationAggregateInput
    user_roles?: user_rolesOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    banned?: BoolNullableFilter<"users"> | boolean | null
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    histories?: HistoriesListRelationFilter
    tokens?: TokensListRelationFilter
    user_roles?: User_rolesListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    banned?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"users"> | number
    name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    banned?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type workshopsWhereInput = {
    AND?: workshopsWhereInput | workshopsWhereInput[]
    OR?: workshopsWhereInput[]
    NOT?: workshopsWhereInput | workshopsWhereInput[]
    id?: IntFilter<"workshops"> | number
    value?: StringFilter<"workshops"> | string
    records?: RecordsListRelationFilter
  }

  export type workshopsOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    records?: recordsOrderByRelationAggregateInput
  }

  export type workshopsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    value?: string
    AND?: workshopsWhereInput | workshopsWhereInput[]
    OR?: workshopsWhereInput[]
    NOT?: workshopsWhereInput | workshopsWhereInput[]
    records?: RecordsListRelationFilter
  }, "id" | "value">

  export type workshopsOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    _count?: workshopsCountOrderByAggregateInput
    _avg?: workshopsAvgOrderByAggregateInput
    _max?: workshopsMaxOrderByAggregateInput
    _min?: workshopsMinOrderByAggregateInput
    _sum?: workshopsSumOrderByAggregateInput
  }

  export type workshopsScalarWhereWithAggregatesInput = {
    AND?: workshopsScalarWhereWithAggregatesInput | workshopsScalarWhereWithAggregatesInput[]
    OR?: workshopsScalarWhereWithAggregatesInput[]
    NOT?: workshopsScalarWhereWithAggregatesInput | workshopsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"workshops"> | number
    value?: StringWithAggregatesFilter<"workshops"> | string
  }

  export type BatchsCreateInput = {
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BatchsUncheckedCreateInput = {
    BatchPK?: number
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BatchsUpdateInput = {
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchsUncheckedUpdateInput = {
    BatchPK?: IntFieldUpdateOperationsInput | number
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchsCreateManyInput = {
    BatchPK?: number
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type BatchsUpdateManyMutationInput = {
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BatchsUncheckedUpdateManyInput = {
    BatchPK?: IntFieldUpdateOperationsInput | number
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceBatchesCreateInput = {
    BatchPK?: number | null
    BatchName?: string | null
    BatchDate?: Date | string | null
    Plant?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TraceBatchesUncheckedCreateInput = {
    id?: number
    BatchPK?: number | null
    BatchName?: string | null
    BatchDate?: Date | string | null
    Plant?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TraceBatchesUpdateInput = {
    BatchPK?: NullableIntFieldUpdateOperationsInput | number | null
    BatchName?: NullableStringFieldUpdateOperationsInput | string | null
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceBatchesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    BatchPK?: NullableIntFieldUpdateOperationsInput | number | null
    BatchName?: NullableStringFieldUpdateOperationsInput | string | null
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceBatchesCreateManyInput = {
    id?: number
    BatchPK?: number | null
    BatchName?: string | null
    BatchDate?: Date | string | null
    Plant?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type TraceBatchesUpdateManyMutationInput = {
    BatchPK?: NullableIntFieldUpdateOperationsInput | number | null
    BatchName?: NullableStringFieldUpdateOperationsInput | string | null
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TraceBatchesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    BatchPK?: NullableIntFieldUpdateOperationsInput | number | null
    BatchName?: NullableStringFieldUpdateOperationsInput | string | null
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_errorsCreateInput = {
    dto?: string | null
    message?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type api_errorsUncheckedCreateInput = {
    id?: number
    dto?: string | null
    message?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type api_errorsUpdateInput = {
    dto?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_errorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    dto?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_errorsCreateManyInput = {
    id?: number
    dto?: string | null
    message?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type api_errorsUpdateManyMutationInput = {
    dto?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type api_errorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    dto?: NullableStringFieldUpdateOperationsInput | string | null
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type apparatusesCreateInput = {
    value: string
    records?: recordsCreateNestedManyWithoutApparatusesInput
  }

  export type apparatusesUncheckedCreateInput = {
    id?: number
    value: string
    records?: recordsUncheckedCreateNestedManyWithoutApparatusesInput
  }

  export type apparatusesUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    records?: recordsUpdateManyWithoutApparatusesNestedInput
  }

  export type apparatusesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    records?: recordsUncheckedUpdateManyWithoutApparatusesNestedInput
  }

  export type apparatusesCreateManyInput = {
    id?: number
    value: string
  }

  export type apparatusesUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type apparatusesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type basesCreateInput = {
    code: string
    marking?: string | null
    boils?: boilsCreateNestedManyWithoutBasesInput
  }

  export type basesUncheckedCreateInput = {
    id?: number
    code: string
    marking?: string | null
    boils?: boilsUncheckedCreateNestedManyWithoutBasesInput
  }

  export type basesUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    boils?: boilsUpdateManyWithoutBasesNestedInput
  }

  export type basesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    boils?: boilsUncheckedUpdateManyWithoutBasesNestedInput
  }

  export type basesCreateManyInput = {
    id?: number
    code: string
    marking?: string | null
  }

  export type basesUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    marking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type basesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    marking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type batchsCreateInput = {
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type batchsUncheckedCreateInput = {
    BatchPK?: number
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type batchsUpdateInput = {
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type batchsUncheckedUpdateInput = {
    BatchPK?: IntFieldUpdateOperationsInput | number
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type batchsCreateManyInput = {
    BatchPK?: number
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type batchsUpdateManyMutationInput = {
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type batchsUncheckedUpdateManyInput = {
    BatchPK?: IntFieldUpdateOperationsInput | number
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type boilsCreateInput = {
    value: string
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    bases?: basesCreateNestedOneWithoutBoilsInput
    semi_products?: semi_productsCreateNestedManyWithoutBoilsInput
    tube_records?: tube_recordsCreateNestedManyWithoutBoilsInput
    records?: recordsCreateNestedManyWithoutBoilsInput
  }

  export type boilsUncheckedCreateInput = {
    id?: number
    value: string
    base_id?: number | null
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutBoilsInput
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutBoilsInput
    records?: recordsUncheckedCreateNestedManyWithoutBoilsInput
  }

  export type boilsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    bases?: basesUpdateOneWithoutBoilsNestedInput
    semi_products?: semi_productsUpdateManyWithoutBoilsNestedInput
    tube_records?: tube_recordsUpdateManyWithoutBoilsNestedInput
    records?: recordsUpdateManyWithoutBoilsNestedInput
  }

  export type boilsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    base_id?: NullableIntFieldUpdateOperationsInput | number | null
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    semi_products?: semi_productsUncheckedUpdateManyWithoutBoilsNestedInput
    tube_records?: tube_recordsUncheckedUpdateManyWithoutBoilsNestedInput
    records?: recordsUncheckedUpdateManyWithoutBoilsNestedInput
  }

  export type boilsCreateManyInput = {
    id?: number
    value: string
    base_id?: number | null
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
  }

  export type boilsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type boilsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    base_id?: NullableIntFieldUpdateOperationsInput | number | null
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type cansCreateInput = {
    value: string
    records?: recordsCreateNestedManyWithoutCansInput
  }

  export type cansUncheckedCreateInput = {
    id?: number
    value: string
    records?: recordsUncheckedCreateNestedManyWithoutCansInput
  }

  export type cansUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    records?: recordsUpdateManyWithoutCansNestedInput
  }

  export type cansUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    records?: recordsUncheckedUpdateManyWithoutCansNestedInput
  }

  export type cansCreateManyInput = {
    id?: number
    value: string
  }

  export type cansUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type cansUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type conveyorsCreateInput = {
    value: string
    barcode?: string | null
    records?: recordsCreateNestedManyWithoutConveyorsInput
  }

  export type conveyorsUncheckedCreateInput = {
    id?: number
    value: string
    barcode?: string | null
    records?: recordsUncheckedCreateNestedManyWithoutConveyorsInput
  }

  export type conveyorsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    records?: recordsUpdateManyWithoutConveyorsNestedInput
  }

  export type conveyorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    records?: recordsUncheckedUpdateManyWithoutConveyorsNestedInput
  }

  export type conveyorsCreateManyInput = {
    id?: number
    value: string
    barcode?: string | null
  }

  export type conveyorsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conveyorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dbo_BatchsCreateInput = {
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type dbo_BatchsUncheckedCreateInput = {
    BatchPK?: number
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type dbo_BatchsUpdateInput = {
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dbo_BatchsUncheckedUpdateInput = {
    BatchPK?: IntFieldUpdateOperationsInput | number
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dbo_BatchsCreateManyInput = {
    BatchPK?: number
    BatchName: string
    BatchDate?: Date | string | null
    Plant: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type dbo_BatchsUpdateManyMutationInput = {
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type dbo_BatchsUncheckedUpdateManyInput = {
    BatchPK?: IntFieldUpdateOperationsInput | number
    BatchName?: StringFieldUpdateOperationsInput | string
    BatchDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Plant?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type docsCreateInput = {
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    plants?: plantsCreateNestedOneWithoutDocsInput
    records?: recordsCreateNestedManyWithoutDocsInput
  }

  export type docsUncheckedCreateInput = {
    id?: number
    plantId?: number | null
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsUncheckedCreateNestedManyWithoutDocsInput
  }

  export type docsUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plants?: plantsUpdateOneWithoutDocsNestedInput
    records?: recordsUpdateManyWithoutDocsNestedInput
  }

  export type docsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUncheckedUpdateManyWithoutDocsNestedInput
  }

  export type docsCreateManyInput = {
    id?: number
    plantId?: number | null
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type docsUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type docsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employeesCreateInput = {
    name: string
    barcode: string
    createdAt: Date | string
    updatedAt: Date | string
    occupations?: occupationsCreateNestedOneWithoutEmployeesInput
    histories?: historiesCreateNestedManyWithoutEmployeesInput
    tube_histories?: tube_historiesCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateInput = {
    id?: number
    name: string
    barcode: string
    occupationId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesUncheckedCreateNestedManyWithoutEmployeesInput
    tube_histories?: tube_historiesUncheckedCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occupations?: occupationsUpdateOneWithoutEmployeesNestedInput
    histories?: historiesUpdateManyWithoutEmployeesNestedInput
    tube_histories?: tube_historiesUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    occupationId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUncheckedUpdateManyWithoutEmployeesNestedInput
    tube_histories?: tube_historiesUncheckedUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUncheckedUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesCreateManyInput = {
    id?: number
    name: string
    barcode: string
    occupationId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type employeesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employeesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    occupationId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historiesCreateInput = {
    boil_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
    employees?: employeesCreateNestedOneWithoutHistoriesInput
    history_types?: history_typesCreateNestedOneWithoutHistoriesInput
    records?: recordsCreateNestedOneWithoutHistoriesInput
    users?: usersCreateNestedOneWithoutHistoriesInput
  }

  export type historiesUncheckedCreateInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    historyTypeId?: number | null
    userId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type historiesUpdateInput = {
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    employees?: employeesUpdateOneWithoutHistoriesNestedInput
    history_types?: history_typesUpdateOneWithoutHistoriesNestedInput
    records?: recordsUpdateOneWithoutHistoriesNestedInput
    users?: usersUpdateOneWithoutHistoriesNestedInput
  }

  export type historiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historiesCreateManyInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    historyTypeId?: number | null
    userId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type historiesUpdateManyMutationInput = {
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type history_typesCreateInput = {
    value: string
    description: string
    for_boil?: boolean | null
    histories?: historiesCreateNestedManyWithoutHistory_typesInput
  }

  export type history_typesUncheckedCreateInput = {
    id?: number
    value: string
    description: string
    for_boil?: boolean | null
    histories?: historiesUncheckedCreateNestedManyWithoutHistory_typesInput
  }

  export type history_typesUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    for_boil?: NullableBoolFieldUpdateOperationsInput | boolean | null
    histories?: historiesUpdateManyWithoutHistory_typesNestedInput
  }

  export type history_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    for_boil?: NullableBoolFieldUpdateOperationsInput | boolean | null
    histories?: historiesUncheckedUpdateManyWithoutHistory_typesNestedInput
  }

  export type history_typesCreateManyInput = {
    id?: number
    value: string
    description: string
    for_boil?: boolean | null
  }

  export type history_typesUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    for_boil?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type history_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    for_boil?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type marking_sampleCreateInput = {
    value?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    record_regulations?: record_regulationsCreateNestedManyWithoutMarking_sampleInput
    regulations?: regulationsCreateNestedManyWithoutMarking_sampleInput
  }

  export type marking_sampleUncheckedCreateInput = {
    id?: number
    value?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutMarking_sampleInput
    regulations?: regulationsUncheckedCreateNestedManyWithoutMarking_sampleInput
  }

  export type marking_sampleUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record_regulations?: record_regulationsUpdateManyWithoutMarking_sampleNestedInput
    regulations?: regulationsUpdateManyWithoutMarking_sampleNestedInput
  }

  export type marking_sampleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutMarking_sampleNestedInput
    regulations?: regulationsUncheckedUpdateManyWithoutMarking_sampleNestedInput
  }

  export type marking_sampleCreateManyInput = {
    id?: number
    value?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type marking_sampleUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type marking_sampleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type notesCreateInput = {
    value?: string | null
  }

  export type notesUncheckedCreateInput = {
    id?: number
    value?: string | null
  }

  export type notesUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notesCreateManyInput = {
    id?: number
    value?: string | null
  }

  export type notesUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type notesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type occupationsCreateInput = {
    value: string
    description: string
    employees?: employeesCreateNestedManyWithoutOccupationsInput
  }

  export type occupationsUncheckedCreateInput = {
    id?: number
    value: string
    description: string
    employees?: employeesUncheckedCreateNestedManyWithoutOccupationsInput
  }

  export type occupationsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employees?: employeesUpdateManyWithoutOccupationsNestedInput
  }

  export type occupationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    employees?: employeesUncheckedUpdateManyWithoutOccupationsNestedInput
  }

  export type occupationsCreateManyInput = {
    id?: number
    value: string
    description: string
  }

  export type occupationsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type occupationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type plantsCreateInput = {
    value: string
    abb?: string | null
    docs?: docsCreateNestedManyWithoutPlantsInput
  }

  export type plantsUncheckedCreateInput = {
    id?: number
    value: string
    abb?: string | null
    docs?: docsUncheckedCreateNestedManyWithoutPlantsInput
  }

  export type plantsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    abb?: NullableStringFieldUpdateOperationsInput | string | null
    docs?: docsUpdateManyWithoutPlantsNestedInput
  }

  export type plantsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    abb?: NullableStringFieldUpdateOperationsInput | string | null
    docs?: docsUncheckedUpdateManyWithoutPlantsNestedInput
  }

  export type plantsCreateManyInput = {
    id?: number
    value: string
    abb?: string | null
  }

  export type plantsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    abb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plantsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    abb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type productsCreateInput = {
    code1C: string
    marking: string
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    series?: seriesCreateNestedOneWithoutProductsInput
    records?: recordsCreateNestedManyWithoutProductsInput
    regulations?: regulationsCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateInput = {
    id?: number
    code1C: string
    marking: string
    name?: string | null
    serieId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsUncheckedCreateNestedManyWithoutProductsInput
    regulations?: regulationsUncheckedCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsUpdateInput = {
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: seriesUpdateOneWithoutProductsNestedInput
    records?: recordsUpdateManyWithoutProductsNestedInput
    regulations?: regulationsUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    serieId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUncheckedUpdateManyWithoutProductsNestedInput
    regulations?: regulationsUncheckedUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsCreateManyInput = {
    id?: number
    code1C: string
    marking: string
    name?: string | null
    serieId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type productsUpdateManyMutationInput = {
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    serieId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type record_regulationsCreateInput = {
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    marking_sample?: marking_sampleCreateNestedOneWithoutRecord_regulationsInput
    records?: recordsCreateNestedOneWithoutRecord_regulationsInput
  }

  export type record_regulationsUncheckedCreateInput = {
    id?: number
    record_id?: number | null
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type record_regulationsUpdateInput = {
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marking_sample?: marking_sampleUpdateOneWithoutRecord_regulationsNestedInput
    records?: recordsUpdateOneWithoutRecord_regulationsNestedInput
  }

  export type record_regulationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type record_regulationsCreateManyInput = {
    id?: number
    record_id?: number | null
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type record_regulationsUpdateManyMutationInput = {
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type record_regulationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recordsCreateInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsUpdateInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsCreateManyInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type recordsUpdateManyMutationInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type recordsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type regulationsCreateInput = {
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    marking_sample?: marking_sampleCreateNestedOneWithoutRegulationsInput
    products?: productsCreateNestedOneWithoutRegulationsInput
  }

  export type regulationsUncheckedCreateInput = {
    id?: number
    product_id?: number | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type regulationsUpdateInput = {
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marking_sample?: marking_sampleUpdateOneWithoutRegulationsNestedInput
    products?: productsUpdateOneWithoutRegulationsNestedInput
  }

  export type regulationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type regulationsCreateManyInput = {
    id?: number
    product_id?: number | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type regulationsUpdateManyMutationInput = {
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type regulationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rolesCreateInput = {
    value: string
    description: string
    user_roles?: user_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    value: string
    description: string
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    user_roles?: user_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    user_roles?: user_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    value: string
    description: string
  }

  export type rolesUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type semi_productsCreateInput = {
    createdAt: Date | string
    updatedAt: Date | string
    boils?: boilsCreateNestedOneWithoutSemi_productsInput
    products?: productsCreateNestedOneWithoutSemi_productsInput
    records?: recordsCreateNestedOneWithoutSemi_productsInput
  }

  export type semi_productsUncheckedCreateInput = {
    id?: number
    record_id?: number | null
    product_id?: number | null
    boil_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type semi_productsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boils?: boilsUpdateOneWithoutSemi_productsNestedInput
    products?: productsUpdateOneWithoutSemi_productsNestedInput
    records?: recordsUpdateOneWithoutSemi_productsNestedInput
  }

  export type semi_productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semi_productsCreateManyInput = {
    id?: number
    record_id?: number | null
    product_id?: number | null
    boil_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type semi_productsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semi_productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type seriesCreateInput = {
    value: string
    products?: productsCreateNestedManyWithoutSeriesInput
  }

  export type seriesUncheckedCreateInput = {
    id?: number
    value: string
    products?: productsUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type seriesUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    products?: productsUpdateManyWithoutSeriesNestedInput
  }

  export type seriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    products?: productsUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type seriesCreateManyInput = {
    id?: number
    value: string
  }

  export type seriesUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type seriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type signalsCreateInput = {
    value: string
  }

  export type signalsUncheckedCreateInput = {
    id?: number
    value: string
  }

  export type signalsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type signalsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type signalsCreateManyInput = {
    id?: number
    value: string
  }

  export type signalsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type signalsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type tokensCreateInput = {
    token: string
    createdAt: Date | string
    updatedAt: Date | string
    users?: usersCreateNestedOneWithoutTokensInput
  }

  export type tokensUncheckedCreateInput = {
    id?: number
    userId?: number | null
    token: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokensUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneWithoutTokensNestedInput
  }

  export type tokensUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensCreateManyInput = {
    id?: number
    userId?: number | null
    token: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokensUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_assemblyCreateInput = {
    tube_record_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_conveyor_posts?: tube_conveyor_postsCreateNestedOneWithoutTube_assemblyInput
    tube_materials?: tube_materialsCreateNestedOneWithoutTube_assemblyInput
  }

  export type tube_assemblyUncheckedCreateInput = {
    id?: number
    tube_record_id?: number | null
    tube_material_id?: number | null
    tube_conveyor_post_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_assemblyUpdateInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_conveyor_posts?: tube_conveyor_postsUpdateOneWithoutTube_assemblyNestedInput
    tube_materials?: tube_materialsUpdateOneWithoutTube_assemblyNestedInput
  }

  export type tube_assemblyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_assemblyCreateManyInput = {
    id?: number
    tube_record_id?: number | null
    tube_material_id?: number | null
    tube_conveyor_post_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_assemblyUpdateManyMutationInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_assemblyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_conveyor_postsCreateInput = {
    name: string
    tube_assembly?: tube_assemblyCreateNestedManyWithoutTube_conveyor_postsInput
  }

  export type tube_conveyor_postsUncheckedCreateInput = {
    id?: number
    name: string
    tube_assembly?: tube_assemblyUncheckedCreateNestedManyWithoutTube_conveyor_postsInput
  }

  export type tube_conveyor_postsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    tube_assembly?: tube_assemblyUpdateManyWithoutTube_conveyor_postsNestedInput
  }

  export type tube_conveyor_postsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    tube_assembly?: tube_assemblyUncheckedUpdateManyWithoutTube_conveyor_postsNestedInput
  }

  export type tube_conveyor_postsCreateManyInput = {
    id?: number
    name: string
  }

  export type tube_conveyor_postsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tube_conveyor_postsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tube_conveyorsCreateInput = {
    name?: string | null
    barcode?: string | null
    tube_records?: tube_recordsCreateNestedManyWithoutTube_conveyorsInput
    tube_sessions?: tube_sessionsCreateNestedManyWithoutTube_conveyorsInput
  }

  export type tube_conveyorsUncheckedCreateInput = {
    id?: number
    name?: string | null
    barcode?: string | null
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutTube_conveyorsInput
    tube_sessions?: tube_sessionsUncheckedCreateNestedManyWithoutTube_conveyorsInput
  }

  export type tube_conveyorsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUpdateManyWithoutTube_conveyorsNestedInput
    tube_sessions?: tube_sessionsUpdateManyWithoutTube_conveyorsNestedInput
  }

  export type tube_conveyorsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUncheckedUpdateManyWithoutTube_conveyorsNestedInput
    tube_sessions?: tube_sessionsUncheckedUpdateManyWithoutTube_conveyorsNestedInput
  }

  export type tube_conveyorsCreateManyInput = {
    id?: number
    name?: string | null
    barcode?: string | null
  }

  export type tube_conveyorsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_conveyorsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_historiesCreateInput = {
    tube_record_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    employees?: employeesCreateNestedOneWithoutTube_historiesInput
    tube_histories_notes?: tube_histories_notesCreateNestedOneWithoutTube_historiesInput
    tube_history_types?: tube_history_typesCreateNestedOneWithoutTube_historiesInput
  }

  export type tube_historiesUncheckedCreateInput = {
    id?: number
    tube_record_id?: number | null
    tube_history_type_id?: number | null
    employee_id?: number | null
    note?: string | null
    tube_history_note_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_historiesUpdateInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: employeesUpdateOneWithoutTube_historiesNestedInput
    tube_histories_notes?: tube_histories_notesUpdateOneWithoutTube_historiesNestedInput
    tube_history_types?: tube_history_typesUpdateOneWithoutTube_historiesNestedInput
  }

  export type tube_historiesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_history_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    tube_history_note_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_historiesCreateManyInput = {
    id?: number
    tube_record_id?: number | null
    tube_history_type_id?: number | null
    employee_id?: number | null
    note?: string | null
    tube_history_note_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_historiesUpdateManyMutationInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_historiesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_history_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    tube_history_note_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_histories_notesCreateInput = {
    value?: string | null
    tube_histories?: tube_historiesCreateNestedManyWithoutTube_histories_notesInput
  }

  export type tube_histories_notesUncheckedCreateInput = {
    id?: number
    value?: string | null
    tube_histories?: tube_historiesUncheckedCreateNestedManyWithoutTube_histories_notesInput
  }

  export type tube_histories_notesUpdateInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    tube_histories?: tube_historiesUpdateManyWithoutTube_histories_notesNestedInput
  }

  export type tube_histories_notesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    tube_histories?: tube_historiesUncheckedUpdateManyWithoutTube_histories_notesNestedInput
  }

  export type tube_histories_notesCreateManyInput = {
    id?: number
    value?: string | null
  }

  export type tube_histories_notesUpdateManyMutationInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_histories_notesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_history_typesCreateInput = {
    value: string
    description: string
    tube_histories?: tube_historiesCreateNestedManyWithoutTube_history_typesInput
  }

  export type tube_history_typesUncheckedCreateInput = {
    id?: number
    value: string
    description: string
    tube_histories?: tube_historiesUncheckedCreateNestedManyWithoutTube_history_typesInput
  }

  export type tube_history_typesUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tube_histories?: tube_historiesUpdateManyWithoutTube_history_typesNestedInput
  }

  export type tube_history_typesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    tube_histories?: tube_historiesUncheckedUpdateManyWithoutTube_history_typesNestedInput
  }

  export type tube_history_typesCreateManyInput = {
    id?: number
    value: string
    description: string
  }

  export type tube_history_typesUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type tube_history_typesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type tube_materialsCreateInput = {
    code_1C?: string | null
    name?: string | null
    tube_assembly?: tube_assemblyCreateNestedManyWithoutTube_materialsInput
    tube_specifications?: tube_specificationsCreateNestedManyWithoutTube_materialsInput
  }

  export type tube_materialsUncheckedCreateInput = {
    id?: number
    code_1C?: string | null
    name?: string | null
    tube_assembly?: tube_assemblyUncheckedCreateNestedManyWithoutTube_materialsInput
    tube_specifications?: tube_specificationsUncheckedCreateNestedManyWithoutTube_materialsInput
  }

  export type tube_materialsUpdateInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_assembly?: tube_assemblyUpdateManyWithoutTube_materialsNestedInput
    tube_specifications?: tube_specificationsUpdateManyWithoutTube_materialsNestedInput
  }

  export type tube_materialsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_assembly?: tube_assemblyUncheckedUpdateManyWithoutTube_materialsNestedInput
    tube_specifications?: tube_specificationsUncheckedUpdateManyWithoutTube_materialsNestedInput
  }

  export type tube_materialsCreateManyInput = {
    id?: number
    code_1C?: string | null
    name?: string | null
  }

  export type tube_materialsUpdateManyMutationInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_materialsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_parametersCreateInput = {
    tube_record_id?: number | null
    press_speed_min?: number | null
    press_speed_max?: number | null
    molding_time_min?: number | null
    molding_time_max?: number | null
    turning_automate_speed_min?: number | null
    turning_automate_speed_max?: number | null
    annealing_furnace_temp_min?: number | null
    annealing_furnace_temp_max?: number | null
    cap_machine_speed_min?: number | null
    cap_machine_speed_max?: number | null
    cap_machine_air_pressure_min?: number | null
    cap_machine_air_pressure_max?: number | null
    grips_forward_min?: number | null
    grips_forward_max?: number | null
    grips_opening_left_min?: number | null
    grips_opening_left_max?: number | null
    grips_opening_right_min?: number | null
    grips_opening_right_max?: number | null
    grips_closing_min?: number | null
    grips_closing_max?: number | null
    injection_start_min?: number | null
    injection_start_max?: number | null
    injection_end_min?: number | null
    injection_end_max?: number | null
    tube_start_position_min?: number | null
    tube_start_position_max?: number | null
    tube_end_position_min?: number | null
    tube_end_position_max?: number | null
    padding_machine_speed_min?: number | null
    padding_machine_speed_max?: number | null
    padding_machine_air_pressure_min?: number | null
    padding_machine_air_pressure_max?: number | null
    padding_furnace_temp_min?: number | null
    padding_furnace_temp_max?: number | null
    offset_furnace_temp_min?: number | null
    offset_furnace_temp_max?: number | null
    printer_motor_speed_min?: number | null
    printer_motor_speed_max?: number | null
    holders_motor_speed_min?: number | null
    holders_motor_speed_max?: number | null
    station_motor_speed_min?: number | null
    station_motor_speed_max?: number | null
    ink_injection_time_min?: number | null
    ink_injection_time_max?: number | null
    lacquer_machine_speed_min?: number | null
    lacquer_machine_speed_max?: number | null
    lacquer_machine_air_pressure_min?: number | null
    lacquer_machine_air_pressure_max?: number | null
    feed_can_air_pressure_min?: number | null
    feed_can_air_pressure_max?: number | null
    nozzle_regulator_air_pressure_min?: number | null
    nozzle_regulator_air_pressure_max?: number | null
    cells_speed_min?: number | null
    cells_speed_max?: number | null
    injection_AB_start_position_min?: number | null
    injection_AB_start_position_max?: number | null
    injection_CD_start_position_min?: number | null
    injection_CD_start_position_max?: number | null
    injection_ABCD_end_position_min?: number | null
    injection_ABCD_end_position_max?: number | null
    tube_molding_start_position_min?: number | null
    tube_molding_start_position_max?: number | null
    tube_molding_end_position_min?: number | null
    tube_molding_end_position_max?: number | null
    polimerization_furnace_temperature_min?: number | null
    polimerization_furnace_temperature_max?: number | null
  }

  export type tube_parametersUncheckedCreateInput = {
    id?: number
    tube_record_id?: number | null
    press_speed_min?: number | null
    press_speed_max?: number | null
    molding_time_min?: number | null
    molding_time_max?: number | null
    turning_automate_speed_min?: number | null
    turning_automate_speed_max?: number | null
    annealing_furnace_temp_min?: number | null
    annealing_furnace_temp_max?: number | null
    cap_machine_speed_min?: number | null
    cap_machine_speed_max?: number | null
    cap_machine_air_pressure_min?: number | null
    cap_machine_air_pressure_max?: number | null
    grips_forward_min?: number | null
    grips_forward_max?: number | null
    grips_opening_left_min?: number | null
    grips_opening_left_max?: number | null
    grips_opening_right_min?: number | null
    grips_opening_right_max?: number | null
    grips_closing_min?: number | null
    grips_closing_max?: number | null
    injection_start_min?: number | null
    injection_start_max?: number | null
    injection_end_min?: number | null
    injection_end_max?: number | null
    tube_start_position_min?: number | null
    tube_start_position_max?: number | null
    tube_end_position_min?: number | null
    tube_end_position_max?: number | null
    padding_machine_speed_min?: number | null
    padding_machine_speed_max?: number | null
    padding_machine_air_pressure_min?: number | null
    padding_machine_air_pressure_max?: number | null
    padding_furnace_temp_min?: number | null
    padding_furnace_temp_max?: number | null
    offset_furnace_temp_min?: number | null
    offset_furnace_temp_max?: number | null
    printer_motor_speed_min?: number | null
    printer_motor_speed_max?: number | null
    holders_motor_speed_min?: number | null
    holders_motor_speed_max?: number | null
    station_motor_speed_min?: number | null
    station_motor_speed_max?: number | null
    ink_injection_time_min?: number | null
    ink_injection_time_max?: number | null
    lacquer_machine_speed_min?: number | null
    lacquer_machine_speed_max?: number | null
    lacquer_machine_air_pressure_min?: number | null
    lacquer_machine_air_pressure_max?: number | null
    feed_can_air_pressure_min?: number | null
    feed_can_air_pressure_max?: number | null
    nozzle_regulator_air_pressure_min?: number | null
    nozzle_regulator_air_pressure_max?: number | null
    cells_speed_min?: number | null
    cells_speed_max?: number | null
    injection_AB_start_position_min?: number | null
    injection_AB_start_position_max?: number | null
    injection_CD_start_position_min?: number | null
    injection_CD_start_position_max?: number | null
    injection_ABCD_end_position_min?: number | null
    injection_ABCD_end_position_max?: number | null
    tube_molding_start_position_min?: number | null
    tube_molding_start_position_max?: number | null
    tube_molding_end_position_min?: number | null
    tube_molding_end_position_max?: number | null
    polimerization_furnace_temperature_min?: number | null
    polimerization_furnace_temperature_max?: number | null
  }

  export type tube_parametersUpdateInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_min?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_max?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    grips_forward_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_forward_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    ink_injection_time_min?: NullableFloatFieldUpdateOperationsInput | number | null
    ink_injection_time_max?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cells_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cells_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_min?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_max?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tube_parametersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_min?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_max?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    grips_forward_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_forward_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    ink_injection_time_min?: NullableFloatFieldUpdateOperationsInput | number | null
    ink_injection_time_max?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cells_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cells_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_min?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_max?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tube_parametersCreateManyInput = {
    id?: number
    tube_record_id?: number | null
    press_speed_min?: number | null
    press_speed_max?: number | null
    molding_time_min?: number | null
    molding_time_max?: number | null
    turning_automate_speed_min?: number | null
    turning_automate_speed_max?: number | null
    annealing_furnace_temp_min?: number | null
    annealing_furnace_temp_max?: number | null
    cap_machine_speed_min?: number | null
    cap_machine_speed_max?: number | null
    cap_machine_air_pressure_min?: number | null
    cap_machine_air_pressure_max?: number | null
    grips_forward_min?: number | null
    grips_forward_max?: number | null
    grips_opening_left_min?: number | null
    grips_opening_left_max?: number | null
    grips_opening_right_min?: number | null
    grips_opening_right_max?: number | null
    grips_closing_min?: number | null
    grips_closing_max?: number | null
    injection_start_min?: number | null
    injection_start_max?: number | null
    injection_end_min?: number | null
    injection_end_max?: number | null
    tube_start_position_min?: number | null
    tube_start_position_max?: number | null
    tube_end_position_min?: number | null
    tube_end_position_max?: number | null
    padding_machine_speed_min?: number | null
    padding_machine_speed_max?: number | null
    padding_machine_air_pressure_min?: number | null
    padding_machine_air_pressure_max?: number | null
    padding_furnace_temp_min?: number | null
    padding_furnace_temp_max?: number | null
    offset_furnace_temp_min?: number | null
    offset_furnace_temp_max?: number | null
    printer_motor_speed_min?: number | null
    printer_motor_speed_max?: number | null
    holders_motor_speed_min?: number | null
    holders_motor_speed_max?: number | null
    station_motor_speed_min?: number | null
    station_motor_speed_max?: number | null
    ink_injection_time_min?: number | null
    ink_injection_time_max?: number | null
    lacquer_machine_speed_min?: number | null
    lacquer_machine_speed_max?: number | null
    lacquer_machine_air_pressure_min?: number | null
    lacquer_machine_air_pressure_max?: number | null
    feed_can_air_pressure_min?: number | null
    feed_can_air_pressure_max?: number | null
    nozzle_regulator_air_pressure_min?: number | null
    nozzle_regulator_air_pressure_max?: number | null
    cells_speed_min?: number | null
    cells_speed_max?: number | null
    injection_AB_start_position_min?: number | null
    injection_AB_start_position_max?: number | null
    injection_CD_start_position_min?: number | null
    injection_CD_start_position_max?: number | null
    injection_ABCD_end_position_min?: number | null
    injection_ABCD_end_position_max?: number | null
    tube_molding_start_position_min?: number | null
    tube_molding_start_position_max?: number | null
    tube_molding_end_position_min?: number | null
    tube_molding_end_position_max?: number | null
    polimerization_furnace_temperature_min?: number | null
    polimerization_furnace_temperature_max?: number | null
  }

  export type tube_parametersUpdateManyMutationInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_min?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_max?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    grips_forward_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_forward_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    ink_injection_time_min?: NullableFloatFieldUpdateOperationsInput | number | null
    ink_injection_time_max?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cells_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cells_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_min?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_max?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tube_parametersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    press_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_min?: NullableIntFieldUpdateOperationsInput | number | null
    molding_time_max?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    turning_automate_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    annealing_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    cap_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    grips_forward_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_forward_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_left_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_opening_right_max?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_min?: NullableIntFieldUpdateOperationsInput | number | null
    grips_closing_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_start_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_end_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    padding_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    padding_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_min?: NullableIntFieldUpdateOperationsInput | number | null
    offset_furnace_temp_max?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    printer_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    holders_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    station_motor_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    ink_injection_time_min?: NullableFloatFieldUpdateOperationsInput | number | null
    ink_injection_time_max?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    lacquer_machine_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    feed_can_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_min?: NullableFloatFieldUpdateOperationsInput | number | null
    nozzle_regulator_air_pressure_max?: NullableFloatFieldUpdateOperationsInput | number | null
    cells_speed_min?: NullableIntFieldUpdateOperationsInput | number | null
    cells_speed_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_AB_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_CD_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    injection_ABCD_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_start_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_min?: NullableIntFieldUpdateOperationsInput | number | null
    tube_molding_end_position_max?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_min?: NullableIntFieldUpdateOperationsInput | number | null
    polimerization_furnace_temperature_max?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tube_productsCreateInput = {
    code_1C?: string | null
    marking?: string | null
    name?: string | null
    tube_records?: tube_recordsCreateNestedManyWithoutTube_productsInput
    tube_specifications?: tube_specificationsCreateNestedManyWithoutTube_productsInput
  }

  export type tube_productsUncheckedCreateInput = {
    id?: number
    code_1C?: string | null
    marking?: string | null
    name?: string | null
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutTube_productsInput
    tube_specifications?: tube_specificationsUncheckedCreateNestedManyWithoutTube_productsInput
  }

  export type tube_productsUpdateInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUpdateManyWithoutTube_productsNestedInput
    tube_specifications?: tube_specificationsUpdateManyWithoutTube_productsNestedInput
  }

  export type tube_productsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUncheckedUpdateManyWithoutTube_productsNestedInput
    tube_specifications?: tube_specificationsUncheckedUpdateManyWithoutTube_productsNestedInput
  }

  export type tube_productsCreateManyInput = {
    id?: number
    code_1C?: string | null
    marking?: string | null
    name?: string | null
  }

  export type tube_productsUpdateManyMutationInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_productsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_recordsCreateInput = {
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    boils?: boilsCreateNestedOneWithoutTube_recordsInput
    tube_conveyors?: tube_conveyorsCreateNestedOneWithoutTube_recordsInput
    tube_products?: tube_productsCreateNestedOneWithoutTube_recordsInput
  }

  export type tube_recordsUncheckedCreateInput = {
    id?: number
    tube_product_id?: number | null
    tube_conveyor_id?: number | null
    boil_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsUpdateInput = {
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boils?: boilsUpdateOneWithoutTube_recordsNestedInput
    tube_conveyors?: tube_conveyorsUpdateOneWithoutTube_recordsNestedInput
    tube_products?: tube_productsUpdateOneWithoutTube_recordsNestedInput
  }

  export type tube_recordsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsCreateManyInput = {
    id?: number
    tube_product_id?: number | null
    tube_conveyor_id?: number | null
    boil_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsUpdateManyMutationInput = {
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_sessionsCreateInput = {
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_conveyors?: tube_conveyorsCreateNestedOneWithoutTube_sessionsInput
    employees?: employeesCreateNestedOneWithoutTube_sessionsInput
  }

  export type tube_sessionsUncheckedCreateInput = {
    id?: number
    conveyor_id?: number | null
    employee_id?: number | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_sessionsUpdateInput = {
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_conveyors?: tube_conveyorsUpdateOneWithoutTube_sessionsNestedInput
    employees?: employeesUpdateOneWithoutTube_sessionsNestedInput
  }

  export type tube_sessionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_sessionsCreateManyInput = {
    id?: number
    conveyor_id?: number | null
    employee_id?: number | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_sessionsUpdateManyMutationInput = {
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_sessionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_specificationsCreateInput = {
    createdAt: Date | string
    updatedAt: Date | string
    tube_materials?: tube_materialsCreateNestedOneWithoutTube_specificationsInput
    tube_products?: tube_productsCreateNestedOneWithoutTube_specificationsInput
  }

  export type tube_specificationsUncheckedCreateInput = {
    id?: number
    tube_product_id?: number | null
    tube_material_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_specificationsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_materials?: tube_materialsUpdateOneWithoutTube_specificationsNestedInput
    tube_products?: tube_productsUpdateOneWithoutTube_specificationsNestedInput
  }

  export type tube_specificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_specificationsCreateManyInput = {
    id?: number
    tube_product_id?: number | null
    tube_material_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_specificationsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_specificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesCreateInput = {
    roles: rolesCreateNestedOneWithoutUser_rolesInput
    users: usersCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateInput = {
    id?: number
    roleId: number
    userId: number
  }

  export type user_rolesUpdateInput = {
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
    users?: usersUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesCreateManyInput = {
    id?: number
    roleId: number
    userId: number
  }

  export type user_rolesUpdateManyMutationInput = {

  }

  export type user_rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateInput = {
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesCreateNestedManyWithoutUsersInput
    tokens?: tokensCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesUncheckedCreateNestedManyWithoutUsersInput
    tokens?: tokensUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUpdateManyWithoutUsersNestedInput
    tokens?: tokensUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUncheckedUpdateManyWithoutUsersNestedInput
    tokens?: tokensUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type usersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type workshopsCreateInput = {
    value: string
    records?: recordsCreateNestedManyWithoutWorkshopsInput
  }

  export type workshopsUncheckedCreateInput = {
    id?: number
    value: string
    records?: recordsUncheckedCreateNestedManyWithoutWorkshopsInput
  }

  export type workshopsUpdateInput = {
    value?: StringFieldUpdateOperationsInput | string
    records?: recordsUpdateManyWithoutWorkshopsNestedInput
  }

  export type workshopsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    records?: recordsUncheckedUpdateManyWithoutWorkshopsNestedInput
  }

  export type workshopsCreateManyInput = {
    id?: number
    value: string
  }

  export type workshopsUpdateManyMutationInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type workshopsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BatchsCountOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchsAvgOrderByAggregateInput = {
    BatchPK?: SortOrder
  }

  export type BatchsMaxOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchsMinOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BatchsSumOrderByAggregateInput = {
    BatchPK?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type TraceBatchesCountOrderByAggregateInput = {
    id?: SortOrder
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TraceBatchesAvgOrderByAggregateInput = {
    id?: SortOrder
    BatchPK?: SortOrder
  }

  export type TraceBatchesMaxOrderByAggregateInput = {
    id?: SortOrder
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TraceBatchesMinOrderByAggregateInput = {
    id?: SortOrder
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TraceBatchesSumOrderByAggregateInput = {
    id?: SortOrder
    BatchPK?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type api_errorsCountOrderByAggregateInput = {
    id?: SortOrder
    dto?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type api_errorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type api_errorsMaxOrderByAggregateInput = {
    id?: SortOrder
    dto?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type api_errorsMinOrderByAggregateInput = {
    id?: SortOrder
    dto?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type api_errorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RecordsListRelationFilter = {
    every?: recordsWhereInput
    some?: recordsWhereInput
    none?: recordsWhereInput
  }

  export type recordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type apparatusesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type apparatusesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type apparatusesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type apparatusesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type apparatusesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoilsListRelationFilter = {
    every?: boilsWhereInput
    some?: boilsWhereInput
    none?: boilsWhereInput
  }

  export type boilsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type basesCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    marking?: SortOrder
  }

  export type basesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type basesMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    marking?: SortOrder
  }

  export type basesMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    marking?: SortOrder
  }

  export type basesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type batchsCountOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type batchsAvgOrderByAggregateInput = {
    BatchPK?: SortOrder
  }

  export type batchsMaxOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type batchsMinOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type batchsSumOrderByAggregateInput = {
    BatchPK?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BasesNullableScalarRelationFilter = {
    is?: basesWhereInput | null
    isNot?: basesWhereInput | null
  }

  export type Semi_productsListRelationFilter = {
    every?: semi_productsWhereInput
    some?: semi_productsWhereInput
    none?: semi_productsWhereInput
  }

  export type Tube_recordsListRelationFilter = {
    every?: tube_recordsWhereInput
    some?: tube_recordsWhereInput
    none?: tube_recordsWhereInput
  }

  export type semi_productsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tube_recordsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type boilsCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    base_id?: SortOrder
    letter?: SortOrder
    year?: SortOrder
    number?: SortOrder
    plant_id?: SortOrder
  }

  export type boilsAvgOrderByAggregateInput = {
    id?: SortOrder
    base_id?: SortOrder
    year?: SortOrder
    number?: SortOrder
    plant_id?: SortOrder
  }

  export type boilsMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    base_id?: SortOrder
    letter?: SortOrder
    year?: SortOrder
    number?: SortOrder
    plant_id?: SortOrder
  }

  export type boilsMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    base_id?: SortOrder
    letter?: SortOrder
    year?: SortOrder
    number?: SortOrder
    plant_id?: SortOrder
  }

  export type boilsSumOrderByAggregateInput = {
    id?: SortOrder
    base_id?: SortOrder
    year?: SortOrder
    number?: SortOrder
    plant_id?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type cansCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type cansAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type cansMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type cansMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type cansSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type conveyorsCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    barcode?: SortOrder
  }

  export type conveyorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type conveyorsMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    barcode?: SortOrder
  }

  export type conveyorsMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    barcode?: SortOrder
  }

  export type conveyorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type dbo_BatchsCountOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dbo_BatchsAvgOrderByAggregateInput = {
    BatchPK?: SortOrder
  }

  export type dbo_BatchsMaxOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dbo_BatchsMinOrderByAggregateInput = {
    BatchPK?: SortOrder
    BatchName?: SortOrder
    BatchDate?: SortOrder
    Plant?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type dbo_BatchsSumOrderByAggregateInput = {
    BatchPK?: SortOrder
  }

  export type PlantsNullableScalarRelationFilter = {
    is?: plantsWhereInput | null
    isNot?: plantsWhereInput | null
  }

  export type docsCountOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type docsAvgOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type docsMaxOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type docsMinOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type docsSumOrderByAggregateInput = {
    id?: SortOrder
    plantId?: SortOrder
  }

  export type OccupationsNullableScalarRelationFilter = {
    is?: occupationsWhereInput | null
    isNot?: occupationsWhereInput | null
  }

  export type HistoriesListRelationFilter = {
    every?: historiesWhereInput
    some?: historiesWhereInput
    none?: historiesWhereInput
  }

  export type Tube_historiesListRelationFilter = {
    every?: tube_historiesWhereInput
    some?: tube_historiesWhereInput
    none?: tube_historiesWhereInput
  }

  export type Tube_sessionsListRelationFilter = {
    every?: tube_sessionsWhereInput
    some?: tube_sessionsWhereInput
    none?: tube_sessionsWhereInput
  }

  export type historiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tube_historiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tube_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type employeesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    occupationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type employeesAvgOrderByAggregateInput = {
    id?: SortOrder
    occupationId?: SortOrder
  }

  export type employeesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    occupationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type employeesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
    occupationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type employeesSumOrderByAggregateInput = {
    id?: SortOrder
    occupationId?: SortOrder
  }

  export type EmployeesNullableScalarRelationFilter = {
    is?: employeesWhereInput | null
    isNot?: employeesWhereInput | null
  }

  export type History_typesNullableScalarRelationFilter = {
    is?: history_typesWhereInput | null
    isNot?: history_typesWhereInput | null
  }

  export type RecordsNullableScalarRelationFilter = {
    is?: recordsWhereInput | null
    isNot?: recordsWhereInput | null
  }

  export type UsersNullableScalarRelationFilter = {
    is?: usersWhereInput | null
    isNot?: usersWhereInput | null
  }

  export type historiesCountOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    boil_id?: SortOrder
    historyTypeId?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note_id?: SortOrder
    plant_id?: SortOrder
  }

  export type historiesAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    boil_id?: SortOrder
    historyTypeId?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    note_id?: SortOrder
    plant_id?: SortOrder
  }

  export type historiesMaxOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    boil_id?: SortOrder
    historyTypeId?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note_id?: SortOrder
    plant_id?: SortOrder
  }

  export type historiesMinOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    boil_id?: SortOrder
    historyTypeId?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    note?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    note_id?: SortOrder
    plant_id?: SortOrder
  }

  export type historiesSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    boil_id?: SortOrder
    historyTypeId?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    note_id?: SortOrder
    plant_id?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type history_typesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    for_boil?: SortOrder
  }

  export type history_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type history_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    for_boil?: SortOrder
  }

  export type history_typesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
    for_boil?: SortOrder
  }

  export type history_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type Record_regulationsListRelationFilter = {
    every?: record_regulationsWhereInput
    some?: record_regulationsWhereInput
    none?: record_regulationsWhereInput
  }

  export type RegulationsListRelationFilter = {
    every?: regulationsWhereInput
    some?: regulationsWhereInput
    none?: regulationsWhereInput
  }

  export type record_regulationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type regulationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type marking_sampleCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type marking_sampleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type marking_sampleMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type marking_sampleMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type marking_sampleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type notesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type notesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type notesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type notesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type notesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EmployeesListRelationFilter = {
    every?: employeesWhereInput
    some?: employeesWhereInput
    none?: employeesWhereInput
  }

  export type employeesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type occupationsCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type occupationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type occupationsMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type occupationsMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type occupationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DocsListRelationFilter = {
    every?: docsWhereInput
    some?: docsWhereInput
    none?: docsWhereInput
  }

  export type docsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type plantsCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    abb?: SortOrder
  }

  export type plantsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type plantsMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    abb?: SortOrder
  }

  export type plantsMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    abb?: SortOrder
  }

  export type plantsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SeriesNullableScalarRelationFilter = {
    is?: seriesWhereInput | null
    isNot?: seriesWhereInput | null
  }

  export type productsCountOrderByAggregateInput = {
    id?: SortOrder
    code1C?: SortOrder
    marking?: SortOrder
    name?: SortOrder
    serieId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productsAvgOrderByAggregateInput = {
    id?: SortOrder
    serieId?: SortOrder
  }

  export type productsMaxOrderByAggregateInput = {
    id?: SortOrder
    code1C?: SortOrder
    marking?: SortOrder
    name?: SortOrder
    serieId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productsMinOrderByAggregateInput = {
    id?: SortOrder
    code1C?: SortOrder
    marking?: SortOrder
    name?: SortOrder
    serieId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type productsSumOrderByAggregateInput = {
    id?: SortOrder
    serieId?: SortOrder
  }

  export type Marking_sampleNullableScalarRelationFilter = {
    is?: marking_sampleWhereInput | null
    isNot?: marking_sampleWhereInput | null
  }

  export type record_regulationsCountOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    org_base_min_weight?: SortOrder
    org_base_max_weight?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    gasket?: SortOrder
    seal?: SortOrder
    technician_note?: SortOrder
    packaging_note?: SortOrder
    marking_sample_id?: SortOrder
    inc_color?: SortOrder
    marking_feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type record_regulationsAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    org_base_min_weight?: SortOrder
    org_base_max_weight?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    marking_sample_id?: SortOrder
  }

  export type record_regulationsMaxOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    org_base_min_weight?: SortOrder
    org_base_max_weight?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    gasket?: SortOrder
    seal?: SortOrder
    technician_note?: SortOrder
    packaging_note?: SortOrder
    marking_sample_id?: SortOrder
    inc_color?: SortOrder
    marking_feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type record_regulationsMinOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    org_base_min_weight?: SortOrder
    org_base_max_weight?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    gasket?: SortOrder
    seal?: SortOrder
    technician_note?: SortOrder
    packaging_note?: SortOrder
    marking_sample_id?: SortOrder
    inc_color?: SortOrder
    marking_feature?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type record_regulationsSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    org_base_min_weight?: SortOrder
    org_base_max_weight?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    marking_sample_id?: SortOrder
  }

  export type ApparatusesNullableScalarRelationFilter = {
    is?: apparatusesWhereInput | null
    isNot?: apparatusesWhereInput | null
  }

  export type CansNullableScalarRelationFilter = {
    is?: cansWhereInput | null
    isNot?: cansWhereInput | null
  }

  export type ConveyorsNullableScalarRelationFilter = {
    is?: conveyorsWhereInput | null
    isNot?: conveyorsWhereInput | null
  }

  export type DocsNullableScalarRelationFilter = {
    is?: docsWhereInput | null
    isNot?: docsWhereInput | null
  }

  export type ProductsNullableScalarRelationFilter = {
    is?: productsWhereInput | null
    isNot?: productsWhereInput | null
  }

  export type WorkshopsNullableScalarRelationFilter = {
    is?: workshopsWhereInput | null
    isNot?: workshopsWhereInput | null
  }

  export type BoilsNullableScalarRelationFilter = {
    is?: boilsWhereInput | null
    isNot?: boilsWhereInput | null
  }

  export type recordsCountOrderByAggregateInput = {
    id?: SortOrder
    doc_id?: SortOrder
    productId?: SortOrder
    boilId?: SortOrder
    apparatusId?: SortOrder
    canId?: SortOrder
    conveyorId?: SortOrder
    plan?: SortOrder
    bbf?: SortOrder
    note?: SortOrder
    workshopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSet?: SortOrder
    organic_base_id?: SortOrder
    water_base_id?: SortOrder
    dm?: SortOrder
  }

  export type recordsAvgOrderByAggregateInput = {
    id?: SortOrder
    doc_id?: SortOrder
    productId?: SortOrder
    boilId?: SortOrder
    apparatusId?: SortOrder
    canId?: SortOrder
    conveyorId?: SortOrder
    plan?: SortOrder
    workshopId?: SortOrder
    organic_base_id?: SortOrder
    water_base_id?: SortOrder
  }

  export type recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    doc_id?: SortOrder
    productId?: SortOrder
    boilId?: SortOrder
    apparatusId?: SortOrder
    canId?: SortOrder
    conveyorId?: SortOrder
    plan?: SortOrder
    bbf?: SortOrder
    note?: SortOrder
    workshopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSet?: SortOrder
    organic_base_id?: SortOrder
    water_base_id?: SortOrder
    dm?: SortOrder
  }

  export type recordsMinOrderByAggregateInput = {
    id?: SortOrder
    doc_id?: SortOrder
    productId?: SortOrder
    boilId?: SortOrder
    apparatusId?: SortOrder
    canId?: SortOrder
    conveyorId?: SortOrder
    plan?: SortOrder
    bbf?: SortOrder
    note?: SortOrder
    workshopId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isSet?: SortOrder
    organic_base_id?: SortOrder
    water_base_id?: SortOrder
    dm?: SortOrder
  }

  export type recordsSumOrderByAggregateInput = {
    id?: SortOrder
    doc_id?: SortOrder
    productId?: SortOrder
    boilId?: SortOrder
    apparatusId?: SortOrder
    canId?: SortOrder
    conveyorId?: SortOrder
    plan?: SortOrder
    workshopId?: SortOrder
    organic_base_id?: SortOrder
    water_base_id?: SortOrder
  }

  export type regulationsCountOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    gasket?: SortOrder
    seal?: SortOrder
    technician_note?: SortOrder
    packaging_note?: SortOrder
    marking_sample_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type regulationsAvgOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    marking_sample_id?: SortOrder
  }

  export type regulationsMaxOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    gasket?: SortOrder
    seal?: SortOrder
    technician_note?: SortOrder
    packaging_note?: SortOrder
    marking_sample_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type regulationsMinOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    gasket?: SortOrder
    seal?: SortOrder
    technician_note?: SortOrder
    packaging_note?: SortOrder
    marking_sample_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type regulationsSumOrderByAggregateInput = {
    id?: SortOrder
    product_id?: SortOrder
    water_base_min_weight?: SortOrder
    water_base_max_weight?: SortOrder
    per_box?: SortOrder
    box_per_row?: SortOrder
    row_on_pallet?: SortOrder
    marking_sample_id?: SortOrder
  }

  export type User_rolesListRelationFilter = {
    every?: user_rolesWhereInput
    some?: user_rolesWhereInput
    none?: user_rolesWhereInput
  }

  export type user_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type semi_productsCountOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    product_id?: SortOrder
    boil_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type semi_productsAvgOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    product_id?: SortOrder
    boil_id?: SortOrder
  }

  export type semi_productsMaxOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    product_id?: SortOrder
    boil_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type semi_productsMinOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    product_id?: SortOrder
    boil_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type semi_productsSumOrderByAggregateInput = {
    id?: SortOrder
    record_id?: SortOrder
    product_id?: SortOrder
    boil_id?: SortOrder
  }

  export type ProductsListRelationFilter = {
    every?: productsWhereInput
    some?: productsWhereInput
    none?: productsWhereInput
  }

  export type productsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type seriesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type seriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type seriesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type seriesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type seriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type signalsCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type signalsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type signalsMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type signalsMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type signalsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tokensCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokensAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type tokensMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokensMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tokensSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type Tube_conveyor_postsNullableScalarRelationFilter = {
    is?: tube_conveyor_postsWhereInput | null
    isNot?: tube_conveyor_postsWhereInput | null
  }

  export type Tube_materialsNullableScalarRelationFilter = {
    is?: tube_materialsWhereInput | null
    isNot?: tube_materialsWhereInput | null
  }

  export type tube_assemblyCountOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_material_id?: SortOrder
    tube_conveyor_post_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_assemblyAvgOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_material_id?: SortOrder
    tube_conveyor_post_id?: SortOrder
  }

  export type tube_assemblyMaxOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_material_id?: SortOrder
    tube_conveyor_post_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_assemblyMinOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_material_id?: SortOrder
    tube_conveyor_post_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_assemblySumOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_material_id?: SortOrder
    tube_conveyor_post_id?: SortOrder
  }

  export type Tube_assemblyListRelationFilter = {
    every?: tube_assemblyWhereInput
    some?: tube_assemblyWhereInput
    none?: tube_assemblyWhereInput
  }

  export type tube_assemblyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tube_conveyor_postsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type tube_conveyor_postsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_conveyor_postsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type tube_conveyor_postsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type tube_conveyor_postsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_conveyorsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
  }

  export type tube_conveyorsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_conveyorsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
  }

  export type tube_conveyorsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    barcode?: SortOrder
  }

  export type tube_conveyorsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Tube_histories_notesNullableScalarRelationFilter = {
    is?: tube_histories_notesWhereInput | null
    isNot?: tube_histories_notesWhereInput | null
  }

  export type Tube_history_typesNullableScalarRelationFilter = {
    is?: tube_history_typesWhereInput | null
    isNot?: tube_history_typesWhereInput | null
  }

  export type tube_historiesCountOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_history_type_id?: SortOrder
    employee_id?: SortOrder
    note?: SortOrder
    tube_history_note_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_historiesAvgOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_history_type_id?: SortOrder
    employee_id?: SortOrder
    tube_history_note_id?: SortOrder
  }

  export type tube_historiesMaxOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_history_type_id?: SortOrder
    employee_id?: SortOrder
    note?: SortOrder
    tube_history_note_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_historiesMinOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_history_type_id?: SortOrder
    employee_id?: SortOrder
    note?: SortOrder
    tube_history_note_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_historiesSumOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    tube_history_type_id?: SortOrder
    employee_id?: SortOrder
    tube_history_note_id?: SortOrder
  }

  export type tube_histories_notesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type tube_histories_notesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_histories_notesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type tube_histories_notesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type tube_histories_notesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_history_typesCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type tube_history_typesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_history_typesMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type tube_history_typesMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    description?: SortOrder
  }

  export type tube_history_typesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Tube_specificationsListRelationFilter = {
    every?: tube_specificationsWhereInput
    some?: tube_specificationsWhereInput
    none?: tube_specificationsWhereInput
  }

  export type tube_specificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tube_materialsCountOrderByAggregateInput = {
    id?: SortOrder
    code_1C?: SortOrder
    name?: SortOrder
  }

  export type tube_materialsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_materialsMaxOrderByAggregateInput = {
    id?: SortOrder
    code_1C?: SortOrder
    name?: SortOrder
  }

  export type tube_materialsMinOrderByAggregateInput = {
    id?: SortOrder
    code_1C?: SortOrder
    name?: SortOrder
  }

  export type tube_materialsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type tube_parametersCountOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    press_speed_min?: SortOrder
    press_speed_max?: SortOrder
    molding_time_min?: SortOrder
    molding_time_max?: SortOrder
    turning_automate_speed_min?: SortOrder
    turning_automate_speed_max?: SortOrder
    annealing_furnace_temp_min?: SortOrder
    annealing_furnace_temp_max?: SortOrder
    cap_machine_speed_min?: SortOrder
    cap_machine_speed_max?: SortOrder
    cap_machine_air_pressure_min?: SortOrder
    cap_machine_air_pressure_max?: SortOrder
    grips_forward_min?: SortOrder
    grips_forward_max?: SortOrder
    grips_opening_left_min?: SortOrder
    grips_opening_left_max?: SortOrder
    grips_opening_right_min?: SortOrder
    grips_opening_right_max?: SortOrder
    grips_closing_min?: SortOrder
    grips_closing_max?: SortOrder
    injection_start_min?: SortOrder
    injection_start_max?: SortOrder
    injection_end_min?: SortOrder
    injection_end_max?: SortOrder
    tube_start_position_min?: SortOrder
    tube_start_position_max?: SortOrder
    tube_end_position_min?: SortOrder
    tube_end_position_max?: SortOrder
    padding_machine_speed_min?: SortOrder
    padding_machine_speed_max?: SortOrder
    padding_machine_air_pressure_min?: SortOrder
    padding_machine_air_pressure_max?: SortOrder
    padding_furnace_temp_min?: SortOrder
    padding_furnace_temp_max?: SortOrder
    offset_furnace_temp_min?: SortOrder
    offset_furnace_temp_max?: SortOrder
    printer_motor_speed_min?: SortOrder
    printer_motor_speed_max?: SortOrder
    holders_motor_speed_min?: SortOrder
    holders_motor_speed_max?: SortOrder
    station_motor_speed_min?: SortOrder
    station_motor_speed_max?: SortOrder
    ink_injection_time_min?: SortOrder
    ink_injection_time_max?: SortOrder
    lacquer_machine_speed_min?: SortOrder
    lacquer_machine_speed_max?: SortOrder
    lacquer_machine_air_pressure_min?: SortOrder
    lacquer_machine_air_pressure_max?: SortOrder
    feed_can_air_pressure_min?: SortOrder
    feed_can_air_pressure_max?: SortOrder
    nozzle_regulator_air_pressure_min?: SortOrder
    nozzle_regulator_air_pressure_max?: SortOrder
    cells_speed_min?: SortOrder
    cells_speed_max?: SortOrder
    injection_AB_start_position_min?: SortOrder
    injection_AB_start_position_max?: SortOrder
    injection_CD_start_position_min?: SortOrder
    injection_CD_start_position_max?: SortOrder
    injection_ABCD_end_position_min?: SortOrder
    injection_ABCD_end_position_max?: SortOrder
    tube_molding_start_position_min?: SortOrder
    tube_molding_start_position_max?: SortOrder
    tube_molding_end_position_min?: SortOrder
    tube_molding_end_position_max?: SortOrder
    polimerization_furnace_temperature_min?: SortOrder
    polimerization_furnace_temperature_max?: SortOrder
  }

  export type tube_parametersAvgOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    press_speed_min?: SortOrder
    press_speed_max?: SortOrder
    molding_time_min?: SortOrder
    molding_time_max?: SortOrder
    turning_automate_speed_min?: SortOrder
    turning_automate_speed_max?: SortOrder
    annealing_furnace_temp_min?: SortOrder
    annealing_furnace_temp_max?: SortOrder
    cap_machine_speed_min?: SortOrder
    cap_machine_speed_max?: SortOrder
    cap_machine_air_pressure_min?: SortOrder
    cap_machine_air_pressure_max?: SortOrder
    grips_forward_min?: SortOrder
    grips_forward_max?: SortOrder
    grips_opening_left_min?: SortOrder
    grips_opening_left_max?: SortOrder
    grips_opening_right_min?: SortOrder
    grips_opening_right_max?: SortOrder
    grips_closing_min?: SortOrder
    grips_closing_max?: SortOrder
    injection_start_min?: SortOrder
    injection_start_max?: SortOrder
    injection_end_min?: SortOrder
    injection_end_max?: SortOrder
    tube_start_position_min?: SortOrder
    tube_start_position_max?: SortOrder
    tube_end_position_min?: SortOrder
    tube_end_position_max?: SortOrder
    padding_machine_speed_min?: SortOrder
    padding_machine_speed_max?: SortOrder
    padding_machine_air_pressure_min?: SortOrder
    padding_machine_air_pressure_max?: SortOrder
    padding_furnace_temp_min?: SortOrder
    padding_furnace_temp_max?: SortOrder
    offset_furnace_temp_min?: SortOrder
    offset_furnace_temp_max?: SortOrder
    printer_motor_speed_min?: SortOrder
    printer_motor_speed_max?: SortOrder
    holders_motor_speed_min?: SortOrder
    holders_motor_speed_max?: SortOrder
    station_motor_speed_min?: SortOrder
    station_motor_speed_max?: SortOrder
    ink_injection_time_min?: SortOrder
    ink_injection_time_max?: SortOrder
    lacquer_machine_speed_min?: SortOrder
    lacquer_machine_speed_max?: SortOrder
    lacquer_machine_air_pressure_min?: SortOrder
    lacquer_machine_air_pressure_max?: SortOrder
    feed_can_air_pressure_min?: SortOrder
    feed_can_air_pressure_max?: SortOrder
    nozzle_regulator_air_pressure_min?: SortOrder
    nozzle_regulator_air_pressure_max?: SortOrder
    cells_speed_min?: SortOrder
    cells_speed_max?: SortOrder
    injection_AB_start_position_min?: SortOrder
    injection_AB_start_position_max?: SortOrder
    injection_CD_start_position_min?: SortOrder
    injection_CD_start_position_max?: SortOrder
    injection_ABCD_end_position_min?: SortOrder
    injection_ABCD_end_position_max?: SortOrder
    tube_molding_start_position_min?: SortOrder
    tube_molding_start_position_max?: SortOrder
    tube_molding_end_position_min?: SortOrder
    tube_molding_end_position_max?: SortOrder
    polimerization_furnace_temperature_min?: SortOrder
    polimerization_furnace_temperature_max?: SortOrder
  }

  export type tube_parametersMaxOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    press_speed_min?: SortOrder
    press_speed_max?: SortOrder
    molding_time_min?: SortOrder
    molding_time_max?: SortOrder
    turning_automate_speed_min?: SortOrder
    turning_automate_speed_max?: SortOrder
    annealing_furnace_temp_min?: SortOrder
    annealing_furnace_temp_max?: SortOrder
    cap_machine_speed_min?: SortOrder
    cap_machine_speed_max?: SortOrder
    cap_machine_air_pressure_min?: SortOrder
    cap_machine_air_pressure_max?: SortOrder
    grips_forward_min?: SortOrder
    grips_forward_max?: SortOrder
    grips_opening_left_min?: SortOrder
    grips_opening_left_max?: SortOrder
    grips_opening_right_min?: SortOrder
    grips_opening_right_max?: SortOrder
    grips_closing_min?: SortOrder
    grips_closing_max?: SortOrder
    injection_start_min?: SortOrder
    injection_start_max?: SortOrder
    injection_end_min?: SortOrder
    injection_end_max?: SortOrder
    tube_start_position_min?: SortOrder
    tube_start_position_max?: SortOrder
    tube_end_position_min?: SortOrder
    tube_end_position_max?: SortOrder
    padding_machine_speed_min?: SortOrder
    padding_machine_speed_max?: SortOrder
    padding_machine_air_pressure_min?: SortOrder
    padding_machine_air_pressure_max?: SortOrder
    padding_furnace_temp_min?: SortOrder
    padding_furnace_temp_max?: SortOrder
    offset_furnace_temp_min?: SortOrder
    offset_furnace_temp_max?: SortOrder
    printer_motor_speed_min?: SortOrder
    printer_motor_speed_max?: SortOrder
    holders_motor_speed_min?: SortOrder
    holders_motor_speed_max?: SortOrder
    station_motor_speed_min?: SortOrder
    station_motor_speed_max?: SortOrder
    ink_injection_time_min?: SortOrder
    ink_injection_time_max?: SortOrder
    lacquer_machine_speed_min?: SortOrder
    lacquer_machine_speed_max?: SortOrder
    lacquer_machine_air_pressure_min?: SortOrder
    lacquer_machine_air_pressure_max?: SortOrder
    feed_can_air_pressure_min?: SortOrder
    feed_can_air_pressure_max?: SortOrder
    nozzle_regulator_air_pressure_min?: SortOrder
    nozzle_regulator_air_pressure_max?: SortOrder
    cells_speed_min?: SortOrder
    cells_speed_max?: SortOrder
    injection_AB_start_position_min?: SortOrder
    injection_AB_start_position_max?: SortOrder
    injection_CD_start_position_min?: SortOrder
    injection_CD_start_position_max?: SortOrder
    injection_ABCD_end_position_min?: SortOrder
    injection_ABCD_end_position_max?: SortOrder
    tube_molding_start_position_min?: SortOrder
    tube_molding_start_position_max?: SortOrder
    tube_molding_end_position_min?: SortOrder
    tube_molding_end_position_max?: SortOrder
    polimerization_furnace_temperature_min?: SortOrder
    polimerization_furnace_temperature_max?: SortOrder
  }

  export type tube_parametersMinOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    press_speed_min?: SortOrder
    press_speed_max?: SortOrder
    molding_time_min?: SortOrder
    molding_time_max?: SortOrder
    turning_automate_speed_min?: SortOrder
    turning_automate_speed_max?: SortOrder
    annealing_furnace_temp_min?: SortOrder
    annealing_furnace_temp_max?: SortOrder
    cap_machine_speed_min?: SortOrder
    cap_machine_speed_max?: SortOrder
    cap_machine_air_pressure_min?: SortOrder
    cap_machine_air_pressure_max?: SortOrder
    grips_forward_min?: SortOrder
    grips_forward_max?: SortOrder
    grips_opening_left_min?: SortOrder
    grips_opening_left_max?: SortOrder
    grips_opening_right_min?: SortOrder
    grips_opening_right_max?: SortOrder
    grips_closing_min?: SortOrder
    grips_closing_max?: SortOrder
    injection_start_min?: SortOrder
    injection_start_max?: SortOrder
    injection_end_min?: SortOrder
    injection_end_max?: SortOrder
    tube_start_position_min?: SortOrder
    tube_start_position_max?: SortOrder
    tube_end_position_min?: SortOrder
    tube_end_position_max?: SortOrder
    padding_machine_speed_min?: SortOrder
    padding_machine_speed_max?: SortOrder
    padding_machine_air_pressure_min?: SortOrder
    padding_machine_air_pressure_max?: SortOrder
    padding_furnace_temp_min?: SortOrder
    padding_furnace_temp_max?: SortOrder
    offset_furnace_temp_min?: SortOrder
    offset_furnace_temp_max?: SortOrder
    printer_motor_speed_min?: SortOrder
    printer_motor_speed_max?: SortOrder
    holders_motor_speed_min?: SortOrder
    holders_motor_speed_max?: SortOrder
    station_motor_speed_min?: SortOrder
    station_motor_speed_max?: SortOrder
    ink_injection_time_min?: SortOrder
    ink_injection_time_max?: SortOrder
    lacquer_machine_speed_min?: SortOrder
    lacquer_machine_speed_max?: SortOrder
    lacquer_machine_air_pressure_min?: SortOrder
    lacquer_machine_air_pressure_max?: SortOrder
    feed_can_air_pressure_min?: SortOrder
    feed_can_air_pressure_max?: SortOrder
    nozzle_regulator_air_pressure_min?: SortOrder
    nozzle_regulator_air_pressure_max?: SortOrder
    cells_speed_min?: SortOrder
    cells_speed_max?: SortOrder
    injection_AB_start_position_min?: SortOrder
    injection_AB_start_position_max?: SortOrder
    injection_CD_start_position_min?: SortOrder
    injection_CD_start_position_max?: SortOrder
    injection_ABCD_end_position_min?: SortOrder
    injection_ABCD_end_position_max?: SortOrder
    tube_molding_start_position_min?: SortOrder
    tube_molding_start_position_max?: SortOrder
    tube_molding_end_position_min?: SortOrder
    tube_molding_end_position_max?: SortOrder
    polimerization_furnace_temperature_min?: SortOrder
    polimerization_furnace_temperature_max?: SortOrder
  }

  export type tube_parametersSumOrderByAggregateInput = {
    id?: SortOrder
    tube_record_id?: SortOrder
    press_speed_min?: SortOrder
    press_speed_max?: SortOrder
    molding_time_min?: SortOrder
    molding_time_max?: SortOrder
    turning_automate_speed_min?: SortOrder
    turning_automate_speed_max?: SortOrder
    annealing_furnace_temp_min?: SortOrder
    annealing_furnace_temp_max?: SortOrder
    cap_machine_speed_min?: SortOrder
    cap_machine_speed_max?: SortOrder
    cap_machine_air_pressure_min?: SortOrder
    cap_machine_air_pressure_max?: SortOrder
    grips_forward_min?: SortOrder
    grips_forward_max?: SortOrder
    grips_opening_left_min?: SortOrder
    grips_opening_left_max?: SortOrder
    grips_opening_right_min?: SortOrder
    grips_opening_right_max?: SortOrder
    grips_closing_min?: SortOrder
    grips_closing_max?: SortOrder
    injection_start_min?: SortOrder
    injection_start_max?: SortOrder
    injection_end_min?: SortOrder
    injection_end_max?: SortOrder
    tube_start_position_min?: SortOrder
    tube_start_position_max?: SortOrder
    tube_end_position_min?: SortOrder
    tube_end_position_max?: SortOrder
    padding_machine_speed_min?: SortOrder
    padding_machine_speed_max?: SortOrder
    padding_machine_air_pressure_min?: SortOrder
    padding_machine_air_pressure_max?: SortOrder
    padding_furnace_temp_min?: SortOrder
    padding_furnace_temp_max?: SortOrder
    offset_furnace_temp_min?: SortOrder
    offset_furnace_temp_max?: SortOrder
    printer_motor_speed_min?: SortOrder
    printer_motor_speed_max?: SortOrder
    holders_motor_speed_min?: SortOrder
    holders_motor_speed_max?: SortOrder
    station_motor_speed_min?: SortOrder
    station_motor_speed_max?: SortOrder
    ink_injection_time_min?: SortOrder
    ink_injection_time_max?: SortOrder
    lacquer_machine_speed_min?: SortOrder
    lacquer_machine_speed_max?: SortOrder
    lacquer_machine_air_pressure_min?: SortOrder
    lacquer_machine_air_pressure_max?: SortOrder
    feed_can_air_pressure_min?: SortOrder
    feed_can_air_pressure_max?: SortOrder
    nozzle_regulator_air_pressure_min?: SortOrder
    nozzle_regulator_air_pressure_max?: SortOrder
    cells_speed_min?: SortOrder
    cells_speed_max?: SortOrder
    injection_AB_start_position_min?: SortOrder
    injection_AB_start_position_max?: SortOrder
    injection_CD_start_position_min?: SortOrder
    injection_CD_start_position_max?: SortOrder
    injection_ABCD_end_position_min?: SortOrder
    injection_ABCD_end_position_max?: SortOrder
    tube_molding_start_position_min?: SortOrder
    tube_molding_start_position_max?: SortOrder
    tube_molding_end_position_min?: SortOrder
    tube_molding_end_position_max?: SortOrder
    polimerization_furnace_temperature_min?: SortOrder
    polimerization_furnace_temperature_max?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type tube_productsCountOrderByAggregateInput = {
    id?: SortOrder
    code_1C?: SortOrder
    marking?: SortOrder
    name?: SortOrder
  }

  export type tube_productsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tube_productsMaxOrderByAggregateInput = {
    id?: SortOrder
    code_1C?: SortOrder
    marking?: SortOrder
    name?: SortOrder
  }

  export type tube_productsMinOrderByAggregateInput = {
    id?: SortOrder
    code_1C?: SortOrder
    marking?: SortOrder
    name?: SortOrder
  }

  export type tube_productsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Tube_conveyorsNullableScalarRelationFilter = {
    is?: tube_conveyorsWhereInput | null
    isNot?: tube_conveyorsWhereInput | null
  }

  export type Tube_productsNullableScalarRelationFilter = {
    is?: tube_productsWhereInput | null
    isNot?: tube_productsWhereInput | null
  }

  export type tube_recordsCountOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_conveyor_id?: SortOrder
    boil_id?: SortOrder
    plan?: SortOrder
    start_date?: SortOrder
    active?: SortOrder
    finished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_recordsAvgOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_conveyor_id?: SortOrder
    boil_id?: SortOrder
    plan?: SortOrder
  }

  export type tube_recordsMaxOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_conveyor_id?: SortOrder
    boil_id?: SortOrder
    plan?: SortOrder
    start_date?: SortOrder
    active?: SortOrder
    finished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_recordsMinOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_conveyor_id?: SortOrder
    boil_id?: SortOrder
    plan?: SortOrder
    start_date?: SortOrder
    active?: SortOrder
    finished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_recordsSumOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_conveyor_id?: SortOrder
    boil_id?: SortOrder
    plan?: SortOrder
  }

  export type tube_sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    conveyor_id?: SortOrder
    employee_id?: SortOrder
    finished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_sessionsAvgOrderByAggregateInput = {
    id?: SortOrder
    conveyor_id?: SortOrder
    employee_id?: SortOrder
  }

  export type tube_sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    conveyor_id?: SortOrder
    employee_id?: SortOrder
    finished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    conveyor_id?: SortOrder
    employee_id?: SortOrder
    finished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_sessionsSumOrderByAggregateInput = {
    id?: SortOrder
    conveyor_id?: SortOrder
    employee_id?: SortOrder
  }

  export type tube_specificationsCountOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_material_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_specificationsAvgOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_material_id?: SortOrder
  }

  export type tube_specificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_material_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_specificationsMinOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_material_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type tube_specificationsSumOrderByAggregateInput = {
    id?: SortOrder
    tube_product_id?: SortOrder
    tube_material_id?: SortOrder
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type user_rolesRoleIdUserIdCompoundUniqueInput = {
    roleId: number
    userId: number
  }

  export type user_rolesCountOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
  }

  export type user_rolesAvgOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
  }

  export type user_rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
  }

  export type user_rolesMinOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
  }

  export type user_rolesSumOrderByAggregateInput = {
    id?: SortOrder
    roleId?: SortOrder
    userId?: SortOrder
  }

  export type TokensListRelationFilter = {
    every?: tokensWhereInput
    some?: tokensWhereInput
    none?: tokensWhereInput
  }

  export type tokensOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    banned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    banned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    banned?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type workshopsCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type workshopsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type workshopsMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type workshopsMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
  }

  export type workshopsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type recordsCreateNestedManyWithoutApparatusesInput = {
    create?: XOR<recordsCreateWithoutApparatusesInput, recordsUncheckedCreateWithoutApparatusesInput> | recordsCreateWithoutApparatusesInput[] | recordsUncheckedCreateWithoutApparatusesInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutApparatusesInput | recordsCreateOrConnectWithoutApparatusesInput[]
    createMany?: recordsCreateManyApparatusesInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUncheckedCreateNestedManyWithoutApparatusesInput = {
    create?: XOR<recordsCreateWithoutApparatusesInput, recordsUncheckedCreateWithoutApparatusesInput> | recordsCreateWithoutApparatusesInput[] | recordsUncheckedCreateWithoutApparatusesInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutApparatusesInput | recordsCreateOrConnectWithoutApparatusesInput[]
    createMany?: recordsCreateManyApparatusesInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUpdateManyWithoutApparatusesNestedInput = {
    create?: XOR<recordsCreateWithoutApparatusesInput, recordsUncheckedCreateWithoutApparatusesInput> | recordsCreateWithoutApparatusesInput[] | recordsUncheckedCreateWithoutApparatusesInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutApparatusesInput | recordsCreateOrConnectWithoutApparatusesInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutApparatusesInput | recordsUpsertWithWhereUniqueWithoutApparatusesInput[]
    createMany?: recordsCreateManyApparatusesInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutApparatusesInput | recordsUpdateWithWhereUniqueWithoutApparatusesInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutApparatusesInput | recordsUpdateManyWithWhereWithoutApparatusesInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type recordsUncheckedUpdateManyWithoutApparatusesNestedInput = {
    create?: XOR<recordsCreateWithoutApparatusesInput, recordsUncheckedCreateWithoutApparatusesInput> | recordsCreateWithoutApparatusesInput[] | recordsUncheckedCreateWithoutApparatusesInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutApparatusesInput | recordsCreateOrConnectWithoutApparatusesInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutApparatusesInput | recordsUpsertWithWhereUniqueWithoutApparatusesInput[]
    createMany?: recordsCreateManyApparatusesInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutApparatusesInput | recordsUpdateWithWhereUniqueWithoutApparatusesInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutApparatusesInput | recordsUpdateManyWithWhereWithoutApparatusesInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type boilsCreateNestedManyWithoutBasesInput = {
    create?: XOR<boilsCreateWithoutBasesInput, boilsUncheckedCreateWithoutBasesInput> | boilsCreateWithoutBasesInput[] | boilsUncheckedCreateWithoutBasesInput[]
    connectOrCreate?: boilsCreateOrConnectWithoutBasesInput | boilsCreateOrConnectWithoutBasesInput[]
    createMany?: boilsCreateManyBasesInputEnvelope
    connect?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
  }

  export type boilsUncheckedCreateNestedManyWithoutBasesInput = {
    create?: XOR<boilsCreateWithoutBasesInput, boilsUncheckedCreateWithoutBasesInput> | boilsCreateWithoutBasesInput[] | boilsUncheckedCreateWithoutBasesInput[]
    connectOrCreate?: boilsCreateOrConnectWithoutBasesInput | boilsCreateOrConnectWithoutBasesInput[]
    createMany?: boilsCreateManyBasesInputEnvelope
    connect?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
  }

  export type boilsUpdateManyWithoutBasesNestedInput = {
    create?: XOR<boilsCreateWithoutBasesInput, boilsUncheckedCreateWithoutBasesInput> | boilsCreateWithoutBasesInput[] | boilsUncheckedCreateWithoutBasesInput[]
    connectOrCreate?: boilsCreateOrConnectWithoutBasesInput | boilsCreateOrConnectWithoutBasesInput[]
    upsert?: boilsUpsertWithWhereUniqueWithoutBasesInput | boilsUpsertWithWhereUniqueWithoutBasesInput[]
    createMany?: boilsCreateManyBasesInputEnvelope
    set?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    disconnect?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    delete?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    connect?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    update?: boilsUpdateWithWhereUniqueWithoutBasesInput | boilsUpdateWithWhereUniqueWithoutBasesInput[]
    updateMany?: boilsUpdateManyWithWhereWithoutBasesInput | boilsUpdateManyWithWhereWithoutBasesInput[]
    deleteMany?: boilsScalarWhereInput | boilsScalarWhereInput[]
  }

  export type boilsUncheckedUpdateManyWithoutBasesNestedInput = {
    create?: XOR<boilsCreateWithoutBasesInput, boilsUncheckedCreateWithoutBasesInput> | boilsCreateWithoutBasesInput[] | boilsUncheckedCreateWithoutBasesInput[]
    connectOrCreate?: boilsCreateOrConnectWithoutBasesInput | boilsCreateOrConnectWithoutBasesInput[]
    upsert?: boilsUpsertWithWhereUniqueWithoutBasesInput | boilsUpsertWithWhereUniqueWithoutBasesInput[]
    createMany?: boilsCreateManyBasesInputEnvelope
    set?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    disconnect?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    delete?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    connect?: boilsWhereUniqueInput | boilsWhereUniqueInput[]
    update?: boilsUpdateWithWhereUniqueWithoutBasesInput | boilsUpdateWithWhereUniqueWithoutBasesInput[]
    updateMany?: boilsUpdateManyWithWhereWithoutBasesInput | boilsUpdateManyWithWhereWithoutBasesInput[]
    deleteMany?: boilsScalarWhereInput | boilsScalarWhereInput[]
  }

  export type basesCreateNestedOneWithoutBoilsInput = {
    create?: XOR<basesCreateWithoutBoilsInput, basesUncheckedCreateWithoutBoilsInput>
    connectOrCreate?: basesCreateOrConnectWithoutBoilsInput
    connect?: basesWhereUniqueInput
  }

  export type semi_productsCreateNestedManyWithoutBoilsInput = {
    create?: XOR<semi_productsCreateWithoutBoilsInput, semi_productsUncheckedCreateWithoutBoilsInput> | semi_productsCreateWithoutBoilsInput[] | semi_productsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutBoilsInput | semi_productsCreateOrConnectWithoutBoilsInput[]
    createMany?: semi_productsCreateManyBoilsInputEnvelope
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
  }

  export type tube_recordsCreateNestedManyWithoutBoilsInput = {
    create?: XOR<tube_recordsCreateWithoutBoilsInput, tube_recordsUncheckedCreateWithoutBoilsInput> | tube_recordsCreateWithoutBoilsInput[] | tube_recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutBoilsInput | tube_recordsCreateOrConnectWithoutBoilsInput[]
    createMany?: tube_recordsCreateManyBoilsInputEnvelope
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
  }

  export type recordsCreateNestedManyWithoutBoilsInput = {
    create?: XOR<recordsCreateWithoutBoilsInput, recordsUncheckedCreateWithoutBoilsInput> | recordsCreateWithoutBoilsInput[] | recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutBoilsInput | recordsCreateOrConnectWithoutBoilsInput[]
    createMany?: recordsCreateManyBoilsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type semi_productsUncheckedCreateNestedManyWithoutBoilsInput = {
    create?: XOR<semi_productsCreateWithoutBoilsInput, semi_productsUncheckedCreateWithoutBoilsInput> | semi_productsCreateWithoutBoilsInput[] | semi_productsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutBoilsInput | semi_productsCreateOrConnectWithoutBoilsInput[]
    createMany?: semi_productsCreateManyBoilsInputEnvelope
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
  }

  export type tube_recordsUncheckedCreateNestedManyWithoutBoilsInput = {
    create?: XOR<tube_recordsCreateWithoutBoilsInput, tube_recordsUncheckedCreateWithoutBoilsInput> | tube_recordsCreateWithoutBoilsInput[] | tube_recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutBoilsInput | tube_recordsCreateOrConnectWithoutBoilsInput[]
    createMany?: tube_recordsCreateManyBoilsInputEnvelope
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
  }

  export type recordsUncheckedCreateNestedManyWithoutBoilsInput = {
    create?: XOR<recordsCreateWithoutBoilsInput, recordsUncheckedCreateWithoutBoilsInput> | recordsCreateWithoutBoilsInput[] | recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutBoilsInput | recordsCreateOrConnectWithoutBoilsInput[]
    createMany?: recordsCreateManyBoilsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type basesUpdateOneWithoutBoilsNestedInput = {
    create?: XOR<basesCreateWithoutBoilsInput, basesUncheckedCreateWithoutBoilsInput>
    connectOrCreate?: basesCreateOrConnectWithoutBoilsInput
    upsert?: basesUpsertWithoutBoilsInput
    disconnect?: basesWhereInput | boolean
    delete?: basesWhereInput | boolean
    connect?: basesWhereUniqueInput
    update?: XOR<XOR<basesUpdateToOneWithWhereWithoutBoilsInput, basesUpdateWithoutBoilsInput>, basesUncheckedUpdateWithoutBoilsInput>
  }

  export type semi_productsUpdateManyWithoutBoilsNestedInput = {
    create?: XOR<semi_productsCreateWithoutBoilsInput, semi_productsUncheckedCreateWithoutBoilsInput> | semi_productsCreateWithoutBoilsInput[] | semi_productsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutBoilsInput | semi_productsCreateOrConnectWithoutBoilsInput[]
    upsert?: semi_productsUpsertWithWhereUniqueWithoutBoilsInput | semi_productsUpsertWithWhereUniqueWithoutBoilsInput[]
    createMany?: semi_productsCreateManyBoilsInputEnvelope
    set?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    disconnect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    delete?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    update?: semi_productsUpdateWithWhereUniqueWithoutBoilsInput | semi_productsUpdateWithWhereUniqueWithoutBoilsInput[]
    updateMany?: semi_productsUpdateManyWithWhereWithoutBoilsInput | semi_productsUpdateManyWithWhereWithoutBoilsInput[]
    deleteMany?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
  }

  export type tube_recordsUpdateManyWithoutBoilsNestedInput = {
    create?: XOR<tube_recordsCreateWithoutBoilsInput, tube_recordsUncheckedCreateWithoutBoilsInput> | tube_recordsCreateWithoutBoilsInput[] | tube_recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutBoilsInput | tube_recordsCreateOrConnectWithoutBoilsInput[]
    upsert?: tube_recordsUpsertWithWhereUniqueWithoutBoilsInput | tube_recordsUpsertWithWhereUniqueWithoutBoilsInput[]
    createMany?: tube_recordsCreateManyBoilsInputEnvelope
    set?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    disconnect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    delete?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    update?: tube_recordsUpdateWithWhereUniqueWithoutBoilsInput | tube_recordsUpdateWithWhereUniqueWithoutBoilsInput[]
    updateMany?: tube_recordsUpdateManyWithWhereWithoutBoilsInput | tube_recordsUpdateManyWithWhereWithoutBoilsInput[]
    deleteMany?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
  }

  export type recordsUpdateManyWithoutBoilsNestedInput = {
    create?: XOR<recordsCreateWithoutBoilsInput, recordsUncheckedCreateWithoutBoilsInput> | recordsCreateWithoutBoilsInput[] | recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutBoilsInput | recordsCreateOrConnectWithoutBoilsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutBoilsInput | recordsUpsertWithWhereUniqueWithoutBoilsInput[]
    createMany?: recordsCreateManyBoilsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutBoilsInput | recordsUpdateWithWhereUniqueWithoutBoilsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutBoilsInput | recordsUpdateManyWithWhereWithoutBoilsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type semi_productsUncheckedUpdateManyWithoutBoilsNestedInput = {
    create?: XOR<semi_productsCreateWithoutBoilsInput, semi_productsUncheckedCreateWithoutBoilsInput> | semi_productsCreateWithoutBoilsInput[] | semi_productsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutBoilsInput | semi_productsCreateOrConnectWithoutBoilsInput[]
    upsert?: semi_productsUpsertWithWhereUniqueWithoutBoilsInput | semi_productsUpsertWithWhereUniqueWithoutBoilsInput[]
    createMany?: semi_productsCreateManyBoilsInputEnvelope
    set?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    disconnect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    delete?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    update?: semi_productsUpdateWithWhereUniqueWithoutBoilsInput | semi_productsUpdateWithWhereUniqueWithoutBoilsInput[]
    updateMany?: semi_productsUpdateManyWithWhereWithoutBoilsInput | semi_productsUpdateManyWithWhereWithoutBoilsInput[]
    deleteMany?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
  }

  export type tube_recordsUncheckedUpdateManyWithoutBoilsNestedInput = {
    create?: XOR<tube_recordsCreateWithoutBoilsInput, tube_recordsUncheckedCreateWithoutBoilsInput> | tube_recordsCreateWithoutBoilsInput[] | tube_recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutBoilsInput | tube_recordsCreateOrConnectWithoutBoilsInput[]
    upsert?: tube_recordsUpsertWithWhereUniqueWithoutBoilsInput | tube_recordsUpsertWithWhereUniqueWithoutBoilsInput[]
    createMany?: tube_recordsCreateManyBoilsInputEnvelope
    set?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    disconnect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    delete?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    update?: tube_recordsUpdateWithWhereUniqueWithoutBoilsInput | tube_recordsUpdateWithWhereUniqueWithoutBoilsInput[]
    updateMany?: tube_recordsUpdateManyWithWhereWithoutBoilsInput | tube_recordsUpdateManyWithWhereWithoutBoilsInput[]
    deleteMany?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
  }

  export type recordsUncheckedUpdateManyWithoutBoilsNestedInput = {
    create?: XOR<recordsCreateWithoutBoilsInput, recordsUncheckedCreateWithoutBoilsInput> | recordsCreateWithoutBoilsInput[] | recordsUncheckedCreateWithoutBoilsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutBoilsInput | recordsCreateOrConnectWithoutBoilsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutBoilsInput | recordsUpsertWithWhereUniqueWithoutBoilsInput[]
    createMany?: recordsCreateManyBoilsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutBoilsInput | recordsUpdateWithWhereUniqueWithoutBoilsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutBoilsInput | recordsUpdateManyWithWhereWithoutBoilsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type recordsCreateNestedManyWithoutCansInput = {
    create?: XOR<recordsCreateWithoutCansInput, recordsUncheckedCreateWithoutCansInput> | recordsCreateWithoutCansInput[] | recordsUncheckedCreateWithoutCansInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutCansInput | recordsCreateOrConnectWithoutCansInput[]
    createMany?: recordsCreateManyCansInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUncheckedCreateNestedManyWithoutCansInput = {
    create?: XOR<recordsCreateWithoutCansInput, recordsUncheckedCreateWithoutCansInput> | recordsCreateWithoutCansInput[] | recordsUncheckedCreateWithoutCansInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutCansInput | recordsCreateOrConnectWithoutCansInput[]
    createMany?: recordsCreateManyCansInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUpdateManyWithoutCansNestedInput = {
    create?: XOR<recordsCreateWithoutCansInput, recordsUncheckedCreateWithoutCansInput> | recordsCreateWithoutCansInput[] | recordsUncheckedCreateWithoutCansInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutCansInput | recordsCreateOrConnectWithoutCansInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutCansInput | recordsUpsertWithWhereUniqueWithoutCansInput[]
    createMany?: recordsCreateManyCansInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutCansInput | recordsUpdateWithWhereUniqueWithoutCansInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutCansInput | recordsUpdateManyWithWhereWithoutCansInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type recordsUncheckedUpdateManyWithoutCansNestedInput = {
    create?: XOR<recordsCreateWithoutCansInput, recordsUncheckedCreateWithoutCansInput> | recordsCreateWithoutCansInput[] | recordsUncheckedCreateWithoutCansInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutCansInput | recordsCreateOrConnectWithoutCansInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutCansInput | recordsUpsertWithWhereUniqueWithoutCansInput[]
    createMany?: recordsCreateManyCansInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutCansInput | recordsUpdateWithWhereUniqueWithoutCansInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutCansInput | recordsUpdateManyWithWhereWithoutCansInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type recordsCreateNestedManyWithoutConveyorsInput = {
    create?: XOR<recordsCreateWithoutConveyorsInput, recordsUncheckedCreateWithoutConveyorsInput> | recordsCreateWithoutConveyorsInput[] | recordsUncheckedCreateWithoutConveyorsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutConveyorsInput | recordsCreateOrConnectWithoutConveyorsInput[]
    createMany?: recordsCreateManyConveyorsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUncheckedCreateNestedManyWithoutConveyorsInput = {
    create?: XOR<recordsCreateWithoutConveyorsInput, recordsUncheckedCreateWithoutConveyorsInput> | recordsCreateWithoutConveyorsInput[] | recordsUncheckedCreateWithoutConveyorsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutConveyorsInput | recordsCreateOrConnectWithoutConveyorsInput[]
    createMany?: recordsCreateManyConveyorsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUpdateManyWithoutConveyorsNestedInput = {
    create?: XOR<recordsCreateWithoutConveyorsInput, recordsUncheckedCreateWithoutConveyorsInput> | recordsCreateWithoutConveyorsInput[] | recordsUncheckedCreateWithoutConveyorsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutConveyorsInput | recordsCreateOrConnectWithoutConveyorsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutConveyorsInput | recordsUpsertWithWhereUniqueWithoutConveyorsInput[]
    createMany?: recordsCreateManyConveyorsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutConveyorsInput | recordsUpdateWithWhereUniqueWithoutConveyorsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutConveyorsInput | recordsUpdateManyWithWhereWithoutConveyorsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type recordsUncheckedUpdateManyWithoutConveyorsNestedInput = {
    create?: XOR<recordsCreateWithoutConveyorsInput, recordsUncheckedCreateWithoutConveyorsInput> | recordsCreateWithoutConveyorsInput[] | recordsUncheckedCreateWithoutConveyorsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutConveyorsInput | recordsCreateOrConnectWithoutConveyorsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutConveyorsInput | recordsUpsertWithWhereUniqueWithoutConveyorsInput[]
    createMany?: recordsCreateManyConveyorsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutConveyorsInput | recordsUpdateWithWhereUniqueWithoutConveyorsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutConveyorsInput | recordsUpdateManyWithWhereWithoutConveyorsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type plantsCreateNestedOneWithoutDocsInput = {
    create?: XOR<plantsCreateWithoutDocsInput, plantsUncheckedCreateWithoutDocsInput>
    connectOrCreate?: plantsCreateOrConnectWithoutDocsInput
    connect?: plantsWhereUniqueInput
  }

  export type recordsCreateNestedManyWithoutDocsInput = {
    create?: XOR<recordsCreateWithoutDocsInput, recordsUncheckedCreateWithoutDocsInput> | recordsCreateWithoutDocsInput[] | recordsUncheckedCreateWithoutDocsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutDocsInput | recordsCreateOrConnectWithoutDocsInput[]
    createMany?: recordsCreateManyDocsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUncheckedCreateNestedManyWithoutDocsInput = {
    create?: XOR<recordsCreateWithoutDocsInput, recordsUncheckedCreateWithoutDocsInput> | recordsCreateWithoutDocsInput[] | recordsUncheckedCreateWithoutDocsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutDocsInput | recordsCreateOrConnectWithoutDocsInput[]
    createMany?: recordsCreateManyDocsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type plantsUpdateOneWithoutDocsNestedInput = {
    create?: XOR<plantsCreateWithoutDocsInput, plantsUncheckedCreateWithoutDocsInput>
    connectOrCreate?: plantsCreateOrConnectWithoutDocsInput
    upsert?: plantsUpsertWithoutDocsInput
    disconnect?: plantsWhereInput | boolean
    delete?: plantsWhereInput | boolean
    connect?: plantsWhereUniqueInput
    update?: XOR<XOR<plantsUpdateToOneWithWhereWithoutDocsInput, plantsUpdateWithoutDocsInput>, plantsUncheckedUpdateWithoutDocsInput>
  }

  export type recordsUpdateManyWithoutDocsNestedInput = {
    create?: XOR<recordsCreateWithoutDocsInput, recordsUncheckedCreateWithoutDocsInput> | recordsCreateWithoutDocsInput[] | recordsUncheckedCreateWithoutDocsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutDocsInput | recordsCreateOrConnectWithoutDocsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutDocsInput | recordsUpsertWithWhereUniqueWithoutDocsInput[]
    createMany?: recordsCreateManyDocsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutDocsInput | recordsUpdateWithWhereUniqueWithoutDocsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutDocsInput | recordsUpdateManyWithWhereWithoutDocsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type recordsUncheckedUpdateManyWithoutDocsNestedInput = {
    create?: XOR<recordsCreateWithoutDocsInput, recordsUncheckedCreateWithoutDocsInput> | recordsCreateWithoutDocsInput[] | recordsUncheckedCreateWithoutDocsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutDocsInput | recordsCreateOrConnectWithoutDocsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutDocsInput | recordsUpsertWithWhereUniqueWithoutDocsInput[]
    createMany?: recordsCreateManyDocsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutDocsInput | recordsUpdateWithWhereUniqueWithoutDocsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutDocsInput | recordsUpdateManyWithWhereWithoutDocsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type occupationsCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<occupationsCreateWithoutEmployeesInput, occupationsUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: occupationsCreateOrConnectWithoutEmployeesInput
    connect?: occupationsWhereUniqueInput
  }

  export type historiesCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<historiesCreateWithoutEmployeesInput, historiesUncheckedCreateWithoutEmployeesInput> | historiesCreateWithoutEmployeesInput[] | historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutEmployeesInput | historiesCreateOrConnectWithoutEmployeesInput[]
    createMany?: historiesCreateManyEmployeesInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type tube_historiesCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<tube_historiesCreateWithoutEmployeesInput, tube_historiesUncheckedCreateWithoutEmployeesInput> | tube_historiesCreateWithoutEmployeesInput[] | tube_historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutEmployeesInput | tube_historiesCreateOrConnectWithoutEmployeesInput[]
    createMany?: tube_historiesCreateManyEmployeesInputEnvelope
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
  }

  export type tube_sessionsCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<tube_sessionsCreateWithoutEmployeesInput, tube_sessionsUncheckedCreateWithoutEmployeesInput> | tube_sessionsCreateWithoutEmployeesInput[] | tube_sessionsUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutEmployeesInput | tube_sessionsCreateOrConnectWithoutEmployeesInput[]
    createMany?: tube_sessionsCreateManyEmployeesInputEnvelope
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
  }

  export type historiesUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<historiesCreateWithoutEmployeesInput, historiesUncheckedCreateWithoutEmployeesInput> | historiesCreateWithoutEmployeesInput[] | historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutEmployeesInput | historiesCreateOrConnectWithoutEmployeesInput[]
    createMany?: historiesCreateManyEmployeesInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type tube_historiesUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<tube_historiesCreateWithoutEmployeesInput, tube_historiesUncheckedCreateWithoutEmployeesInput> | tube_historiesCreateWithoutEmployeesInput[] | tube_historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutEmployeesInput | tube_historiesCreateOrConnectWithoutEmployeesInput[]
    createMany?: tube_historiesCreateManyEmployeesInputEnvelope
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
  }

  export type tube_sessionsUncheckedCreateNestedManyWithoutEmployeesInput = {
    create?: XOR<tube_sessionsCreateWithoutEmployeesInput, tube_sessionsUncheckedCreateWithoutEmployeesInput> | tube_sessionsCreateWithoutEmployeesInput[] | tube_sessionsUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutEmployeesInput | tube_sessionsCreateOrConnectWithoutEmployeesInput[]
    createMany?: tube_sessionsCreateManyEmployeesInputEnvelope
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
  }

  export type occupationsUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<occupationsCreateWithoutEmployeesInput, occupationsUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: occupationsCreateOrConnectWithoutEmployeesInput
    upsert?: occupationsUpsertWithoutEmployeesInput
    disconnect?: occupationsWhereInput | boolean
    delete?: occupationsWhereInput | boolean
    connect?: occupationsWhereUniqueInput
    update?: XOR<XOR<occupationsUpdateToOneWithWhereWithoutEmployeesInput, occupationsUpdateWithoutEmployeesInput>, occupationsUncheckedUpdateWithoutEmployeesInput>
  }

  export type historiesUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<historiesCreateWithoutEmployeesInput, historiesUncheckedCreateWithoutEmployeesInput> | historiesCreateWithoutEmployeesInput[] | historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutEmployeesInput | historiesCreateOrConnectWithoutEmployeesInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutEmployeesInput | historiesUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: historiesCreateManyEmployeesInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutEmployeesInput | historiesUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutEmployeesInput | historiesUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type tube_historiesUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<tube_historiesCreateWithoutEmployeesInput, tube_historiesUncheckedCreateWithoutEmployeesInput> | tube_historiesCreateWithoutEmployeesInput[] | tube_historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutEmployeesInput | tube_historiesCreateOrConnectWithoutEmployeesInput[]
    upsert?: tube_historiesUpsertWithWhereUniqueWithoutEmployeesInput | tube_historiesUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: tube_historiesCreateManyEmployeesInputEnvelope
    set?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    disconnect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    delete?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    update?: tube_historiesUpdateWithWhereUniqueWithoutEmployeesInput | tube_historiesUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: tube_historiesUpdateManyWithWhereWithoutEmployeesInput | tube_historiesUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
  }

  export type tube_sessionsUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<tube_sessionsCreateWithoutEmployeesInput, tube_sessionsUncheckedCreateWithoutEmployeesInput> | tube_sessionsCreateWithoutEmployeesInput[] | tube_sessionsUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutEmployeesInput | tube_sessionsCreateOrConnectWithoutEmployeesInput[]
    upsert?: tube_sessionsUpsertWithWhereUniqueWithoutEmployeesInput | tube_sessionsUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: tube_sessionsCreateManyEmployeesInputEnvelope
    set?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    disconnect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    delete?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    update?: tube_sessionsUpdateWithWhereUniqueWithoutEmployeesInput | tube_sessionsUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: tube_sessionsUpdateManyWithWhereWithoutEmployeesInput | tube_sessionsUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: tube_sessionsScalarWhereInput | tube_sessionsScalarWhereInput[]
  }

  export type historiesUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<historiesCreateWithoutEmployeesInput, historiesUncheckedCreateWithoutEmployeesInput> | historiesCreateWithoutEmployeesInput[] | historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutEmployeesInput | historiesCreateOrConnectWithoutEmployeesInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutEmployeesInput | historiesUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: historiesCreateManyEmployeesInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutEmployeesInput | historiesUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutEmployeesInput | historiesUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type tube_historiesUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<tube_historiesCreateWithoutEmployeesInput, tube_historiesUncheckedCreateWithoutEmployeesInput> | tube_historiesCreateWithoutEmployeesInput[] | tube_historiesUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutEmployeesInput | tube_historiesCreateOrConnectWithoutEmployeesInput[]
    upsert?: tube_historiesUpsertWithWhereUniqueWithoutEmployeesInput | tube_historiesUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: tube_historiesCreateManyEmployeesInputEnvelope
    set?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    disconnect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    delete?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    update?: tube_historiesUpdateWithWhereUniqueWithoutEmployeesInput | tube_historiesUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: tube_historiesUpdateManyWithWhereWithoutEmployeesInput | tube_historiesUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
  }

  export type tube_sessionsUncheckedUpdateManyWithoutEmployeesNestedInput = {
    create?: XOR<tube_sessionsCreateWithoutEmployeesInput, tube_sessionsUncheckedCreateWithoutEmployeesInput> | tube_sessionsCreateWithoutEmployeesInput[] | tube_sessionsUncheckedCreateWithoutEmployeesInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutEmployeesInput | tube_sessionsCreateOrConnectWithoutEmployeesInput[]
    upsert?: tube_sessionsUpsertWithWhereUniqueWithoutEmployeesInput | tube_sessionsUpsertWithWhereUniqueWithoutEmployeesInput[]
    createMany?: tube_sessionsCreateManyEmployeesInputEnvelope
    set?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    disconnect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    delete?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    update?: tube_sessionsUpdateWithWhereUniqueWithoutEmployeesInput | tube_sessionsUpdateWithWhereUniqueWithoutEmployeesInput[]
    updateMany?: tube_sessionsUpdateManyWithWhereWithoutEmployeesInput | tube_sessionsUpdateManyWithWhereWithoutEmployeesInput[]
    deleteMany?: tube_sessionsScalarWhereInput | tube_sessionsScalarWhereInput[]
  }

  export type employeesCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<employeesCreateWithoutHistoriesInput, employeesUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutHistoriesInput
    connect?: employeesWhereUniqueInput
  }

  export type history_typesCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<history_typesCreateWithoutHistoriesInput, history_typesUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: history_typesCreateOrConnectWithoutHistoriesInput
    connect?: history_typesWhereUniqueInput
  }

  export type recordsCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<recordsCreateWithoutHistoriesInput, recordsUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: recordsCreateOrConnectWithoutHistoriesInput
    connect?: recordsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutHistoriesInput = {
    create?: XOR<usersCreateWithoutHistoriesInput, usersUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistoriesInput
    connect?: usersWhereUniqueInput
  }

  export type employeesUpdateOneWithoutHistoriesNestedInput = {
    create?: XOR<employeesCreateWithoutHistoriesInput, employeesUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutHistoriesInput
    upsert?: employeesUpsertWithoutHistoriesInput
    disconnect?: employeesWhereInput | boolean
    delete?: employeesWhereInput | boolean
    connect?: employeesWhereUniqueInput
    update?: XOR<XOR<employeesUpdateToOneWithWhereWithoutHistoriesInput, employeesUpdateWithoutHistoriesInput>, employeesUncheckedUpdateWithoutHistoriesInput>
  }

  export type history_typesUpdateOneWithoutHistoriesNestedInput = {
    create?: XOR<history_typesCreateWithoutHistoriesInput, history_typesUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: history_typesCreateOrConnectWithoutHistoriesInput
    upsert?: history_typesUpsertWithoutHistoriesInput
    disconnect?: history_typesWhereInput | boolean
    delete?: history_typesWhereInput | boolean
    connect?: history_typesWhereUniqueInput
    update?: XOR<XOR<history_typesUpdateToOneWithWhereWithoutHistoriesInput, history_typesUpdateWithoutHistoriesInput>, history_typesUncheckedUpdateWithoutHistoriesInput>
  }

  export type recordsUpdateOneWithoutHistoriesNestedInput = {
    create?: XOR<recordsCreateWithoutHistoriesInput, recordsUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: recordsCreateOrConnectWithoutHistoriesInput
    upsert?: recordsUpsertWithoutHistoriesInput
    disconnect?: recordsWhereInput | boolean
    delete?: recordsWhereInput | boolean
    connect?: recordsWhereUniqueInput
    update?: XOR<XOR<recordsUpdateToOneWithWhereWithoutHistoriesInput, recordsUpdateWithoutHistoriesInput>, recordsUncheckedUpdateWithoutHistoriesInput>
  }

  export type usersUpdateOneWithoutHistoriesNestedInput = {
    create?: XOR<usersCreateWithoutHistoriesInput, usersUncheckedCreateWithoutHistoriesInput>
    connectOrCreate?: usersCreateOrConnectWithoutHistoriesInput
    upsert?: usersUpsertWithoutHistoriesInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutHistoriesInput, usersUpdateWithoutHistoriesInput>, usersUncheckedUpdateWithoutHistoriesInput>
  }

  export type historiesCreateNestedManyWithoutHistory_typesInput = {
    create?: XOR<historiesCreateWithoutHistory_typesInput, historiesUncheckedCreateWithoutHistory_typesInput> | historiesCreateWithoutHistory_typesInput[] | historiesUncheckedCreateWithoutHistory_typesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutHistory_typesInput | historiesCreateOrConnectWithoutHistory_typesInput[]
    createMany?: historiesCreateManyHistory_typesInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type historiesUncheckedCreateNestedManyWithoutHistory_typesInput = {
    create?: XOR<historiesCreateWithoutHistory_typesInput, historiesUncheckedCreateWithoutHistory_typesInput> | historiesCreateWithoutHistory_typesInput[] | historiesUncheckedCreateWithoutHistory_typesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutHistory_typesInput | historiesCreateOrConnectWithoutHistory_typesInput[]
    createMany?: historiesCreateManyHistory_typesInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type historiesUpdateManyWithoutHistory_typesNestedInput = {
    create?: XOR<historiesCreateWithoutHistory_typesInput, historiesUncheckedCreateWithoutHistory_typesInput> | historiesCreateWithoutHistory_typesInput[] | historiesUncheckedCreateWithoutHistory_typesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutHistory_typesInput | historiesCreateOrConnectWithoutHistory_typesInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutHistory_typesInput | historiesUpsertWithWhereUniqueWithoutHistory_typesInput[]
    createMany?: historiesCreateManyHistory_typesInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutHistory_typesInput | historiesUpdateWithWhereUniqueWithoutHistory_typesInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutHistory_typesInput | historiesUpdateManyWithWhereWithoutHistory_typesInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type historiesUncheckedUpdateManyWithoutHistory_typesNestedInput = {
    create?: XOR<historiesCreateWithoutHistory_typesInput, historiesUncheckedCreateWithoutHistory_typesInput> | historiesCreateWithoutHistory_typesInput[] | historiesUncheckedCreateWithoutHistory_typesInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutHistory_typesInput | historiesCreateOrConnectWithoutHistory_typesInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutHistory_typesInput | historiesUpsertWithWhereUniqueWithoutHistory_typesInput[]
    createMany?: historiesCreateManyHistory_typesInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutHistory_typesInput | historiesUpdateWithWhereUniqueWithoutHistory_typesInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutHistory_typesInput | historiesUpdateManyWithWhereWithoutHistory_typesInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type record_regulationsCreateNestedManyWithoutMarking_sampleInput = {
    create?: XOR<record_regulationsCreateWithoutMarking_sampleInput, record_regulationsUncheckedCreateWithoutMarking_sampleInput> | record_regulationsCreateWithoutMarking_sampleInput[] | record_regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutMarking_sampleInput | record_regulationsCreateOrConnectWithoutMarking_sampleInput[]
    createMany?: record_regulationsCreateManyMarking_sampleInputEnvelope
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
  }

  export type regulationsCreateNestedManyWithoutMarking_sampleInput = {
    create?: XOR<regulationsCreateWithoutMarking_sampleInput, regulationsUncheckedCreateWithoutMarking_sampleInput> | regulationsCreateWithoutMarking_sampleInput[] | regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutMarking_sampleInput | regulationsCreateOrConnectWithoutMarking_sampleInput[]
    createMany?: regulationsCreateManyMarking_sampleInputEnvelope
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
  }

  export type record_regulationsUncheckedCreateNestedManyWithoutMarking_sampleInput = {
    create?: XOR<record_regulationsCreateWithoutMarking_sampleInput, record_regulationsUncheckedCreateWithoutMarking_sampleInput> | record_regulationsCreateWithoutMarking_sampleInput[] | record_regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutMarking_sampleInput | record_regulationsCreateOrConnectWithoutMarking_sampleInput[]
    createMany?: record_regulationsCreateManyMarking_sampleInputEnvelope
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
  }

  export type regulationsUncheckedCreateNestedManyWithoutMarking_sampleInput = {
    create?: XOR<regulationsCreateWithoutMarking_sampleInput, regulationsUncheckedCreateWithoutMarking_sampleInput> | regulationsCreateWithoutMarking_sampleInput[] | regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutMarking_sampleInput | regulationsCreateOrConnectWithoutMarking_sampleInput[]
    createMany?: regulationsCreateManyMarking_sampleInputEnvelope
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
  }

  export type record_regulationsUpdateManyWithoutMarking_sampleNestedInput = {
    create?: XOR<record_regulationsCreateWithoutMarking_sampleInput, record_regulationsUncheckedCreateWithoutMarking_sampleInput> | record_regulationsCreateWithoutMarking_sampleInput[] | record_regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutMarking_sampleInput | record_regulationsCreateOrConnectWithoutMarking_sampleInput[]
    upsert?: record_regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput | record_regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput[]
    createMany?: record_regulationsCreateManyMarking_sampleInputEnvelope
    set?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    disconnect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    delete?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    update?: record_regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput | record_regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput[]
    updateMany?: record_regulationsUpdateManyWithWhereWithoutMarking_sampleInput | record_regulationsUpdateManyWithWhereWithoutMarking_sampleInput[]
    deleteMany?: record_regulationsScalarWhereInput | record_regulationsScalarWhereInput[]
  }

  export type regulationsUpdateManyWithoutMarking_sampleNestedInput = {
    create?: XOR<regulationsCreateWithoutMarking_sampleInput, regulationsUncheckedCreateWithoutMarking_sampleInput> | regulationsCreateWithoutMarking_sampleInput[] | regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutMarking_sampleInput | regulationsCreateOrConnectWithoutMarking_sampleInput[]
    upsert?: regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput | regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput[]
    createMany?: regulationsCreateManyMarking_sampleInputEnvelope
    set?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    disconnect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    delete?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    update?: regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput | regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput[]
    updateMany?: regulationsUpdateManyWithWhereWithoutMarking_sampleInput | regulationsUpdateManyWithWhereWithoutMarking_sampleInput[]
    deleteMany?: regulationsScalarWhereInput | regulationsScalarWhereInput[]
  }

  export type record_regulationsUncheckedUpdateManyWithoutMarking_sampleNestedInput = {
    create?: XOR<record_regulationsCreateWithoutMarking_sampleInput, record_regulationsUncheckedCreateWithoutMarking_sampleInput> | record_regulationsCreateWithoutMarking_sampleInput[] | record_regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutMarking_sampleInput | record_regulationsCreateOrConnectWithoutMarking_sampleInput[]
    upsert?: record_regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput | record_regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput[]
    createMany?: record_regulationsCreateManyMarking_sampleInputEnvelope
    set?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    disconnect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    delete?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    update?: record_regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput | record_regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput[]
    updateMany?: record_regulationsUpdateManyWithWhereWithoutMarking_sampleInput | record_regulationsUpdateManyWithWhereWithoutMarking_sampleInput[]
    deleteMany?: record_regulationsScalarWhereInput | record_regulationsScalarWhereInput[]
  }

  export type regulationsUncheckedUpdateManyWithoutMarking_sampleNestedInput = {
    create?: XOR<regulationsCreateWithoutMarking_sampleInput, regulationsUncheckedCreateWithoutMarking_sampleInput> | regulationsCreateWithoutMarking_sampleInput[] | regulationsUncheckedCreateWithoutMarking_sampleInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutMarking_sampleInput | regulationsCreateOrConnectWithoutMarking_sampleInput[]
    upsert?: regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput | regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput[]
    createMany?: regulationsCreateManyMarking_sampleInputEnvelope
    set?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    disconnect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    delete?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    update?: regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput | regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput[]
    updateMany?: regulationsUpdateManyWithWhereWithoutMarking_sampleInput | regulationsUpdateManyWithWhereWithoutMarking_sampleInput[]
    deleteMany?: regulationsScalarWhereInput | regulationsScalarWhereInput[]
  }

  export type employeesCreateNestedManyWithoutOccupationsInput = {
    create?: XOR<employeesCreateWithoutOccupationsInput, employeesUncheckedCreateWithoutOccupationsInput> | employeesCreateWithoutOccupationsInput[] | employeesUncheckedCreateWithoutOccupationsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutOccupationsInput | employeesCreateOrConnectWithoutOccupationsInput[]
    createMany?: employeesCreateManyOccupationsInputEnvelope
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
  }

  export type employeesUncheckedCreateNestedManyWithoutOccupationsInput = {
    create?: XOR<employeesCreateWithoutOccupationsInput, employeesUncheckedCreateWithoutOccupationsInput> | employeesCreateWithoutOccupationsInput[] | employeesUncheckedCreateWithoutOccupationsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutOccupationsInput | employeesCreateOrConnectWithoutOccupationsInput[]
    createMany?: employeesCreateManyOccupationsInputEnvelope
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
  }

  export type employeesUpdateManyWithoutOccupationsNestedInput = {
    create?: XOR<employeesCreateWithoutOccupationsInput, employeesUncheckedCreateWithoutOccupationsInput> | employeesCreateWithoutOccupationsInput[] | employeesUncheckedCreateWithoutOccupationsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutOccupationsInput | employeesCreateOrConnectWithoutOccupationsInput[]
    upsert?: employeesUpsertWithWhereUniqueWithoutOccupationsInput | employeesUpsertWithWhereUniqueWithoutOccupationsInput[]
    createMany?: employeesCreateManyOccupationsInputEnvelope
    set?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    disconnect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    delete?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    update?: employeesUpdateWithWhereUniqueWithoutOccupationsInput | employeesUpdateWithWhereUniqueWithoutOccupationsInput[]
    updateMany?: employeesUpdateManyWithWhereWithoutOccupationsInput | employeesUpdateManyWithWhereWithoutOccupationsInput[]
    deleteMany?: employeesScalarWhereInput | employeesScalarWhereInput[]
  }

  export type employeesUncheckedUpdateManyWithoutOccupationsNestedInput = {
    create?: XOR<employeesCreateWithoutOccupationsInput, employeesUncheckedCreateWithoutOccupationsInput> | employeesCreateWithoutOccupationsInput[] | employeesUncheckedCreateWithoutOccupationsInput[]
    connectOrCreate?: employeesCreateOrConnectWithoutOccupationsInput | employeesCreateOrConnectWithoutOccupationsInput[]
    upsert?: employeesUpsertWithWhereUniqueWithoutOccupationsInput | employeesUpsertWithWhereUniqueWithoutOccupationsInput[]
    createMany?: employeesCreateManyOccupationsInputEnvelope
    set?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    disconnect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    delete?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    connect?: employeesWhereUniqueInput | employeesWhereUniqueInput[]
    update?: employeesUpdateWithWhereUniqueWithoutOccupationsInput | employeesUpdateWithWhereUniqueWithoutOccupationsInput[]
    updateMany?: employeesUpdateManyWithWhereWithoutOccupationsInput | employeesUpdateManyWithWhereWithoutOccupationsInput[]
    deleteMany?: employeesScalarWhereInput | employeesScalarWhereInput[]
  }

  export type docsCreateNestedManyWithoutPlantsInput = {
    create?: XOR<docsCreateWithoutPlantsInput, docsUncheckedCreateWithoutPlantsInput> | docsCreateWithoutPlantsInput[] | docsUncheckedCreateWithoutPlantsInput[]
    connectOrCreate?: docsCreateOrConnectWithoutPlantsInput | docsCreateOrConnectWithoutPlantsInput[]
    createMany?: docsCreateManyPlantsInputEnvelope
    connect?: docsWhereUniqueInput | docsWhereUniqueInput[]
  }

  export type docsUncheckedCreateNestedManyWithoutPlantsInput = {
    create?: XOR<docsCreateWithoutPlantsInput, docsUncheckedCreateWithoutPlantsInput> | docsCreateWithoutPlantsInput[] | docsUncheckedCreateWithoutPlantsInput[]
    connectOrCreate?: docsCreateOrConnectWithoutPlantsInput | docsCreateOrConnectWithoutPlantsInput[]
    createMany?: docsCreateManyPlantsInputEnvelope
    connect?: docsWhereUniqueInput | docsWhereUniqueInput[]
  }

  export type docsUpdateManyWithoutPlantsNestedInput = {
    create?: XOR<docsCreateWithoutPlantsInput, docsUncheckedCreateWithoutPlantsInput> | docsCreateWithoutPlantsInput[] | docsUncheckedCreateWithoutPlantsInput[]
    connectOrCreate?: docsCreateOrConnectWithoutPlantsInput | docsCreateOrConnectWithoutPlantsInput[]
    upsert?: docsUpsertWithWhereUniqueWithoutPlantsInput | docsUpsertWithWhereUniqueWithoutPlantsInput[]
    createMany?: docsCreateManyPlantsInputEnvelope
    set?: docsWhereUniqueInput | docsWhereUniqueInput[]
    disconnect?: docsWhereUniqueInput | docsWhereUniqueInput[]
    delete?: docsWhereUniqueInput | docsWhereUniqueInput[]
    connect?: docsWhereUniqueInput | docsWhereUniqueInput[]
    update?: docsUpdateWithWhereUniqueWithoutPlantsInput | docsUpdateWithWhereUniqueWithoutPlantsInput[]
    updateMany?: docsUpdateManyWithWhereWithoutPlantsInput | docsUpdateManyWithWhereWithoutPlantsInput[]
    deleteMany?: docsScalarWhereInput | docsScalarWhereInput[]
  }

  export type docsUncheckedUpdateManyWithoutPlantsNestedInput = {
    create?: XOR<docsCreateWithoutPlantsInput, docsUncheckedCreateWithoutPlantsInput> | docsCreateWithoutPlantsInput[] | docsUncheckedCreateWithoutPlantsInput[]
    connectOrCreate?: docsCreateOrConnectWithoutPlantsInput | docsCreateOrConnectWithoutPlantsInput[]
    upsert?: docsUpsertWithWhereUniqueWithoutPlantsInput | docsUpsertWithWhereUniqueWithoutPlantsInput[]
    createMany?: docsCreateManyPlantsInputEnvelope
    set?: docsWhereUniqueInput | docsWhereUniqueInput[]
    disconnect?: docsWhereUniqueInput | docsWhereUniqueInput[]
    delete?: docsWhereUniqueInput | docsWhereUniqueInput[]
    connect?: docsWhereUniqueInput | docsWhereUniqueInput[]
    update?: docsUpdateWithWhereUniqueWithoutPlantsInput | docsUpdateWithWhereUniqueWithoutPlantsInput[]
    updateMany?: docsUpdateManyWithWhereWithoutPlantsInput | docsUpdateManyWithWhereWithoutPlantsInput[]
    deleteMany?: docsScalarWhereInput | docsScalarWhereInput[]
  }

  export type seriesCreateNestedOneWithoutProductsInput = {
    create?: XOR<seriesCreateWithoutProductsInput, seriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: seriesCreateOrConnectWithoutProductsInput
    connect?: seriesWhereUniqueInput
  }

  export type recordsCreateNestedManyWithoutProductsInput = {
    create?: XOR<recordsCreateWithoutProductsInput, recordsUncheckedCreateWithoutProductsInput> | recordsCreateWithoutProductsInput[] | recordsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutProductsInput | recordsCreateOrConnectWithoutProductsInput[]
    createMany?: recordsCreateManyProductsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type regulationsCreateNestedManyWithoutProductsInput = {
    create?: XOR<regulationsCreateWithoutProductsInput, regulationsUncheckedCreateWithoutProductsInput> | regulationsCreateWithoutProductsInput[] | regulationsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutProductsInput | regulationsCreateOrConnectWithoutProductsInput[]
    createMany?: regulationsCreateManyProductsInputEnvelope
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
  }

  export type semi_productsCreateNestedManyWithoutProductsInput = {
    create?: XOR<semi_productsCreateWithoutProductsInput, semi_productsUncheckedCreateWithoutProductsInput> | semi_productsCreateWithoutProductsInput[] | semi_productsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutProductsInput | semi_productsCreateOrConnectWithoutProductsInput[]
    createMany?: semi_productsCreateManyProductsInputEnvelope
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
  }

  export type recordsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<recordsCreateWithoutProductsInput, recordsUncheckedCreateWithoutProductsInput> | recordsCreateWithoutProductsInput[] | recordsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutProductsInput | recordsCreateOrConnectWithoutProductsInput[]
    createMany?: recordsCreateManyProductsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type regulationsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<regulationsCreateWithoutProductsInput, regulationsUncheckedCreateWithoutProductsInput> | regulationsCreateWithoutProductsInput[] | regulationsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutProductsInput | regulationsCreateOrConnectWithoutProductsInput[]
    createMany?: regulationsCreateManyProductsInputEnvelope
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
  }

  export type semi_productsUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<semi_productsCreateWithoutProductsInput, semi_productsUncheckedCreateWithoutProductsInput> | semi_productsCreateWithoutProductsInput[] | semi_productsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutProductsInput | semi_productsCreateOrConnectWithoutProductsInput[]
    createMany?: semi_productsCreateManyProductsInputEnvelope
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
  }

  export type seriesUpdateOneWithoutProductsNestedInput = {
    create?: XOR<seriesCreateWithoutProductsInput, seriesUncheckedCreateWithoutProductsInput>
    connectOrCreate?: seriesCreateOrConnectWithoutProductsInput
    upsert?: seriesUpsertWithoutProductsInput
    disconnect?: seriesWhereInput | boolean
    delete?: seriesWhereInput | boolean
    connect?: seriesWhereUniqueInput
    update?: XOR<XOR<seriesUpdateToOneWithWhereWithoutProductsInput, seriesUpdateWithoutProductsInput>, seriesUncheckedUpdateWithoutProductsInput>
  }

  export type recordsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<recordsCreateWithoutProductsInput, recordsUncheckedCreateWithoutProductsInput> | recordsCreateWithoutProductsInput[] | recordsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutProductsInput | recordsCreateOrConnectWithoutProductsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutProductsInput | recordsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: recordsCreateManyProductsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutProductsInput | recordsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutProductsInput | recordsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type regulationsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<regulationsCreateWithoutProductsInput, regulationsUncheckedCreateWithoutProductsInput> | regulationsCreateWithoutProductsInput[] | regulationsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutProductsInput | regulationsCreateOrConnectWithoutProductsInput[]
    upsert?: regulationsUpsertWithWhereUniqueWithoutProductsInput | regulationsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: regulationsCreateManyProductsInputEnvelope
    set?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    disconnect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    delete?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    update?: regulationsUpdateWithWhereUniqueWithoutProductsInput | regulationsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: regulationsUpdateManyWithWhereWithoutProductsInput | regulationsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: regulationsScalarWhereInput | regulationsScalarWhereInput[]
  }

  export type semi_productsUpdateManyWithoutProductsNestedInput = {
    create?: XOR<semi_productsCreateWithoutProductsInput, semi_productsUncheckedCreateWithoutProductsInput> | semi_productsCreateWithoutProductsInput[] | semi_productsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutProductsInput | semi_productsCreateOrConnectWithoutProductsInput[]
    upsert?: semi_productsUpsertWithWhereUniqueWithoutProductsInput | semi_productsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: semi_productsCreateManyProductsInputEnvelope
    set?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    disconnect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    delete?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    update?: semi_productsUpdateWithWhereUniqueWithoutProductsInput | semi_productsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: semi_productsUpdateManyWithWhereWithoutProductsInput | semi_productsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
  }

  export type recordsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<recordsCreateWithoutProductsInput, recordsUncheckedCreateWithoutProductsInput> | recordsCreateWithoutProductsInput[] | recordsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutProductsInput | recordsCreateOrConnectWithoutProductsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutProductsInput | recordsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: recordsCreateManyProductsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutProductsInput | recordsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutProductsInput | recordsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type regulationsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<regulationsCreateWithoutProductsInput, regulationsUncheckedCreateWithoutProductsInput> | regulationsCreateWithoutProductsInput[] | regulationsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: regulationsCreateOrConnectWithoutProductsInput | regulationsCreateOrConnectWithoutProductsInput[]
    upsert?: regulationsUpsertWithWhereUniqueWithoutProductsInput | regulationsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: regulationsCreateManyProductsInputEnvelope
    set?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    disconnect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    delete?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    connect?: regulationsWhereUniqueInput | regulationsWhereUniqueInput[]
    update?: regulationsUpdateWithWhereUniqueWithoutProductsInput | regulationsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: regulationsUpdateManyWithWhereWithoutProductsInput | regulationsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: regulationsScalarWhereInput | regulationsScalarWhereInput[]
  }

  export type semi_productsUncheckedUpdateManyWithoutProductsNestedInput = {
    create?: XOR<semi_productsCreateWithoutProductsInput, semi_productsUncheckedCreateWithoutProductsInput> | semi_productsCreateWithoutProductsInput[] | semi_productsUncheckedCreateWithoutProductsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutProductsInput | semi_productsCreateOrConnectWithoutProductsInput[]
    upsert?: semi_productsUpsertWithWhereUniqueWithoutProductsInput | semi_productsUpsertWithWhereUniqueWithoutProductsInput[]
    createMany?: semi_productsCreateManyProductsInputEnvelope
    set?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    disconnect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    delete?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    update?: semi_productsUpdateWithWhereUniqueWithoutProductsInput | semi_productsUpdateWithWhereUniqueWithoutProductsInput[]
    updateMany?: semi_productsUpdateManyWithWhereWithoutProductsInput | semi_productsUpdateManyWithWhereWithoutProductsInput[]
    deleteMany?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
  }

  export type marking_sampleCreateNestedOneWithoutRecord_regulationsInput = {
    create?: XOR<marking_sampleCreateWithoutRecord_regulationsInput, marking_sampleUncheckedCreateWithoutRecord_regulationsInput>
    connectOrCreate?: marking_sampleCreateOrConnectWithoutRecord_regulationsInput
    connect?: marking_sampleWhereUniqueInput
  }

  export type recordsCreateNestedOneWithoutRecord_regulationsInput = {
    create?: XOR<recordsCreateWithoutRecord_regulationsInput, recordsUncheckedCreateWithoutRecord_regulationsInput>
    connectOrCreate?: recordsCreateOrConnectWithoutRecord_regulationsInput
    connect?: recordsWhereUniqueInput
  }

  export type marking_sampleUpdateOneWithoutRecord_regulationsNestedInput = {
    create?: XOR<marking_sampleCreateWithoutRecord_regulationsInput, marking_sampleUncheckedCreateWithoutRecord_regulationsInput>
    connectOrCreate?: marking_sampleCreateOrConnectWithoutRecord_regulationsInput
    upsert?: marking_sampleUpsertWithoutRecord_regulationsInput
    disconnect?: marking_sampleWhereInput | boolean
    delete?: marking_sampleWhereInput | boolean
    connect?: marking_sampleWhereUniqueInput
    update?: XOR<XOR<marking_sampleUpdateToOneWithWhereWithoutRecord_regulationsInput, marking_sampleUpdateWithoutRecord_regulationsInput>, marking_sampleUncheckedUpdateWithoutRecord_regulationsInput>
  }

  export type recordsUpdateOneWithoutRecord_regulationsNestedInput = {
    create?: XOR<recordsCreateWithoutRecord_regulationsInput, recordsUncheckedCreateWithoutRecord_regulationsInput>
    connectOrCreate?: recordsCreateOrConnectWithoutRecord_regulationsInput
    upsert?: recordsUpsertWithoutRecord_regulationsInput
    disconnect?: recordsWhereInput | boolean
    delete?: recordsWhereInput | boolean
    connect?: recordsWhereUniqueInput
    update?: XOR<XOR<recordsUpdateToOneWithWhereWithoutRecord_regulationsInput, recordsUpdateWithoutRecord_regulationsInput>, recordsUncheckedUpdateWithoutRecord_regulationsInput>
  }

  export type historiesCreateNestedManyWithoutRecordsInput = {
    create?: XOR<historiesCreateWithoutRecordsInput, historiesUncheckedCreateWithoutRecordsInput> | historiesCreateWithoutRecordsInput[] | historiesUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutRecordsInput | historiesCreateOrConnectWithoutRecordsInput[]
    createMany?: historiesCreateManyRecordsInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type record_regulationsCreateNestedManyWithoutRecordsInput = {
    create?: XOR<record_regulationsCreateWithoutRecordsInput, record_regulationsUncheckedCreateWithoutRecordsInput> | record_regulationsCreateWithoutRecordsInput[] | record_regulationsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutRecordsInput | record_regulationsCreateOrConnectWithoutRecordsInput[]
    createMany?: record_regulationsCreateManyRecordsInputEnvelope
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
  }

  export type apparatusesCreateNestedOneWithoutRecordsInput = {
    create?: XOR<apparatusesCreateWithoutRecordsInput, apparatusesUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: apparatusesCreateOrConnectWithoutRecordsInput
    connect?: apparatusesWhereUniqueInput
  }

  export type cansCreateNestedOneWithoutRecordsInput = {
    create?: XOR<cansCreateWithoutRecordsInput, cansUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: cansCreateOrConnectWithoutRecordsInput
    connect?: cansWhereUniqueInput
  }

  export type conveyorsCreateNestedOneWithoutRecordsInput = {
    create?: XOR<conveyorsCreateWithoutRecordsInput, conveyorsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: conveyorsCreateOrConnectWithoutRecordsInput
    connect?: conveyorsWhereUniqueInput
  }

  export type docsCreateNestedOneWithoutRecordsInput = {
    create?: XOR<docsCreateWithoutRecordsInput, docsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: docsCreateOrConnectWithoutRecordsInput
    connect?: docsWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutRecordsInput = {
    create?: XOR<productsCreateWithoutRecordsInput, productsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRecordsInput
    connect?: productsWhereUniqueInput
  }

  export type workshopsCreateNestedOneWithoutRecordsInput = {
    create?: XOR<workshopsCreateWithoutRecordsInput, workshopsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: workshopsCreateOrConnectWithoutRecordsInput
    connect?: workshopsWhereUniqueInput
  }

  export type boilsCreateNestedOneWithoutRecordsInput = {
    create?: XOR<boilsCreateWithoutRecordsInput, boilsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: boilsCreateOrConnectWithoutRecordsInput
    connect?: boilsWhereUniqueInput
  }

  export type semi_productsCreateNestedManyWithoutRecordsInput = {
    create?: XOR<semi_productsCreateWithoutRecordsInput, semi_productsUncheckedCreateWithoutRecordsInput> | semi_productsCreateWithoutRecordsInput[] | semi_productsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutRecordsInput | semi_productsCreateOrConnectWithoutRecordsInput[]
    createMany?: semi_productsCreateManyRecordsInputEnvelope
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
  }

  export type historiesUncheckedCreateNestedManyWithoutRecordsInput = {
    create?: XOR<historiesCreateWithoutRecordsInput, historiesUncheckedCreateWithoutRecordsInput> | historiesCreateWithoutRecordsInput[] | historiesUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutRecordsInput | historiesCreateOrConnectWithoutRecordsInput[]
    createMany?: historiesCreateManyRecordsInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type record_regulationsUncheckedCreateNestedManyWithoutRecordsInput = {
    create?: XOR<record_regulationsCreateWithoutRecordsInput, record_regulationsUncheckedCreateWithoutRecordsInput> | record_regulationsCreateWithoutRecordsInput[] | record_regulationsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutRecordsInput | record_regulationsCreateOrConnectWithoutRecordsInput[]
    createMany?: record_regulationsCreateManyRecordsInputEnvelope
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
  }

  export type semi_productsUncheckedCreateNestedManyWithoutRecordsInput = {
    create?: XOR<semi_productsCreateWithoutRecordsInput, semi_productsUncheckedCreateWithoutRecordsInput> | semi_productsCreateWithoutRecordsInput[] | semi_productsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutRecordsInput | semi_productsCreateOrConnectWithoutRecordsInput[]
    createMany?: semi_productsCreateManyRecordsInputEnvelope
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
  }

  export type historiesUpdateManyWithoutRecordsNestedInput = {
    create?: XOR<historiesCreateWithoutRecordsInput, historiesUncheckedCreateWithoutRecordsInput> | historiesCreateWithoutRecordsInput[] | historiesUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutRecordsInput | historiesCreateOrConnectWithoutRecordsInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutRecordsInput | historiesUpsertWithWhereUniqueWithoutRecordsInput[]
    createMany?: historiesCreateManyRecordsInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutRecordsInput | historiesUpdateWithWhereUniqueWithoutRecordsInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutRecordsInput | historiesUpdateManyWithWhereWithoutRecordsInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type record_regulationsUpdateManyWithoutRecordsNestedInput = {
    create?: XOR<record_regulationsCreateWithoutRecordsInput, record_regulationsUncheckedCreateWithoutRecordsInput> | record_regulationsCreateWithoutRecordsInput[] | record_regulationsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutRecordsInput | record_regulationsCreateOrConnectWithoutRecordsInput[]
    upsert?: record_regulationsUpsertWithWhereUniqueWithoutRecordsInput | record_regulationsUpsertWithWhereUniqueWithoutRecordsInput[]
    createMany?: record_regulationsCreateManyRecordsInputEnvelope
    set?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    disconnect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    delete?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    update?: record_regulationsUpdateWithWhereUniqueWithoutRecordsInput | record_regulationsUpdateWithWhereUniqueWithoutRecordsInput[]
    updateMany?: record_regulationsUpdateManyWithWhereWithoutRecordsInput | record_regulationsUpdateManyWithWhereWithoutRecordsInput[]
    deleteMany?: record_regulationsScalarWhereInput | record_regulationsScalarWhereInput[]
  }

  export type apparatusesUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<apparatusesCreateWithoutRecordsInput, apparatusesUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: apparatusesCreateOrConnectWithoutRecordsInput
    upsert?: apparatusesUpsertWithoutRecordsInput
    disconnect?: apparatusesWhereInput | boolean
    delete?: apparatusesWhereInput | boolean
    connect?: apparatusesWhereUniqueInput
    update?: XOR<XOR<apparatusesUpdateToOneWithWhereWithoutRecordsInput, apparatusesUpdateWithoutRecordsInput>, apparatusesUncheckedUpdateWithoutRecordsInput>
  }

  export type cansUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<cansCreateWithoutRecordsInput, cansUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: cansCreateOrConnectWithoutRecordsInput
    upsert?: cansUpsertWithoutRecordsInput
    disconnect?: cansWhereInput | boolean
    delete?: cansWhereInput | boolean
    connect?: cansWhereUniqueInput
    update?: XOR<XOR<cansUpdateToOneWithWhereWithoutRecordsInput, cansUpdateWithoutRecordsInput>, cansUncheckedUpdateWithoutRecordsInput>
  }

  export type conveyorsUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<conveyorsCreateWithoutRecordsInput, conveyorsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: conveyorsCreateOrConnectWithoutRecordsInput
    upsert?: conveyorsUpsertWithoutRecordsInput
    disconnect?: conveyorsWhereInput | boolean
    delete?: conveyorsWhereInput | boolean
    connect?: conveyorsWhereUniqueInput
    update?: XOR<XOR<conveyorsUpdateToOneWithWhereWithoutRecordsInput, conveyorsUpdateWithoutRecordsInput>, conveyorsUncheckedUpdateWithoutRecordsInput>
  }

  export type docsUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<docsCreateWithoutRecordsInput, docsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: docsCreateOrConnectWithoutRecordsInput
    upsert?: docsUpsertWithoutRecordsInput
    disconnect?: docsWhereInput | boolean
    delete?: docsWhereInput | boolean
    connect?: docsWhereUniqueInput
    update?: XOR<XOR<docsUpdateToOneWithWhereWithoutRecordsInput, docsUpdateWithoutRecordsInput>, docsUncheckedUpdateWithoutRecordsInput>
  }

  export type productsUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<productsCreateWithoutRecordsInput, productsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRecordsInput
    upsert?: productsUpsertWithoutRecordsInput
    disconnect?: productsWhereInput | boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutRecordsInput, productsUpdateWithoutRecordsInput>, productsUncheckedUpdateWithoutRecordsInput>
  }

  export type workshopsUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<workshopsCreateWithoutRecordsInput, workshopsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: workshopsCreateOrConnectWithoutRecordsInput
    upsert?: workshopsUpsertWithoutRecordsInput
    disconnect?: workshopsWhereInput | boolean
    delete?: workshopsWhereInput | boolean
    connect?: workshopsWhereUniqueInput
    update?: XOR<XOR<workshopsUpdateToOneWithWhereWithoutRecordsInput, workshopsUpdateWithoutRecordsInput>, workshopsUncheckedUpdateWithoutRecordsInput>
  }

  export type boilsUpdateOneWithoutRecordsNestedInput = {
    create?: XOR<boilsCreateWithoutRecordsInput, boilsUncheckedCreateWithoutRecordsInput>
    connectOrCreate?: boilsCreateOrConnectWithoutRecordsInput
    upsert?: boilsUpsertWithoutRecordsInput
    disconnect?: boilsWhereInput | boolean
    delete?: boilsWhereInput | boolean
    connect?: boilsWhereUniqueInput
    update?: XOR<XOR<boilsUpdateToOneWithWhereWithoutRecordsInput, boilsUpdateWithoutRecordsInput>, boilsUncheckedUpdateWithoutRecordsInput>
  }

  export type semi_productsUpdateManyWithoutRecordsNestedInput = {
    create?: XOR<semi_productsCreateWithoutRecordsInput, semi_productsUncheckedCreateWithoutRecordsInput> | semi_productsCreateWithoutRecordsInput[] | semi_productsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutRecordsInput | semi_productsCreateOrConnectWithoutRecordsInput[]
    upsert?: semi_productsUpsertWithWhereUniqueWithoutRecordsInput | semi_productsUpsertWithWhereUniqueWithoutRecordsInput[]
    createMany?: semi_productsCreateManyRecordsInputEnvelope
    set?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    disconnect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    delete?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    update?: semi_productsUpdateWithWhereUniqueWithoutRecordsInput | semi_productsUpdateWithWhereUniqueWithoutRecordsInput[]
    updateMany?: semi_productsUpdateManyWithWhereWithoutRecordsInput | semi_productsUpdateManyWithWhereWithoutRecordsInput[]
    deleteMany?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
  }

  export type historiesUncheckedUpdateManyWithoutRecordsNestedInput = {
    create?: XOR<historiesCreateWithoutRecordsInput, historiesUncheckedCreateWithoutRecordsInput> | historiesCreateWithoutRecordsInput[] | historiesUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutRecordsInput | historiesCreateOrConnectWithoutRecordsInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutRecordsInput | historiesUpsertWithWhereUniqueWithoutRecordsInput[]
    createMany?: historiesCreateManyRecordsInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutRecordsInput | historiesUpdateWithWhereUniqueWithoutRecordsInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutRecordsInput | historiesUpdateManyWithWhereWithoutRecordsInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput = {
    create?: XOR<record_regulationsCreateWithoutRecordsInput, record_regulationsUncheckedCreateWithoutRecordsInput> | record_regulationsCreateWithoutRecordsInput[] | record_regulationsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: record_regulationsCreateOrConnectWithoutRecordsInput | record_regulationsCreateOrConnectWithoutRecordsInput[]
    upsert?: record_regulationsUpsertWithWhereUniqueWithoutRecordsInput | record_regulationsUpsertWithWhereUniqueWithoutRecordsInput[]
    createMany?: record_regulationsCreateManyRecordsInputEnvelope
    set?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    disconnect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    delete?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    connect?: record_regulationsWhereUniqueInput | record_regulationsWhereUniqueInput[]
    update?: record_regulationsUpdateWithWhereUniqueWithoutRecordsInput | record_regulationsUpdateWithWhereUniqueWithoutRecordsInput[]
    updateMany?: record_regulationsUpdateManyWithWhereWithoutRecordsInput | record_regulationsUpdateManyWithWhereWithoutRecordsInput[]
    deleteMany?: record_regulationsScalarWhereInput | record_regulationsScalarWhereInput[]
  }

  export type semi_productsUncheckedUpdateManyWithoutRecordsNestedInput = {
    create?: XOR<semi_productsCreateWithoutRecordsInput, semi_productsUncheckedCreateWithoutRecordsInput> | semi_productsCreateWithoutRecordsInput[] | semi_productsUncheckedCreateWithoutRecordsInput[]
    connectOrCreate?: semi_productsCreateOrConnectWithoutRecordsInput | semi_productsCreateOrConnectWithoutRecordsInput[]
    upsert?: semi_productsUpsertWithWhereUniqueWithoutRecordsInput | semi_productsUpsertWithWhereUniqueWithoutRecordsInput[]
    createMany?: semi_productsCreateManyRecordsInputEnvelope
    set?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    disconnect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    delete?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    connect?: semi_productsWhereUniqueInput | semi_productsWhereUniqueInput[]
    update?: semi_productsUpdateWithWhereUniqueWithoutRecordsInput | semi_productsUpdateWithWhereUniqueWithoutRecordsInput[]
    updateMany?: semi_productsUpdateManyWithWhereWithoutRecordsInput | semi_productsUpdateManyWithWhereWithoutRecordsInput[]
    deleteMany?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
  }

  export type marking_sampleCreateNestedOneWithoutRegulationsInput = {
    create?: XOR<marking_sampleCreateWithoutRegulationsInput, marking_sampleUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: marking_sampleCreateOrConnectWithoutRegulationsInput
    connect?: marking_sampleWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutRegulationsInput = {
    create?: XOR<productsCreateWithoutRegulationsInput, productsUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRegulationsInput
    connect?: productsWhereUniqueInput
  }

  export type marking_sampleUpdateOneWithoutRegulationsNestedInput = {
    create?: XOR<marking_sampleCreateWithoutRegulationsInput, marking_sampleUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: marking_sampleCreateOrConnectWithoutRegulationsInput
    upsert?: marking_sampleUpsertWithoutRegulationsInput
    disconnect?: marking_sampleWhereInput | boolean
    delete?: marking_sampleWhereInput | boolean
    connect?: marking_sampleWhereUniqueInput
    update?: XOR<XOR<marking_sampleUpdateToOneWithWhereWithoutRegulationsInput, marking_sampleUpdateWithoutRegulationsInput>, marking_sampleUncheckedUpdateWithoutRegulationsInput>
  }

  export type productsUpdateOneWithoutRegulationsNestedInput = {
    create?: XOR<productsCreateWithoutRegulationsInput, productsUncheckedCreateWithoutRegulationsInput>
    connectOrCreate?: productsCreateOrConnectWithoutRegulationsInput
    upsert?: productsUpsertWithoutRegulationsInput
    disconnect?: productsWhereInput | boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutRegulationsInput, productsUpdateWithoutRegulationsInput>, productsUncheckedUpdateWithoutRegulationsInput>
  }

  export type user_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type user_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput> | user_rolesCreateWithoutRolesInput[] | user_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutRolesInput | user_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutRolesInput | user_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: user_rolesCreateManyRolesInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutRolesInput | user_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutRolesInput | user_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type boilsCreateNestedOneWithoutSemi_productsInput = {
    create?: XOR<boilsCreateWithoutSemi_productsInput, boilsUncheckedCreateWithoutSemi_productsInput>
    connectOrCreate?: boilsCreateOrConnectWithoutSemi_productsInput
    connect?: boilsWhereUniqueInput
  }

  export type productsCreateNestedOneWithoutSemi_productsInput = {
    create?: XOR<productsCreateWithoutSemi_productsInput, productsUncheckedCreateWithoutSemi_productsInput>
    connectOrCreate?: productsCreateOrConnectWithoutSemi_productsInput
    connect?: productsWhereUniqueInput
  }

  export type recordsCreateNestedOneWithoutSemi_productsInput = {
    create?: XOR<recordsCreateWithoutSemi_productsInput, recordsUncheckedCreateWithoutSemi_productsInput>
    connectOrCreate?: recordsCreateOrConnectWithoutSemi_productsInput
    connect?: recordsWhereUniqueInput
  }

  export type boilsUpdateOneWithoutSemi_productsNestedInput = {
    create?: XOR<boilsCreateWithoutSemi_productsInput, boilsUncheckedCreateWithoutSemi_productsInput>
    connectOrCreate?: boilsCreateOrConnectWithoutSemi_productsInput
    upsert?: boilsUpsertWithoutSemi_productsInput
    disconnect?: boilsWhereInput | boolean
    delete?: boilsWhereInput | boolean
    connect?: boilsWhereUniqueInput
    update?: XOR<XOR<boilsUpdateToOneWithWhereWithoutSemi_productsInput, boilsUpdateWithoutSemi_productsInput>, boilsUncheckedUpdateWithoutSemi_productsInput>
  }

  export type productsUpdateOneWithoutSemi_productsNestedInput = {
    create?: XOR<productsCreateWithoutSemi_productsInput, productsUncheckedCreateWithoutSemi_productsInput>
    connectOrCreate?: productsCreateOrConnectWithoutSemi_productsInput
    upsert?: productsUpsertWithoutSemi_productsInput
    disconnect?: productsWhereInput | boolean
    delete?: productsWhereInput | boolean
    connect?: productsWhereUniqueInput
    update?: XOR<XOR<productsUpdateToOneWithWhereWithoutSemi_productsInput, productsUpdateWithoutSemi_productsInput>, productsUncheckedUpdateWithoutSemi_productsInput>
  }

  export type recordsUpdateOneWithoutSemi_productsNestedInput = {
    create?: XOR<recordsCreateWithoutSemi_productsInput, recordsUncheckedCreateWithoutSemi_productsInput>
    connectOrCreate?: recordsCreateOrConnectWithoutSemi_productsInput
    upsert?: recordsUpsertWithoutSemi_productsInput
    disconnect?: recordsWhereInput | boolean
    delete?: recordsWhereInput | boolean
    connect?: recordsWhereUniqueInput
    update?: XOR<XOR<recordsUpdateToOneWithWhereWithoutSemi_productsInput, recordsUpdateWithoutSemi_productsInput>, recordsUncheckedUpdateWithoutSemi_productsInput>
  }

  export type productsCreateNestedManyWithoutSeriesInput = {
    create?: XOR<productsCreateWithoutSeriesInput, productsUncheckedCreateWithoutSeriesInput> | productsCreateWithoutSeriesInput[] | productsUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSeriesInput | productsCreateOrConnectWithoutSeriesInput[]
    createMany?: productsCreateManySeriesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type productsUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<productsCreateWithoutSeriesInput, productsUncheckedCreateWithoutSeriesInput> | productsCreateWithoutSeriesInput[] | productsUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSeriesInput | productsCreateOrConnectWithoutSeriesInput[]
    createMany?: productsCreateManySeriesInputEnvelope
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
  }

  export type productsUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<productsCreateWithoutSeriesInput, productsUncheckedCreateWithoutSeriesInput> | productsCreateWithoutSeriesInput[] | productsUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSeriesInput | productsCreateOrConnectWithoutSeriesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutSeriesInput | productsUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: productsCreateManySeriesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutSeriesInput | productsUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutSeriesInput | productsUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type productsUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<productsCreateWithoutSeriesInput, productsUncheckedCreateWithoutSeriesInput> | productsCreateWithoutSeriesInput[] | productsUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: productsCreateOrConnectWithoutSeriesInput | productsCreateOrConnectWithoutSeriesInput[]
    upsert?: productsUpsertWithWhereUniqueWithoutSeriesInput | productsUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: productsCreateManySeriesInputEnvelope
    set?: productsWhereUniqueInput | productsWhereUniqueInput[]
    disconnect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    delete?: productsWhereUniqueInput | productsWhereUniqueInput[]
    connect?: productsWhereUniqueInput | productsWhereUniqueInput[]
    update?: productsUpdateWithWhereUniqueWithoutSeriesInput | productsUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: productsUpdateManyWithWhereWithoutSeriesInput | productsUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: productsScalarWhereInput | productsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutTokensInput = {
    create?: XOR<usersCreateWithoutTokensInput, usersUncheckedCreateWithoutTokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutTokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneWithoutTokensNestedInput = {
    create?: XOR<usersCreateWithoutTokensInput, usersUncheckedCreateWithoutTokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutTokensInput
    upsert?: usersUpsertWithoutTokensInput
    disconnect?: usersWhereInput | boolean
    delete?: usersWhereInput | boolean
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutTokensInput, usersUpdateWithoutTokensInput>, usersUncheckedUpdateWithoutTokensInput>
  }

  export type tube_conveyor_postsCreateNestedOneWithoutTube_assemblyInput = {
    create?: XOR<tube_conveyor_postsCreateWithoutTube_assemblyInput, tube_conveyor_postsUncheckedCreateWithoutTube_assemblyInput>
    connectOrCreate?: tube_conveyor_postsCreateOrConnectWithoutTube_assemblyInput
    connect?: tube_conveyor_postsWhereUniqueInput
  }

  export type tube_materialsCreateNestedOneWithoutTube_assemblyInput = {
    create?: XOR<tube_materialsCreateWithoutTube_assemblyInput, tube_materialsUncheckedCreateWithoutTube_assemblyInput>
    connectOrCreate?: tube_materialsCreateOrConnectWithoutTube_assemblyInput
    connect?: tube_materialsWhereUniqueInput
  }

  export type tube_conveyor_postsUpdateOneWithoutTube_assemblyNestedInput = {
    create?: XOR<tube_conveyor_postsCreateWithoutTube_assemblyInput, tube_conveyor_postsUncheckedCreateWithoutTube_assemblyInput>
    connectOrCreate?: tube_conveyor_postsCreateOrConnectWithoutTube_assemblyInput
    upsert?: tube_conveyor_postsUpsertWithoutTube_assemblyInput
    disconnect?: tube_conveyor_postsWhereInput | boolean
    delete?: tube_conveyor_postsWhereInput | boolean
    connect?: tube_conveyor_postsWhereUniqueInput
    update?: XOR<XOR<tube_conveyor_postsUpdateToOneWithWhereWithoutTube_assemblyInput, tube_conveyor_postsUpdateWithoutTube_assemblyInput>, tube_conveyor_postsUncheckedUpdateWithoutTube_assemblyInput>
  }

  export type tube_materialsUpdateOneWithoutTube_assemblyNestedInput = {
    create?: XOR<tube_materialsCreateWithoutTube_assemblyInput, tube_materialsUncheckedCreateWithoutTube_assemblyInput>
    connectOrCreate?: tube_materialsCreateOrConnectWithoutTube_assemblyInput
    upsert?: tube_materialsUpsertWithoutTube_assemblyInput
    disconnect?: tube_materialsWhereInput | boolean
    delete?: tube_materialsWhereInput | boolean
    connect?: tube_materialsWhereUniqueInput
    update?: XOR<XOR<tube_materialsUpdateToOneWithWhereWithoutTube_assemblyInput, tube_materialsUpdateWithoutTube_assemblyInput>, tube_materialsUncheckedUpdateWithoutTube_assemblyInput>
  }

  export type tube_assemblyCreateNestedManyWithoutTube_conveyor_postsInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput> | tube_assemblyCreateWithoutTube_conveyor_postsInput[] | tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput | tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput[]
    createMany?: tube_assemblyCreateManyTube_conveyor_postsInputEnvelope
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
  }

  export type tube_assemblyUncheckedCreateNestedManyWithoutTube_conveyor_postsInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput> | tube_assemblyCreateWithoutTube_conveyor_postsInput[] | tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput | tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput[]
    createMany?: tube_assemblyCreateManyTube_conveyor_postsInputEnvelope
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
  }

  export type tube_assemblyUpdateManyWithoutTube_conveyor_postsNestedInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput> | tube_assemblyCreateWithoutTube_conveyor_postsInput[] | tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput | tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput[]
    upsert?: tube_assemblyUpsertWithWhereUniqueWithoutTube_conveyor_postsInput | tube_assemblyUpsertWithWhereUniqueWithoutTube_conveyor_postsInput[]
    createMany?: tube_assemblyCreateManyTube_conveyor_postsInputEnvelope
    set?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    disconnect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    delete?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    update?: tube_assemblyUpdateWithWhereUniqueWithoutTube_conveyor_postsInput | tube_assemblyUpdateWithWhereUniqueWithoutTube_conveyor_postsInput[]
    updateMany?: tube_assemblyUpdateManyWithWhereWithoutTube_conveyor_postsInput | tube_assemblyUpdateManyWithWhereWithoutTube_conveyor_postsInput[]
    deleteMany?: tube_assemblyScalarWhereInput | tube_assemblyScalarWhereInput[]
  }

  export type tube_assemblyUncheckedUpdateManyWithoutTube_conveyor_postsNestedInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput> | tube_assemblyCreateWithoutTube_conveyor_postsInput[] | tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput | tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput[]
    upsert?: tube_assemblyUpsertWithWhereUniqueWithoutTube_conveyor_postsInput | tube_assemblyUpsertWithWhereUniqueWithoutTube_conveyor_postsInput[]
    createMany?: tube_assemblyCreateManyTube_conveyor_postsInputEnvelope
    set?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    disconnect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    delete?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    update?: tube_assemblyUpdateWithWhereUniqueWithoutTube_conveyor_postsInput | tube_assemblyUpdateWithWhereUniqueWithoutTube_conveyor_postsInput[]
    updateMany?: tube_assemblyUpdateManyWithWhereWithoutTube_conveyor_postsInput | tube_assemblyUpdateManyWithWhereWithoutTube_conveyor_postsInput[]
    deleteMany?: tube_assemblyScalarWhereInput | tube_assemblyScalarWhereInput[]
  }

  export type tube_recordsCreateNestedManyWithoutTube_conveyorsInput = {
    create?: XOR<tube_recordsCreateWithoutTube_conveyorsInput, tube_recordsUncheckedCreateWithoutTube_conveyorsInput> | tube_recordsCreateWithoutTube_conveyorsInput[] | tube_recordsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_conveyorsInput | tube_recordsCreateOrConnectWithoutTube_conveyorsInput[]
    createMany?: tube_recordsCreateManyTube_conveyorsInputEnvelope
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
  }

  export type tube_sessionsCreateNestedManyWithoutTube_conveyorsInput = {
    create?: XOR<tube_sessionsCreateWithoutTube_conveyorsInput, tube_sessionsUncheckedCreateWithoutTube_conveyorsInput> | tube_sessionsCreateWithoutTube_conveyorsInput[] | tube_sessionsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutTube_conveyorsInput | tube_sessionsCreateOrConnectWithoutTube_conveyorsInput[]
    createMany?: tube_sessionsCreateManyTube_conveyorsInputEnvelope
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
  }

  export type tube_recordsUncheckedCreateNestedManyWithoutTube_conveyorsInput = {
    create?: XOR<tube_recordsCreateWithoutTube_conveyorsInput, tube_recordsUncheckedCreateWithoutTube_conveyorsInput> | tube_recordsCreateWithoutTube_conveyorsInput[] | tube_recordsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_conveyorsInput | tube_recordsCreateOrConnectWithoutTube_conveyorsInput[]
    createMany?: tube_recordsCreateManyTube_conveyorsInputEnvelope
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
  }

  export type tube_sessionsUncheckedCreateNestedManyWithoutTube_conveyorsInput = {
    create?: XOR<tube_sessionsCreateWithoutTube_conveyorsInput, tube_sessionsUncheckedCreateWithoutTube_conveyorsInput> | tube_sessionsCreateWithoutTube_conveyorsInput[] | tube_sessionsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutTube_conveyorsInput | tube_sessionsCreateOrConnectWithoutTube_conveyorsInput[]
    createMany?: tube_sessionsCreateManyTube_conveyorsInputEnvelope
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
  }

  export type tube_recordsUpdateManyWithoutTube_conveyorsNestedInput = {
    create?: XOR<tube_recordsCreateWithoutTube_conveyorsInput, tube_recordsUncheckedCreateWithoutTube_conveyorsInput> | tube_recordsCreateWithoutTube_conveyorsInput[] | tube_recordsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_conveyorsInput | tube_recordsCreateOrConnectWithoutTube_conveyorsInput[]
    upsert?: tube_recordsUpsertWithWhereUniqueWithoutTube_conveyorsInput | tube_recordsUpsertWithWhereUniqueWithoutTube_conveyorsInput[]
    createMany?: tube_recordsCreateManyTube_conveyorsInputEnvelope
    set?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    disconnect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    delete?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    update?: tube_recordsUpdateWithWhereUniqueWithoutTube_conveyorsInput | tube_recordsUpdateWithWhereUniqueWithoutTube_conveyorsInput[]
    updateMany?: tube_recordsUpdateManyWithWhereWithoutTube_conveyorsInput | tube_recordsUpdateManyWithWhereWithoutTube_conveyorsInput[]
    deleteMany?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
  }

  export type tube_sessionsUpdateManyWithoutTube_conveyorsNestedInput = {
    create?: XOR<tube_sessionsCreateWithoutTube_conveyorsInput, tube_sessionsUncheckedCreateWithoutTube_conveyorsInput> | tube_sessionsCreateWithoutTube_conveyorsInput[] | tube_sessionsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutTube_conveyorsInput | tube_sessionsCreateOrConnectWithoutTube_conveyorsInput[]
    upsert?: tube_sessionsUpsertWithWhereUniqueWithoutTube_conveyorsInput | tube_sessionsUpsertWithWhereUniqueWithoutTube_conveyorsInput[]
    createMany?: tube_sessionsCreateManyTube_conveyorsInputEnvelope
    set?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    disconnect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    delete?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    update?: tube_sessionsUpdateWithWhereUniqueWithoutTube_conveyorsInput | tube_sessionsUpdateWithWhereUniqueWithoutTube_conveyorsInput[]
    updateMany?: tube_sessionsUpdateManyWithWhereWithoutTube_conveyorsInput | tube_sessionsUpdateManyWithWhereWithoutTube_conveyorsInput[]
    deleteMany?: tube_sessionsScalarWhereInput | tube_sessionsScalarWhereInput[]
  }

  export type tube_recordsUncheckedUpdateManyWithoutTube_conveyorsNestedInput = {
    create?: XOR<tube_recordsCreateWithoutTube_conveyorsInput, tube_recordsUncheckedCreateWithoutTube_conveyorsInput> | tube_recordsCreateWithoutTube_conveyorsInput[] | tube_recordsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_conveyorsInput | tube_recordsCreateOrConnectWithoutTube_conveyorsInput[]
    upsert?: tube_recordsUpsertWithWhereUniqueWithoutTube_conveyorsInput | tube_recordsUpsertWithWhereUniqueWithoutTube_conveyorsInput[]
    createMany?: tube_recordsCreateManyTube_conveyorsInputEnvelope
    set?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    disconnect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    delete?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    update?: tube_recordsUpdateWithWhereUniqueWithoutTube_conveyorsInput | tube_recordsUpdateWithWhereUniqueWithoutTube_conveyorsInput[]
    updateMany?: tube_recordsUpdateManyWithWhereWithoutTube_conveyorsInput | tube_recordsUpdateManyWithWhereWithoutTube_conveyorsInput[]
    deleteMany?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
  }

  export type tube_sessionsUncheckedUpdateManyWithoutTube_conveyorsNestedInput = {
    create?: XOR<tube_sessionsCreateWithoutTube_conveyorsInput, tube_sessionsUncheckedCreateWithoutTube_conveyorsInput> | tube_sessionsCreateWithoutTube_conveyorsInput[] | tube_sessionsUncheckedCreateWithoutTube_conveyorsInput[]
    connectOrCreate?: tube_sessionsCreateOrConnectWithoutTube_conveyorsInput | tube_sessionsCreateOrConnectWithoutTube_conveyorsInput[]
    upsert?: tube_sessionsUpsertWithWhereUniqueWithoutTube_conveyorsInput | tube_sessionsUpsertWithWhereUniqueWithoutTube_conveyorsInput[]
    createMany?: tube_sessionsCreateManyTube_conveyorsInputEnvelope
    set?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    disconnect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    delete?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    connect?: tube_sessionsWhereUniqueInput | tube_sessionsWhereUniqueInput[]
    update?: tube_sessionsUpdateWithWhereUniqueWithoutTube_conveyorsInput | tube_sessionsUpdateWithWhereUniqueWithoutTube_conveyorsInput[]
    updateMany?: tube_sessionsUpdateManyWithWhereWithoutTube_conveyorsInput | tube_sessionsUpdateManyWithWhereWithoutTube_conveyorsInput[]
    deleteMany?: tube_sessionsScalarWhereInput | tube_sessionsScalarWhereInput[]
  }

  export type employeesCreateNestedOneWithoutTube_historiesInput = {
    create?: XOR<employeesCreateWithoutTube_historiesInput, employeesUncheckedCreateWithoutTube_historiesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutTube_historiesInput
    connect?: employeesWhereUniqueInput
  }

  export type tube_histories_notesCreateNestedOneWithoutTube_historiesInput = {
    create?: XOR<tube_histories_notesCreateWithoutTube_historiesInput, tube_histories_notesUncheckedCreateWithoutTube_historiesInput>
    connectOrCreate?: tube_histories_notesCreateOrConnectWithoutTube_historiesInput
    connect?: tube_histories_notesWhereUniqueInput
  }

  export type tube_history_typesCreateNestedOneWithoutTube_historiesInput = {
    create?: XOR<tube_history_typesCreateWithoutTube_historiesInput, tube_history_typesUncheckedCreateWithoutTube_historiesInput>
    connectOrCreate?: tube_history_typesCreateOrConnectWithoutTube_historiesInput
    connect?: tube_history_typesWhereUniqueInput
  }

  export type employeesUpdateOneWithoutTube_historiesNestedInput = {
    create?: XOR<employeesCreateWithoutTube_historiesInput, employeesUncheckedCreateWithoutTube_historiesInput>
    connectOrCreate?: employeesCreateOrConnectWithoutTube_historiesInput
    upsert?: employeesUpsertWithoutTube_historiesInput
    disconnect?: employeesWhereInput | boolean
    delete?: employeesWhereInput | boolean
    connect?: employeesWhereUniqueInput
    update?: XOR<XOR<employeesUpdateToOneWithWhereWithoutTube_historiesInput, employeesUpdateWithoutTube_historiesInput>, employeesUncheckedUpdateWithoutTube_historiesInput>
  }

  export type tube_histories_notesUpdateOneWithoutTube_historiesNestedInput = {
    create?: XOR<tube_histories_notesCreateWithoutTube_historiesInput, tube_histories_notesUncheckedCreateWithoutTube_historiesInput>
    connectOrCreate?: tube_histories_notesCreateOrConnectWithoutTube_historiesInput
    upsert?: tube_histories_notesUpsertWithoutTube_historiesInput
    disconnect?: tube_histories_notesWhereInput | boolean
    delete?: tube_histories_notesWhereInput | boolean
    connect?: tube_histories_notesWhereUniqueInput
    update?: XOR<XOR<tube_histories_notesUpdateToOneWithWhereWithoutTube_historiesInput, tube_histories_notesUpdateWithoutTube_historiesInput>, tube_histories_notesUncheckedUpdateWithoutTube_historiesInput>
  }

  export type tube_history_typesUpdateOneWithoutTube_historiesNestedInput = {
    create?: XOR<tube_history_typesCreateWithoutTube_historiesInput, tube_history_typesUncheckedCreateWithoutTube_historiesInput>
    connectOrCreate?: tube_history_typesCreateOrConnectWithoutTube_historiesInput
    upsert?: tube_history_typesUpsertWithoutTube_historiesInput
    disconnect?: tube_history_typesWhereInput | boolean
    delete?: tube_history_typesWhereInput | boolean
    connect?: tube_history_typesWhereUniqueInput
    update?: XOR<XOR<tube_history_typesUpdateToOneWithWhereWithoutTube_historiesInput, tube_history_typesUpdateWithoutTube_historiesInput>, tube_history_typesUncheckedUpdateWithoutTube_historiesInput>
  }

  export type tube_historiesCreateNestedManyWithoutTube_histories_notesInput = {
    create?: XOR<tube_historiesCreateWithoutTube_histories_notesInput, tube_historiesUncheckedCreateWithoutTube_histories_notesInput> | tube_historiesCreateWithoutTube_histories_notesInput[] | tube_historiesUncheckedCreateWithoutTube_histories_notesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_histories_notesInput | tube_historiesCreateOrConnectWithoutTube_histories_notesInput[]
    createMany?: tube_historiesCreateManyTube_histories_notesInputEnvelope
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
  }

  export type tube_historiesUncheckedCreateNestedManyWithoutTube_histories_notesInput = {
    create?: XOR<tube_historiesCreateWithoutTube_histories_notesInput, tube_historiesUncheckedCreateWithoutTube_histories_notesInput> | tube_historiesCreateWithoutTube_histories_notesInput[] | tube_historiesUncheckedCreateWithoutTube_histories_notesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_histories_notesInput | tube_historiesCreateOrConnectWithoutTube_histories_notesInput[]
    createMany?: tube_historiesCreateManyTube_histories_notesInputEnvelope
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
  }

  export type tube_historiesUpdateManyWithoutTube_histories_notesNestedInput = {
    create?: XOR<tube_historiesCreateWithoutTube_histories_notesInput, tube_historiesUncheckedCreateWithoutTube_histories_notesInput> | tube_historiesCreateWithoutTube_histories_notesInput[] | tube_historiesUncheckedCreateWithoutTube_histories_notesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_histories_notesInput | tube_historiesCreateOrConnectWithoutTube_histories_notesInput[]
    upsert?: tube_historiesUpsertWithWhereUniqueWithoutTube_histories_notesInput | tube_historiesUpsertWithWhereUniqueWithoutTube_histories_notesInput[]
    createMany?: tube_historiesCreateManyTube_histories_notesInputEnvelope
    set?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    disconnect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    delete?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    update?: tube_historiesUpdateWithWhereUniqueWithoutTube_histories_notesInput | tube_historiesUpdateWithWhereUniqueWithoutTube_histories_notesInput[]
    updateMany?: tube_historiesUpdateManyWithWhereWithoutTube_histories_notesInput | tube_historiesUpdateManyWithWhereWithoutTube_histories_notesInput[]
    deleteMany?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
  }

  export type tube_historiesUncheckedUpdateManyWithoutTube_histories_notesNestedInput = {
    create?: XOR<tube_historiesCreateWithoutTube_histories_notesInput, tube_historiesUncheckedCreateWithoutTube_histories_notesInput> | tube_historiesCreateWithoutTube_histories_notesInput[] | tube_historiesUncheckedCreateWithoutTube_histories_notesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_histories_notesInput | tube_historiesCreateOrConnectWithoutTube_histories_notesInput[]
    upsert?: tube_historiesUpsertWithWhereUniqueWithoutTube_histories_notesInput | tube_historiesUpsertWithWhereUniqueWithoutTube_histories_notesInput[]
    createMany?: tube_historiesCreateManyTube_histories_notesInputEnvelope
    set?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    disconnect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    delete?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    update?: tube_historiesUpdateWithWhereUniqueWithoutTube_histories_notesInput | tube_historiesUpdateWithWhereUniqueWithoutTube_histories_notesInput[]
    updateMany?: tube_historiesUpdateManyWithWhereWithoutTube_histories_notesInput | tube_historiesUpdateManyWithWhereWithoutTube_histories_notesInput[]
    deleteMany?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
  }

  export type tube_historiesCreateNestedManyWithoutTube_history_typesInput = {
    create?: XOR<tube_historiesCreateWithoutTube_history_typesInput, tube_historiesUncheckedCreateWithoutTube_history_typesInput> | tube_historiesCreateWithoutTube_history_typesInput[] | tube_historiesUncheckedCreateWithoutTube_history_typesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_history_typesInput | tube_historiesCreateOrConnectWithoutTube_history_typesInput[]
    createMany?: tube_historiesCreateManyTube_history_typesInputEnvelope
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
  }

  export type tube_historiesUncheckedCreateNestedManyWithoutTube_history_typesInput = {
    create?: XOR<tube_historiesCreateWithoutTube_history_typesInput, tube_historiesUncheckedCreateWithoutTube_history_typesInput> | tube_historiesCreateWithoutTube_history_typesInput[] | tube_historiesUncheckedCreateWithoutTube_history_typesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_history_typesInput | tube_historiesCreateOrConnectWithoutTube_history_typesInput[]
    createMany?: tube_historiesCreateManyTube_history_typesInputEnvelope
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
  }

  export type tube_historiesUpdateManyWithoutTube_history_typesNestedInput = {
    create?: XOR<tube_historiesCreateWithoutTube_history_typesInput, tube_historiesUncheckedCreateWithoutTube_history_typesInput> | tube_historiesCreateWithoutTube_history_typesInput[] | tube_historiesUncheckedCreateWithoutTube_history_typesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_history_typesInput | tube_historiesCreateOrConnectWithoutTube_history_typesInput[]
    upsert?: tube_historiesUpsertWithWhereUniqueWithoutTube_history_typesInput | tube_historiesUpsertWithWhereUniqueWithoutTube_history_typesInput[]
    createMany?: tube_historiesCreateManyTube_history_typesInputEnvelope
    set?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    disconnect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    delete?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    update?: tube_historiesUpdateWithWhereUniqueWithoutTube_history_typesInput | tube_historiesUpdateWithWhereUniqueWithoutTube_history_typesInput[]
    updateMany?: tube_historiesUpdateManyWithWhereWithoutTube_history_typesInput | tube_historiesUpdateManyWithWhereWithoutTube_history_typesInput[]
    deleteMany?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
  }

  export type tube_historiesUncheckedUpdateManyWithoutTube_history_typesNestedInput = {
    create?: XOR<tube_historiesCreateWithoutTube_history_typesInput, tube_historiesUncheckedCreateWithoutTube_history_typesInput> | tube_historiesCreateWithoutTube_history_typesInput[] | tube_historiesUncheckedCreateWithoutTube_history_typesInput[]
    connectOrCreate?: tube_historiesCreateOrConnectWithoutTube_history_typesInput | tube_historiesCreateOrConnectWithoutTube_history_typesInput[]
    upsert?: tube_historiesUpsertWithWhereUniqueWithoutTube_history_typesInput | tube_historiesUpsertWithWhereUniqueWithoutTube_history_typesInput[]
    createMany?: tube_historiesCreateManyTube_history_typesInputEnvelope
    set?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    disconnect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    delete?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    connect?: tube_historiesWhereUniqueInput | tube_historiesWhereUniqueInput[]
    update?: tube_historiesUpdateWithWhereUniqueWithoutTube_history_typesInput | tube_historiesUpdateWithWhereUniqueWithoutTube_history_typesInput[]
    updateMany?: tube_historiesUpdateManyWithWhereWithoutTube_history_typesInput | tube_historiesUpdateManyWithWhereWithoutTube_history_typesInput[]
    deleteMany?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
  }

  export type tube_assemblyCreateNestedManyWithoutTube_materialsInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_materialsInput, tube_assemblyUncheckedCreateWithoutTube_materialsInput> | tube_assemblyCreateWithoutTube_materialsInput[] | tube_assemblyUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_materialsInput | tube_assemblyCreateOrConnectWithoutTube_materialsInput[]
    createMany?: tube_assemblyCreateManyTube_materialsInputEnvelope
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
  }

  export type tube_specificationsCreateNestedManyWithoutTube_materialsInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_materialsInput, tube_specificationsUncheckedCreateWithoutTube_materialsInput> | tube_specificationsCreateWithoutTube_materialsInput[] | tube_specificationsUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_materialsInput | tube_specificationsCreateOrConnectWithoutTube_materialsInput[]
    createMany?: tube_specificationsCreateManyTube_materialsInputEnvelope
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
  }

  export type tube_assemblyUncheckedCreateNestedManyWithoutTube_materialsInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_materialsInput, tube_assemblyUncheckedCreateWithoutTube_materialsInput> | tube_assemblyCreateWithoutTube_materialsInput[] | tube_assemblyUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_materialsInput | tube_assemblyCreateOrConnectWithoutTube_materialsInput[]
    createMany?: tube_assemblyCreateManyTube_materialsInputEnvelope
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
  }

  export type tube_specificationsUncheckedCreateNestedManyWithoutTube_materialsInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_materialsInput, tube_specificationsUncheckedCreateWithoutTube_materialsInput> | tube_specificationsCreateWithoutTube_materialsInput[] | tube_specificationsUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_materialsInput | tube_specificationsCreateOrConnectWithoutTube_materialsInput[]
    createMany?: tube_specificationsCreateManyTube_materialsInputEnvelope
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
  }

  export type tube_assemblyUpdateManyWithoutTube_materialsNestedInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_materialsInput, tube_assemblyUncheckedCreateWithoutTube_materialsInput> | tube_assemblyCreateWithoutTube_materialsInput[] | tube_assemblyUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_materialsInput | tube_assemblyCreateOrConnectWithoutTube_materialsInput[]
    upsert?: tube_assemblyUpsertWithWhereUniqueWithoutTube_materialsInput | tube_assemblyUpsertWithWhereUniqueWithoutTube_materialsInput[]
    createMany?: tube_assemblyCreateManyTube_materialsInputEnvelope
    set?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    disconnect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    delete?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    update?: tube_assemblyUpdateWithWhereUniqueWithoutTube_materialsInput | tube_assemblyUpdateWithWhereUniqueWithoutTube_materialsInput[]
    updateMany?: tube_assemblyUpdateManyWithWhereWithoutTube_materialsInput | tube_assemblyUpdateManyWithWhereWithoutTube_materialsInput[]
    deleteMany?: tube_assemblyScalarWhereInput | tube_assemblyScalarWhereInput[]
  }

  export type tube_specificationsUpdateManyWithoutTube_materialsNestedInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_materialsInput, tube_specificationsUncheckedCreateWithoutTube_materialsInput> | tube_specificationsCreateWithoutTube_materialsInput[] | tube_specificationsUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_materialsInput | tube_specificationsCreateOrConnectWithoutTube_materialsInput[]
    upsert?: tube_specificationsUpsertWithWhereUniqueWithoutTube_materialsInput | tube_specificationsUpsertWithWhereUniqueWithoutTube_materialsInput[]
    createMany?: tube_specificationsCreateManyTube_materialsInputEnvelope
    set?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    disconnect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    delete?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    update?: tube_specificationsUpdateWithWhereUniqueWithoutTube_materialsInput | tube_specificationsUpdateWithWhereUniqueWithoutTube_materialsInput[]
    updateMany?: tube_specificationsUpdateManyWithWhereWithoutTube_materialsInput | tube_specificationsUpdateManyWithWhereWithoutTube_materialsInput[]
    deleteMany?: tube_specificationsScalarWhereInput | tube_specificationsScalarWhereInput[]
  }

  export type tube_assemblyUncheckedUpdateManyWithoutTube_materialsNestedInput = {
    create?: XOR<tube_assemblyCreateWithoutTube_materialsInput, tube_assemblyUncheckedCreateWithoutTube_materialsInput> | tube_assemblyCreateWithoutTube_materialsInput[] | tube_assemblyUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_assemblyCreateOrConnectWithoutTube_materialsInput | tube_assemblyCreateOrConnectWithoutTube_materialsInput[]
    upsert?: tube_assemblyUpsertWithWhereUniqueWithoutTube_materialsInput | tube_assemblyUpsertWithWhereUniqueWithoutTube_materialsInput[]
    createMany?: tube_assemblyCreateManyTube_materialsInputEnvelope
    set?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    disconnect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    delete?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    connect?: tube_assemblyWhereUniqueInput | tube_assemblyWhereUniqueInput[]
    update?: tube_assemblyUpdateWithWhereUniqueWithoutTube_materialsInput | tube_assemblyUpdateWithWhereUniqueWithoutTube_materialsInput[]
    updateMany?: tube_assemblyUpdateManyWithWhereWithoutTube_materialsInput | tube_assemblyUpdateManyWithWhereWithoutTube_materialsInput[]
    deleteMany?: tube_assemblyScalarWhereInput | tube_assemblyScalarWhereInput[]
  }

  export type tube_specificationsUncheckedUpdateManyWithoutTube_materialsNestedInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_materialsInput, tube_specificationsUncheckedCreateWithoutTube_materialsInput> | tube_specificationsCreateWithoutTube_materialsInput[] | tube_specificationsUncheckedCreateWithoutTube_materialsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_materialsInput | tube_specificationsCreateOrConnectWithoutTube_materialsInput[]
    upsert?: tube_specificationsUpsertWithWhereUniqueWithoutTube_materialsInput | tube_specificationsUpsertWithWhereUniqueWithoutTube_materialsInput[]
    createMany?: tube_specificationsCreateManyTube_materialsInputEnvelope
    set?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    disconnect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    delete?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    update?: tube_specificationsUpdateWithWhereUniqueWithoutTube_materialsInput | tube_specificationsUpdateWithWhereUniqueWithoutTube_materialsInput[]
    updateMany?: tube_specificationsUpdateManyWithWhereWithoutTube_materialsInput | tube_specificationsUpdateManyWithWhereWithoutTube_materialsInput[]
    deleteMany?: tube_specificationsScalarWhereInput | tube_specificationsScalarWhereInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type tube_recordsCreateNestedManyWithoutTube_productsInput = {
    create?: XOR<tube_recordsCreateWithoutTube_productsInput, tube_recordsUncheckedCreateWithoutTube_productsInput> | tube_recordsCreateWithoutTube_productsInput[] | tube_recordsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_productsInput | tube_recordsCreateOrConnectWithoutTube_productsInput[]
    createMany?: tube_recordsCreateManyTube_productsInputEnvelope
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
  }

  export type tube_specificationsCreateNestedManyWithoutTube_productsInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_productsInput, tube_specificationsUncheckedCreateWithoutTube_productsInput> | tube_specificationsCreateWithoutTube_productsInput[] | tube_specificationsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_productsInput | tube_specificationsCreateOrConnectWithoutTube_productsInput[]
    createMany?: tube_specificationsCreateManyTube_productsInputEnvelope
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
  }

  export type tube_recordsUncheckedCreateNestedManyWithoutTube_productsInput = {
    create?: XOR<tube_recordsCreateWithoutTube_productsInput, tube_recordsUncheckedCreateWithoutTube_productsInput> | tube_recordsCreateWithoutTube_productsInput[] | tube_recordsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_productsInput | tube_recordsCreateOrConnectWithoutTube_productsInput[]
    createMany?: tube_recordsCreateManyTube_productsInputEnvelope
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
  }

  export type tube_specificationsUncheckedCreateNestedManyWithoutTube_productsInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_productsInput, tube_specificationsUncheckedCreateWithoutTube_productsInput> | tube_specificationsCreateWithoutTube_productsInput[] | tube_specificationsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_productsInput | tube_specificationsCreateOrConnectWithoutTube_productsInput[]
    createMany?: tube_specificationsCreateManyTube_productsInputEnvelope
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
  }

  export type tube_recordsUpdateManyWithoutTube_productsNestedInput = {
    create?: XOR<tube_recordsCreateWithoutTube_productsInput, tube_recordsUncheckedCreateWithoutTube_productsInput> | tube_recordsCreateWithoutTube_productsInput[] | tube_recordsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_productsInput | tube_recordsCreateOrConnectWithoutTube_productsInput[]
    upsert?: tube_recordsUpsertWithWhereUniqueWithoutTube_productsInput | tube_recordsUpsertWithWhereUniqueWithoutTube_productsInput[]
    createMany?: tube_recordsCreateManyTube_productsInputEnvelope
    set?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    disconnect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    delete?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    update?: tube_recordsUpdateWithWhereUniqueWithoutTube_productsInput | tube_recordsUpdateWithWhereUniqueWithoutTube_productsInput[]
    updateMany?: tube_recordsUpdateManyWithWhereWithoutTube_productsInput | tube_recordsUpdateManyWithWhereWithoutTube_productsInput[]
    deleteMany?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
  }

  export type tube_specificationsUpdateManyWithoutTube_productsNestedInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_productsInput, tube_specificationsUncheckedCreateWithoutTube_productsInput> | tube_specificationsCreateWithoutTube_productsInput[] | tube_specificationsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_productsInput | tube_specificationsCreateOrConnectWithoutTube_productsInput[]
    upsert?: tube_specificationsUpsertWithWhereUniqueWithoutTube_productsInput | tube_specificationsUpsertWithWhereUniqueWithoutTube_productsInput[]
    createMany?: tube_specificationsCreateManyTube_productsInputEnvelope
    set?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    disconnect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    delete?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    update?: tube_specificationsUpdateWithWhereUniqueWithoutTube_productsInput | tube_specificationsUpdateWithWhereUniqueWithoutTube_productsInput[]
    updateMany?: tube_specificationsUpdateManyWithWhereWithoutTube_productsInput | tube_specificationsUpdateManyWithWhereWithoutTube_productsInput[]
    deleteMany?: tube_specificationsScalarWhereInput | tube_specificationsScalarWhereInput[]
  }

  export type tube_recordsUncheckedUpdateManyWithoutTube_productsNestedInput = {
    create?: XOR<tube_recordsCreateWithoutTube_productsInput, tube_recordsUncheckedCreateWithoutTube_productsInput> | tube_recordsCreateWithoutTube_productsInput[] | tube_recordsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_recordsCreateOrConnectWithoutTube_productsInput | tube_recordsCreateOrConnectWithoutTube_productsInput[]
    upsert?: tube_recordsUpsertWithWhereUniqueWithoutTube_productsInput | tube_recordsUpsertWithWhereUniqueWithoutTube_productsInput[]
    createMany?: tube_recordsCreateManyTube_productsInputEnvelope
    set?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    disconnect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    delete?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    connect?: tube_recordsWhereUniqueInput | tube_recordsWhereUniqueInput[]
    update?: tube_recordsUpdateWithWhereUniqueWithoutTube_productsInput | tube_recordsUpdateWithWhereUniqueWithoutTube_productsInput[]
    updateMany?: tube_recordsUpdateManyWithWhereWithoutTube_productsInput | tube_recordsUpdateManyWithWhereWithoutTube_productsInput[]
    deleteMany?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
  }

  export type tube_specificationsUncheckedUpdateManyWithoutTube_productsNestedInput = {
    create?: XOR<tube_specificationsCreateWithoutTube_productsInput, tube_specificationsUncheckedCreateWithoutTube_productsInput> | tube_specificationsCreateWithoutTube_productsInput[] | tube_specificationsUncheckedCreateWithoutTube_productsInput[]
    connectOrCreate?: tube_specificationsCreateOrConnectWithoutTube_productsInput | tube_specificationsCreateOrConnectWithoutTube_productsInput[]
    upsert?: tube_specificationsUpsertWithWhereUniqueWithoutTube_productsInput | tube_specificationsUpsertWithWhereUniqueWithoutTube_productsInput[]
    createMany?: tube_specificationsCreateManyTube_productsInputEnvelope
    set?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    disconnect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    delete?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    connect?: tube_specificationsWhereUniqueInput | tube_specificationsWhereUniqueInput[]
    update?: tube_specificationsUpdateWithWhereUniqueWithoutTube_productsInput | tube_specificationsUpdateWithWhereUniqueWithoutTube_productsInput[]
    updateMany?: tube_specificationsUpdateManyWithWhereWithoutTube_productsInput | tube_specificationsUpdateManyWithWhereWithoutTube_productsInput[]
    deleteMany?: tube_specificationsScalarWhereInput | tube_specificationsScalarWhereInput[]
  }

  export type boilsCreateNestedOneWithoutTube_recordsInput = {
    create?: XOR<boilsCreateWithoutTube_recordsInput, boilsUncheckedCreateWithoutTube_recordsInput>
    connectOrCreate?: boilsCreateOrConnectWithoutTube_recordsInput
    connect?: boilsWhereUniqueInput
  }

  export type tube_conveyorsCreateNestedOneWithoutTube_recordsInput = {
    create?: XOR<tube_conveyorsCreateWithoutTube_recordsInput, tube_conveyorsUncheckedCreateWithoutTube_recordsInput>
    connectOrCreate?: tube_conveyorsCreateOrConnectWithoutTube_recordsInput
    connect?: tube_conveyorsWhereUniqueInput
  }

  export type tube_productsCreateNestedOneWithoutTube_recordsInput = {
    create?: XOR<tube_productsCreateWithoutTube_recordsInput, tube_productsUncheckedCreateWithoutTube_recordsInput>
    connectOrCreate?: tube_productsCreateOrConnectWithoutTube_recordsInput
    connect?: tube_productsWhereUniqueInput
  }

  export type boilsUpdateOneWithoutTube_recordsNestedInput = {
    create?: XOR<boilsCreateWithoutTube_recordsInput, boilsUncheckedCreateWithoutTube_recordsInput>
    connectOrCreate?: boilsCreateOrConnectWithoutTube_recordsInput
    upsert?: boilsUpsertWithoutTube_recordsInput
    disconnect?: boilsWhereInput | boolean
    delete?: boilsWhereInput | boolean
    connect?: boilsWhereUniqueInput
    update?: XOR<XOR<boilsUpdateToOneWithWhereWithoutTube_recordsInput, boilsUpdateWithoutTube_recordsInput>, boilsUncheckedUpdateWithoutTube_recordsInput>
  }

  export type tube_conveyorsUpdateOneWithoutTube_recordsNestedInput = {
    create?: XOR<tube_conveyorsCreateWithoutTube_recordsInput, tube_conveyorsUncheckedCreateWithoutTube_recordsInput>
    connectOrCreate?: tube_conveyorsCreateOrConnectWithoutTube_recordsInput
    upsert?: tube_conveyorsUpsertWithoutTube_recordsInput
    disconnect?: tube_conveyorsWhereInput | boolean
    delete?: tube_conveyorsWhereInput | boolean
    connect?: tube_conveyorsWhereUniqueInput
    update?: XOR<XOR<tube_conveyorsUpdateToOneWithWhereWithoutTube_recordsInput, tube_conveyorsUpdateWithoutTube_recordsInput>, tube_conveyorsUncheckedUpdateWithoutTube_recordsInput>
  }

  export type tube_productsUpdateOneWithoutTube_recordsNestedInput = {
    create?: XOR<tube_productsCreateWithoutTube_recordsInput, tube_productsUncheckedCreateWithoutTube_recordsInput>
    connectOrCreate?: tube_productsCreateOrConnectWithoutTube_recordsInput
    upsert?: tube_productsUpsertWithoutTube_recordsInput
    disconnect?: tube_productsWhereInput | boolean
    delete?: tube_productsWhereInput | boolean
    connect?: tube_productsWhereUniqueInput
    update?: XOR<XOR<tube_productsUpdateToOneWithWhereWithoutTube_recordsInput, tube_productsUpdateWithoutTube_recordsInput>, tube_productsUncheckedUpdateWithoutTube_recordsInput>
  }

  export type tube_conveyorsCreateNestedOneWithoutTube_sessionsInput = {
    create?: XOR<tube_conveyorsCreateWithoutTube_sessionsInput, tube_conveyorsUncheckedCreateWithoutTube_sessionsInput>
    connectOrCreate?: tube_conveyorsCreateOrConnectWithoutTube_sessionsInput
    connect?: tube_conveyorsWhereUniqueInput
  }

  export type employeesCreateNestedOneWithoutTube_sessionsInput = {
    create?: XOR<employeesCreateWithoutTube_sessionsInput, employeesUncheckedCreateWithoutTube_sessionsInput>
    connectOrCreate?: employeesCreateOrConnectWithoutTube_sessionsInput
    connect?: employeesWhereUniqueInput
  }

  export type tube_conveyorsUpdateOneWithoutTube_sessionsNestedInput = {
    create?: XOR<tube_conveyorsCreateWithoutTube_sessionsInput, tube_conveyorsUncheckedCreateWithoutTube_sessionsInput>
    connectOrCreate?: tube_conveyorsCreateOrConnectWithoutTube_sessionsInput
    upsert?: tube_conveyorsUpsertWithoutTube_sessionsInput
    disconnect?: tube_conveyorsWhereInput | boolean
    delete?: tube_conveyorsWhereInput | boolean
    connect?: tube_conveyorsWhereUniqueInput
    update?: XOR<XOR<tube_conveyorsUpdateToOneWithWhereWithoutTube_sessionsInput, tube_conveyorsUpdateWithoutTube_sessionsInput>, tube_conveyorsUncheckedUpdateWithoutTube_sessionsInput>
  }

  export type employeesUpdateOneWithoutTube_sessionsNestedInput = {
    create?: XOR<employeesCreateWithoutTube_sessionsInput, employeesUncheckedCreateWithoutTube_sessionsInput>
    connectOrCreate?: employeesCreateOrConnectWithoutTube_sessionsInput
    upsert?: employeesUpsertWithoutTube_sessionsInput
    disconnect?: employeesWhereInput | boolean
    delete?: employeesWhereInput | boolean
    connect?: employeesWhereUniqueInput
    update?: XOR<XOR<employeesUpdateToOneWithWhereWithoutTube_sessionsInput, employeesUpdateWithoutTube_sessionsInput>, employeesUncheckedUpdateWithoutTube_sessionsInput>
  }

  export type tube_materialsCreateNestedOneWithoutTube_specificationsInput = {
    create?: XOR<tube_materialsCreateWithoutTube_specificationsInput, tube_materialsUncheckedCreateWithoutTube_specificationsInput>
    connectOrCreate?: tube_materialsCreateOrConnectWithoutTube_specificationsInput
    connect?: tube_materialsWhereUniqueInput
  }

  export type tube_productsCreateNestedOneWithoutTube_specificationsInput = {
    create?: XOR<tube_productsCreateWithoutTube_specificationsInput, tube_productsUncheckedCreateWithoutTube_specificationsInput>
    connectOrCreate?: tube_productsCreateOrConnectWithoutTube_specificationsInput
    connect?: tube_productsWhereUniqueInput
  }

  export type tube_materialsUpdateOneWithoutTube_specificationsNestedInput = {
    create?: XOR<tube_materialsCreateWithoutTube_specificationsInput, tube_materialsUncheckedCreateWithoutTube_specificationsInput>
    connectOrCreate?: tube_materialsCreateOrConnectWithoutTube_specificationsInput
    upsert?: tube_materialsUpsertWithoutTube_specificationsInput
    disconnect?: tube_materialsWhereInput | boolean
    delete?: tube_materialsWhereInput | boolean
    connect?: tube_materialsWhereUniqueInput
    update?: XOR<XOR<tube_materialsUpdateToOneWithWhereWithoutTube_specificationsInput, tube_materialsUpdateWithoutTube_specificationsInput>, tube_materialsUncheckedUpdateWithoutTube_specificationsInput>
  }

  export type tube_productsUpdateOneWithoutTube_specificationsNestedInput = {
    create?: XOR<tube_productsCreateWithoutTube_specificationsInput, tube_productsUncheckedCreateWithoutTube_specificationsInput>
    connectOrCreate?: tube_productsCreateOrConnectWithoutTube_specificationsInput
    upsert?: tube_productsUpsertWithoutTube_specificationsInput
    disconnect?: tube_productsWhereInput | boolean
    delete?: tube_productsWhereInput | boolean
    connect?: tube_productsWhereUniqueInput
    update?: XOR<XOR<tube_productsUpdateToOneWithWhereWithoutTube_specificationsInput, tube_productsUpdateWithoutTube_specificationsInput>, tube_productsUncheckedUpdateWithoutTube_specificationsInput>
  }

  export type rolesCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUser_rolesInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUser_rolesInput
    upsert?: rolesUpsertWithoutUser_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUser_rolesInput, rolesUpdateWithoutUser_rolesInput>, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type usersUpdateOneRequiredWithoutUser_rolesNestedInput = {
    create?: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_rolesInput
    upsert?: usersUpsertWithoutUser_rolesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUser_rolesInput, usersUpdateWithoutUser_rolesInput>, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type historiesCreateNestedManyWithoutUsersInput = {
    create?: XOR<historiesCreateWithoutUsersInput, historiesUncheckedCreateWithoutUsersInput> | historiesCreateWithoutUsersInput[] | historiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutUsersInput | historiesCreateOrConnectWithoutUsersInput[]
    createMany?: historiesCreateManyUsersInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type tokensCreateNestedManyWithoutUsersInput = {
    create?: XOR<tokensCreateWithoutUsersInput, tokensUncheckedCreateWithoutUsersInput> | tokensCreateWithoutUsersInput[] | tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tokensCreateOrConnectWithoutUsersInput | tokensCreateOrConnectWithoutUsersInput[]
    createMany?: tokensCreateManyUsersInputEnvelope
    connect?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
  }

  export type user_rolesCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type historiesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<historiesCreateWithoutUsersInput, historiesUncheckedCreateWithoutUsersInput> | historiesCreateWithoutUsersInput[] | historiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutUsersInput | historiesCreateOrConnectWithoutUsersInput[]
    createMany?: historiesCreateManyUsersInputEnvelope
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
  }

  export type tokensUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<tokensCreateWithoutUsersInput, tokensUncheckedCreateWithoutUsersInput> | tokensCreateWithoutUsersInput[] | tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tokensCreateOrConnectWithoutUsersInput | tokensCreateOrConnectWithoutUsersInput[]
    createMany?: tokensCreateManyUsersInputEnvelope
    connect?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
  }

  export type user_rolesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
  }

  export type historiesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<historiesCreateWithoutUsersInput, historiesUncheckedCreateWithoutUsersInput> | historiesCreateWithoutUsersInput[] | historiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutUsersInput | historiesCreateOrConnectWithoutUsersInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutUsersInput | historiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: historiesCreateManyUsersInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutUsersInput | historiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutUsersInput | historiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type tokensUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tokensCreateWithoutUsersInput, tokensUncheckedCreateWithoutUsersInput> | tokensCreateWithoutUsersInput[] | tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tokensCreateOrConnectWithoutUsersInput | tokensCreateOrConnectWithoutUsersInput[]
    upsert?: tokensUpsertWithWhereUniqueWithoutUsersInput | tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tokensCreateManyUsersInputEnvelope
    set?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    disconnect?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    delete?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    connect?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    update?: tokensUpdateWithWhereUniqueWithoutUsersInput | tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tokensUpdateManyWithWhereWithoutUsersInput | tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tokensScalarWhereInput | tokensScalarWhereInput[]
  }

  export type user_rolesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type historiesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<historiesCreateWithoutUsersInput, historiesUncheckedCreateWithoutUsersInput> | historiesCreateWithoutUsersInput[] | historiesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: historiesCreateOrConnectWithoutUsersInput | historiesCreateOrConnectWithoutUsersInput[]
    upsert?: historiesUpsertWithWhereUniqueWithoutUsersInput | historiesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: historiesCreateManyUsersInputEnvelope
    set?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    disconnect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    delete?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    connect?: historiesWhereUniqueInput | historiesWhereUniqueInput[]
    update?: historiesUpdateWithWhereUniqueWithoutUsersInput | historiesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: historiesUpdateManyWithWhereWithoutUsersInput | historiesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: historiesScalarWhereInput | historiesScalarWhereInput[]
  }

  export type tokensUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<tokensCreateWithoutUsersInput, tokensUncheckedCreateWithoutUsersInput> | tokensCreateWithoutUsersInput[] | tokensUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: tokensCreateOrConnectWithoutUsersInput | tokensCreateOrConnectWithoutUsersInput[]
    upsert?: tokensUpsertWithWhereUniqueWithoutUsersInput | tokensUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: tokensCreateManyUsersInputEnvelope
    set?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    disconnect?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    delete?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    connect?: tokensWhereUniqueInput | tokensWhereUniqueInput[]
    update?: tokensUpdateWithWhereUniqueWithoutUsersInput | tokensUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: tokensUpdateManyWithWhereWithoutUsersInput | tokensUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: tokensScalarWhereInput | tokensScalarWhereInput[]
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput> | user_rolesCreateWithoutUsersInput[] | user_rolesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: user_rolesCreateOrConnectWithoutUsersInput | user_rolesCreateOrConnectWithoutUsersInput[]
    upsert?: user_rolesUpsertWithWhereUniqueWithoutUsersInput | user_rolesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: user_rolesCreateManyUsersInputEnvelope
    set?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    disconnect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    delete?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    connect?: user_rolesWhereUniqueInput | user_rolesWhereUniqueInput[]
    update?: user_rolesUpdateWithWhereUniqueWithoutUsersInput | user_rolesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: user_rolesUpdateManyWithWhereWithoutUsersInput | user_rolesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
  }

  export type recordsCreateNestedManyWithoutWorkshopsInput = {
    create?: XOR<recordsCreateWithoutWorkshopsInput, recordsUncheckedCreateWithoutWorkshopsInput> | recordsCreateWithoutWorkshopsInput[] | recordsUncheckedCreateWithoutWorkshopsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutWorkshopsInput | recordsCreateOrConnectWithoutWorkshopsInput[]
    createMany?: recordsCreateManyWorkshopsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUncheckedCreateNestedManyWithoutWorkshopsInput = {
    create?: XOR<recordsCreateWithoutWorkshopsInput, recordsUncheckedCreateWithoutWorkshopsInput> | recordsCreateWithoutWorkshopsInput[] | recordsUncheckedCreateWithoutWorkshopsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutWorkshopsInput | recordsCreateOrConnectWithoutWorkshopsInput[]
    createMany?: recordsCreateManyWorkshopsInputEnvelope
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
  }

  export type recordsUpdateManyWithoutWorkshopsNestedInput = {
    create?: XOR<recordsCreateWithoutWorkshopsInput, recordsUncheckedCreateWithoutWorkshopsInput> | recordsCreateWithoutWorkshopsInput[] | recordsUncheckedCreateWithoutWorkshopsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutWorkshopsInput | recordsCreateOrConnectWithoutWorkshopsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutWorkshopsInput | recordsUpsertWithWhereUniqueWithoutWorkshopsInput[]
    createMany?: recordsCreateManyWorkshopsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutWorkshopsInput | recordsUpdateWithWhereUniqueWithoutWorkshopsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutWorkshopsInput | recordsUpdateManyWithWhereWithoutWorkshopsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type recordsUncheckedUpdateManyWithoutWorkshopsNestedInput = {
    create?: XOR<recordsCreateWithoutWorkshopsInput, recordsUncheckedCreateWithoutWorkshopsInput> | recordsCreateWithoutWorkshopsInput[] | recordsUncheckedCreateWithoutWorkshopsInput[]
    connectOrCreate?: recordsCreateOrConnectWithoutWorkshopsInput | recordsCreateOrConnectWithoutWorkshopsInput[]
    upsert?: recordsUpsertWithWhereUniqueWithoutWorkshopsInput | recordsUpsertWithWhereUniqueWithoutWorkshopsInput[]
    createMany?: recordsCreateManyWorkshopsInputEnvelope
    set?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    disconnect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    delete?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    connect?: recordsWhereUniqueInput | recordsWhereUniqueInput[]
    update?: recordsUpdateWithWhereUniqueWithoutWorkshopsInput | recordsUpdateWithWhereUniqueWithoutWorkshopsInput[]
    updateMany?: recordsUpdateManyWithWhereWithoutWorkshopsInput | recordsUpdateManyWithWhereWithoutWorkshopsInput[]
    deleteMany?: recordsScalarWhereInput | recordsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type recordsCreateWithoutApparatusesInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutApparatusesInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutApparatusesInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutApparatusesInput, recordsUncheckedCreateWithoutApparatusesInput>
  }

  export type recordsCreateManyApparatusesInputEnvelope = {
    data: recordsCreateManyApparatusesInput | recordsCreateManyApparatusesInput[]
    skipDuplicates?: boolean
  }

  export type recordsUpsertWithWhereUniqueWithoutApparatusesInput = {
    where: recordsWhereUniqueInput
    update: XOR<recordsUpdateWithoutApparatusesInput, recordsUncheckedUpdateWithoutApparatusesInput>
    create: XOR<recordsCreateWithoutApparatusesInput, recordsUncheckedCreateWithoutApparatusesInput>
  }

  export type recordsUpdateWithWhereUniqueWithoutApparatusesInput = {
    where: recordsWhereUniqueInput
    data: XOR<recordsUpdateWithoutApparatusesInput, recordsUncheckedUpdateWithoutApparatusesInput>
  }

  export type recordsUpdateManyWithWhereWithoutApparatusesInput = {
    where: recordsScalarWhereInput
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyWithoutApparatusesInput>
  }

  export type recordsScalarWhereInput = {
    AND?: recordsScalarWhereInput | recordsScalarWhereInput[]
    OR?: recordsScalarWhereInput[]
    NOT?: recordsScalarWhereInput | recordsScalarWhereInput[]
    id?: IntFilter<"records"> | number
    doc_id?: IntNullableFilter<"records"> | number | null
    productId?: IntNullableFilter<"records"> | number | null
    boilId?: IntNullableFilter<"records"> | number | null
    apparatusId?: IntNullableFilter<"records"> | number | null
    canId?: IntNullableFilter<"records"> | number | null
    conveyorId?: IntNullableFilter<"records"> | number | null
    plan?: IntFilter<"records"> | number
    bbf?: StringFilter<"records"> | string
    note?: StringFilter<"records"> | string
    workshopId?: IntNullableFilter<"records"> | number | null
    createdAt?: DateTimeFilter<"records"> | Date | string
    updatedAt?: DateTimeFilter<"records"> | Date | string
    isSet?: BoolNullableFilter<"records"> | boolean | null
    organic_base_id?: IntNullableFilter<"records"> | number | null
    water_base_id?: IntNullableFilter<"records"> | number | null
    dm?: StringFilter<"records"> | string
  }

  export type boilsCreateWithoutBasesInput = {
    value: string
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    semi_products?: semi_productsCreateNestedManyWithoutBoilsInput
    tube_records?: tube_recordsCreateNestedManyWithoutBoilsInput
    records?: recordsCreateNestedManyWithoutBoilsInput
  }

  export type boilsUncheckedCreateWithoutBasesInput = {
    id?: number
    value: string
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutBoilsInput
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutBoilsInput
    records?: recordsUncheckedCreateNestedManyWithoutBoilsInput
  }

  export type boilsCreateOrConnectWithoutBasesInput = {
    where: boilsWhereUniqueInput
    create: XOR<boilsCreateWithoutBasesInput, boilsUncheckedCreateWithoutBasesInput>
  }

  export type boilsCreateManyBasesInputEnvelope = {
    data: boilsCreateManyBasesInput | boilsCreateManyBasesInput[]
    skipDuplicates?: boolean
  }

  export type boilsUpsertWithWhereUniqueWithoutBasesInput = {
    where: boilsWhereUniqueInput
    update: XOR<boilsUpdateWithoutBasesInput, boilsUncheckedUpdateWithoutBasesInput>
    create: XOR<boilsCreateWithoutBasesInput, boilsUncheckedCreateWithoutBasesInput>
  }

  export type boilsUpdateWithWhereUniqueWithoutBasesInput = {
    where: boilsWhereUniqueInput
    data: XOR<boilsUpdateWithoutBasesInput, boilsUncheckedUpdateWithoutBasesInput>
  }

  export type boilsUpdateManyWithWhereWithoutBasesInput = {
    where: boilsScalarWhereInput
    data: XOR<boilsUpdateManyMutationInput, boilsUncheckedUpdateManyWithoutBasesInput>
  }

  export type boilsScalarWhereInput = {
    AND?: boilsScalarWhereInput | boilsScalarWhereInput[]
    OR?: boilsScalarWhereInput[]
    NOT?: boilsScalarWhereInput | boilsScalarWhereInput[]
    id?: IntFilter<"boils"> | number
    value?: StringFilter<"boils"> | string
    base_id?: IntNullableFilter<"boils"> | number | null
    letter?: StringNullableFilter<"boils"> | string | null
    year?: DecimalNullableFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    number?: DecimalNullableFilter<"boils"> | Decimal | DecimalJsLike | number | string | null
    plant_id?: IntNullableFilter<"boils"> | number | null
  }

  export type basesCreateWithoutBoilsInput = {
    code: string
    marking?: string | null
  }

  export type basesUncheckedCreateWithoutBoilsInput = {
    id?: number
    code: string
    marking?: string | null
  }

  export type basesCreateOrConnectWithoutBoilsInput = {
    where: basesWhereUniqueInput
    create: XOR<basesCreateWithoutBoilsInput, basesUncheckedCreateWithoutBoilsInput>
  }

  export type semi_productsCreateWithoutBoilsInput = {
    createdAt: Date | string
    updatedAt: Date | string
    products?: productsCreateNestedOneWithoutSemi_productsInput
    records?: recordsCreateNestedOneWithoutSemi_productsInput
  }

  export type semi_productsUncheckedCreateWithoutBoilsInput = {
    id?: number
    record_id?: number | null
    product_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type semi_productsCreateOrConnectWithoutBoilsInput = {
    where: semi_productsWhereUniqueInput
    create: XOR<semi_productsCreateWithoutBoilsInput, semi_productsUncheckedCreateWithoutBoilsInput>
  }

  export type semi_productsCreateManyBoilsInputEnvelope = {
    data: semi_productsCreateManyBoilsInput | semi_productsCreateManyBoilsInput[]
    skipDuplicates?: boolean
  }

  export type tube_recordsCreateWithoutBoilsInput = {
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_conveyors?: tube_conveyorsCreateNestedOneWithoutTube_recordsInput
    tube_products?: tube_productsCreateNestedOneWithoutTube_recordsInput
  }

  export type tube_recordsUncheckedCreateWithoutBoilsInput = {
    id?: number
    tube_product_id?: number | null
    tube_conveyor_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsCreateOrConnectWithoutBoilsInput = {
    where: tube_recordsWhereUniqueInput
    create: XOR<tube_recordsCreateWithoutBoilsInput, tube_recordsUncheckedCreateWithoutBoilsInput>
  }

  export type tube_recordsCreateManyBoilsInputEnvelope = {
    data: tube_recordsCreateManyBoilsInput | tube_recordsCreateManyBoilsInput[]
    skipDuplicates?: boolean
  }

  export type recordsCreateWithoutBoilsInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutBoilsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutBoilsInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutBoilsInput, recordsUncheckedCreateWithoutBoilsInput>
  }

  export type recordsCreateManyBoilsInputEnvelope = {
    data: recordsCreateManyBoilsInput | recordsCreateManyBoilsInput[]
    skipDuplicates?: boolean
  }

  export type basesUpsertWithoutBoilsInput = {
    update: XOR<basesUpdateWithoutBoilsInput, basesUncheckedUpdateWithoutBoilsInput>
    create: XOR<basesCreateWithoutBoilsInput, basesUncheckedCreateWithoutBoilsInput>
    where?: basesWhereInput
  }

  export type basesUpdateToOneWithWhereWithoutBoilsInput = {
    where?: basesWhereInput
    data: XOR<basesUpdateWithoutBoilsInput, basesUncheckedUpdateWithoutBoilsInput>
  }

  export type basesUpdateWithoutBoilsInput = {
    code?: StringFieldUpdateOperationsInput | string
    marking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type basesUncheckedUpdateWithoutBoilsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    marking?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type semi_productsUpsertWithWhereUniqueWithoutBoilsInput = {
    where: semi_productsWhereUniqueInput
    update: XOR<semi_productsUpdateWithoutBoilsInput, semi_productsUncheckedUpdateWithoutBoilsInput>
    create: XOR<semi_productsCreateWithoutBoilsInput, semi_productsUncheckedCreateWithoutBoilsInput>
  }

  export type semi_productsUpdateWithWhereUniqueWithoutBoilsInput = {
    where: semi_productsWhereUniqueInput
    data: XOR<semi_productsUpdateWithoutBoilsInput, semi_productsUncheckedUpdateWithoutBoilsInput>
  }

  export type semi_productsUpdateManyWithWhereWithoutBoilsInput = {
    where: semi_productsScalarWhereInput
    data: XOR<semi_productsUpdateManyMutationInput, semi_productsUncheckedUpdateManyWithoutBoilsInput>
  }

  export type semi_productsScalarWhereInput = {
    AND?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
    OR?: semi_productsScalarWhereInput[]
    NOT?: semi_productsScalarWhereInput | semi_productsScalarWhereInput[]
    id?: IntFilter<"semi_products"> | number
    record_id?: IntNullableFilter<"semi_products"> | number | null
    product_id?: IntNullableFilter<"semi_products"> | number | null
    boil_id?: IntNullableFilter<"semi_products"> | number | null
    createdAt?: DateTimeFilter<"semi_products"> | Date | string
    updatedAt?: DateTimeFilter<"semi_products"> | Date | string
  }

  export type tube_recordsUpsertWithWhereUniqueWithoutBoilsInput = {
    where: tube_recordsWhereUniqueInput
    update: XOR<tube_recordsUpdateWithoutBoilsInput, tube_recordsUncheckedUpdateWithoutBoilsInput>
    create: XOR<tube_recordsCreateWithoutBoilsInput, tube_recordsUncheckedCreateWithoutBoilsInput>
  }

  export type tube_recordsUpdateWithWhereUniqueWithoutBoilsInput = {
    where: tube_recordsWhereUniqueInput
    data: XOR<tube_recordsUpdateWithoutBoilsInput, tube_recordsUncheckedUpdateWithoutBoilsInput>
  }

  export type tube_recordsUpdateManyWithWhereWithoutBoilsInput = {
    where: tube_recordsScalarWhereInput
    data: XOR<tube_recordsUpdateManyMutationInput, tube_recordsUncheckedUpdateManyWithoutBoilsInput>
  }

  export type tube_recordsScalarWhereInput = {
    AND?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
    OR?: tube_recordsScalarWhereInput[]
    NOT?: tube_recordsScalarWhereInput | tube_recordsScalarWhereInput[]
    id?: IntFilter<"tube_records"> | number
    tube_product_id?: IntNullableFilter<"tube_records"> | number | null
    tube_conveyor_id?: IntNullableFilter<"tube_records"> | number | null
    boil_id?: IntNullableFilter<"tube_records"> | number | null
    plan?: IntFilter<"tube_records"> | number
    start_date?: DateTimeNullableFilter<"tube_records"> | Date | string | null
    active?: BoolNullableFilter<"tube_records"> | boolean | null
    finished?: BoolNullableFilter<"tube_records"> | boolean | null
    createdAt?: DateTimeFilter<"tube_records"> | Date | string
    updatedAt?: DateTimeFilter<"tube_records"> | Date | string
  }

  export type recordsUpsertWithWhereUniqueWithoutBoilsInput = {
    where: recordsWhereUniqueInput
    update: XOR<recordsUpdateWithoutBoilsInput, recordsUncheckedUpdateWithoutBoilsInput>
    create: XOR<recordsCreateWithoutBoilsInput, recordsUncheckedCreateWithoutBoilsInput>
  }

  export type recordsUpdateWithWhereUniqueWithoutBoilsInput = {
    where: recordsWhereUniqueInput
    data: XOR<recordsUpdateWithoutBoilsInput, recordsUncheckedUpdateWithoutBoilsInput>
  }

  export type recordsUpdateManyWithWhereWithoutBoilsInput = {
    where: recordsScalarWhereInput
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyWithoutBoilsInput>
  }

  export type recordsCreateWithoutCansInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutCansInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutCansInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutCansInput, recordsUncheckedCreateWithoutCansInput>
  }

  export type recordsCreateManyCansInputEnvelope = {
    data: recordsCreateManyCansInput | recordsCreateManyCansInput[]
    skipDuplicates?: boolean
  }

  export type recordsUpsertWithWhereUniqueWithoutCansInput = {
    where: recordsWhereUniqueInput
    update: XOR<recordsUpdateWithoutCansInput, recordsUncheckedUpdateWithoutCansInput>
    create: XOR<recordsCreateWithoutCansInput, recordsUncheckedCreateWithoutCansInput>
  }

  export type recordsUpdateWithWhereUniqueWithoutCansInput = {
    where: recordsWhereUniqueInput
    data: XOR<recordsUpdateWithoutCansInput, recordsUncheckedUpdateWithoutCansInput>
  }

  export type recordsUpdateManyWithWhereWithoutCansInput = {
    where: recordsScalarWhereInput
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyWithoutCansInput>
  }

  export type recordsCreateWithoutConveyorsInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutConveyorsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutConveyorsInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutConveyorsInput, recordsUncheckedCreateWithoutConveyorsInput>
  }

  export type recordsCreateManyConveyorsInputEnvelope = {
    data: recordsCreateManyConveyorsInput | recordsCreateManyConveyorsInput[]
    skipDuplicates?: boolean
  }

  export type recordsUpsertWithWhereUniqueWithoutConveyorsInput = {
    where: recordsWhereUniqueInput
    update: XOR<recordsUpdateWithoutConveyorsInput, recordsUncheckedUpdateWithoutConveyorsInput>
    create: XOR<recordsCreateWithoutConveyorsInput, recordsUncheckedCreateWithoutConveyorsInput>
  }

  export type recordsUpdateWithWhereUniqueWithoutConveyorsInput = {
    where: recordsWhereUniqueInput
    data: XOR<recordsUpdateWithoutConveyorsInput, recordsUncheckedUpdateWithoutConveyorsInput>
  }

  export type recordsUpdateManyWithWhereWithoutConveyorsInput = {
    where: recordsScalarWhereInput
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyWithoutConveyorsInput>
  }

  export type plantsCreateWithoutDocsInput = {
    value: string
    abb?: string | null
  }

  export type plantsUncheckedCreateWithoutDocsInput = {
    id?: number
    value: string
    abb?: string | null
  }

  export type plantsCreateOrConnectWithoutDocsInput = {
    where: plantsWhereUniqueInput
    create: XOR<plantsCreateWithoutDocsInput, plantsUncheckedCreateWithoutDocsInput>
  }

  export type recordsCreateWithoutDocsInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutDocsInput = {
    id?: number
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutDocsInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutDocsInput, recordsUncheckedCreateWithoutDocsInput>
  }

  export type recordsCreateManyDocsInputEnvelope = {
    data: recordsCreateManyDocsInput | recordsCreateManyDocsInput[]
    skipDuplicates?: boolean
  }

  export type plantsUpsertWithoutDocsInput = {
    update: XOR<plantsUpdateWithoutDocsInput, plantsUncheckedUpdateWithoutDocsInput>
    create: XOR<plantsCreateWithoutDocsInput, plantsUncheckedCreateWithoutDocsInput>
    where?: plantsWhereInput
  }

  export type plantsUpdateToOneWithWhereWithoutDocsInput = {
    where?: plantsWhereInput
    data: XOR<plantsUpdateWithoutDocsInput, plantsUncheckedUpdateWithoutDocsInput>
  }

  export type plantsUpdateWithoutDocsInput = {
    value?: StringFieldUpdateOperationsInput | string
    abb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type plantsUncheckedUpdateWithoutDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    abb?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type recordsUpsertWithWhereUniqueWithoutDocsInput = {
    where: recordsWhereUniqueInput
    update: XOR<recordsUpdateWithoutDocsInput, recordsUncheckedUpdateWithoutDocsInput>
    create: XOR<recordsCreateWithoutDocsInput, recordsUncheckedCreateWithoutDocsInput>
  }

  export type recordsUpdateWithWhereUniqueWithoutDocsInput = {
    where: recordsWhereUniqueInput
    data: XOR<recordsUpdateWithoutDocsInput, recordsUncheckedUpdateWithoutDocsInput>
  }

  export type recordsUpdateManyWithWhereWithoutDocsInput = {
    where: recordsScalarWhereInput
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyWithoutDocsInput>
  }

  export type occupationsCreateWithoutEmployeesInput = {
    value: string
    description: string
  }

  export type occupationsUncheckedCreateWithoutEmployeesInput = {
    id?: number
    value: string
    description: string
  }

  export type occupationsCreateOrConnectWithoutEmployeesInput = {
    where: occupationsWhereUniqueInput
    create: XOR<occupationsCreateWithoutEmployeesInput, occupationsUncheckedCreateWithoutEmployeesInput>
  }

  export type historiesCreateWithoutEmployeesInput = {
    boil_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
    history_types?: history_typesCreateNestedOneWithoutHistoriesInput
    records?: recordsCreateNestedOneWithoutHistoriesInput
    users?: usersCreateNestedOneWithoutHistoriesInput
  }

  export type historiesUncheckedCreateWithoutEmployeesInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    historyTypeId?: number | null
    userId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type historiesCreateOrConnectWithoutEmployeesInput = {
    where: historiesWhereUniqueInput
    create: XOR<historiesCreateWithoutEmployeesInput, historiesUncheckedCreateWithoutEmployeesInput>
  }

  export type historiesCreateManyEmployeesInputEnvelope = {
    data: historiesCreateManyEmployeesInput | historiesCreateManyEmployeesInput[]
    skipDuplicates?: boolean
  }

  export type tube_historiesCreateWithoutEmployeesInput = {
    tube_record_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_histories_notes?: tube_histories_notesCreateNestedOneWithoutTube_historiesInput
    tube_history_types?: tube_history_typesCreateNestedOneWithoutTube_historiesInput
  }

  export type tube_historiesUncheckedCreateWithoutEmployeesInput = {
    id?: number
    tube_record_id?: number | null
    tube_history_type_id?: number | null
    note?: string | null
    tube_history_note_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_historiesCreateOrConnectWithoutEmployeesInput = {
    where: tube_historiesWhereUniqueInput
    create: XOR<tube_historiesCreateWithoutEmployeesInput, tube_historiesUncheckedCreateWithoutEmployeesInput>
  }

  export type tube_historiesCreateManyEmployeesInputEnvelope = {
    data: tube_historiesCreateManyEmployeesInput | tube_historiesCreateManyEmployeesInput[]
    skipDuplicates?: boolean
  }

  export type tube_sessionsCreateWithoutEmployeesInput = {
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_conveyors?: tube_conveyorsCreateNestedOneWithoutTube_sessionsInput
  }

  export type tube_sessionsUncheckedCreateWithoutEmployeesInput = {
    id?: number
    conveyor_id?: number | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_sessionsCreateOrConnectWithoutEmployeesInput = {
    where: tube_sessionsWhereUniqueInput
    create: XOR<tube_sessionsCreateWithoutEmployeesInput, tube_sessionsUncheckedCreateWithoutEmployeesInput>
  }

  export type tube_sessionsCreateManyEmployeesInputEnvelope = {
    data: tube_sessionsCreateManyEmployeesInput | tube_sessionsCreateManyEmployeesInput[]
    skipDuplicates?: boolean
  }

  export type occupationsUpsertWithoutEmployeesInput = {
    update: XOR<occupationsUpdateWithoutEmployeesInput, occupationsUncheckedUpdateWithoutEmployeesInput>
    create: XOR<occupationsCreateWithoutEmployeesInput, occupationsUncheckedCreateWithoutEmployeesInput>
    where?: occupationsWhereInput
  }

  export type occupationsUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: occupationsWhereInput
    data: XOR<occupationsUpdateWithoutEmployeesInput, occupationsUncheckedUpdateWithoutEmployeesInput>
  }

  export type occupationsUpdateWithoutEmployeesInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type occupationsUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type historiesUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: historiesWhereUniqueInput
    update: XOR<historiesUpdateWithoutEmployeesInput, historiesUncheckedUpdateWithoutEmployeesInput>
    create: XOR<historiesCreateWithoutEmployeesInput, historiesUncheckedCreateWithoutEmployeesInput>
  }

  export type historiesUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: historiesWhereUniqueInput
    data: XOR<historiesUpdateWithoutEmployeesInput, historiesUncheckedUpdateWithoutEmployeesInput>
  }

  export type historiesUpdateManyWithWhereWithoutEmployeesInput = {
    where: historiesScalarWhereInput
    data: XOR<historiesUpdateManyMutationInput, historiesUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type historiesScalarWhereInput = {
    AND?: historiesScalarWhereInput | historiesScalarWhereInput[]
    OR?: historiesScalarWhereInput[]
    NOT?: historiesScalarWhereInput | historiesScalarWhereInput[]
    id?: IntFilter<"histories"> | number
    record_id?: IntNullableFilter<"histories"> | number | null
    boil_id?: IntNullableFilter<"histories"> | number | null
    historyTypeId?: IntNullableFilter<"histories"> | number | null
    userId?: IntNullableFilter<"histories"> | number | null
    employeeId?: IntNullableFilter<"histories"> | number | null
    note?: StringNullableFilter<"histories"> | string | null
    createdAt?: DateTimeFilter<"histories"> | Date | string
    updatedAt?: DateTimeFilter<"histories"> | Date | string
    note_id?: IntNullableFilter<"histories"> | number | null
    plant_id?: IntNullableFilter<"histories"> | number | null
  }

  export type tube_historiesUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: tube_historiesWhereUniqueInput
    update: XOR<tube_historiesUpdateWithoutEmployeesInput, tube_historiesUncheckedUpdateWithoutEmployeesInput>
    create: XOR<tube_historiesCreateWithoutEmployeesInput, tube_historiesUncheckedCreateWithoutEmployeesInput>
  }

  export type tube_historiesUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: tube_historiesWhereUniqueInput
    data: XOR<tube_historiesUpdateWithoutEmployeesInput, tube_historiesUncheckedUpdateWithoutEmployeesInput>
  }

  export type tube_historiesUpdateManyWithWhereWithoutEmployeesInput = {
    where: tube_historiesScalarWhereInput
    data: XOR<tube_historiesUpdateManyMutationInput, tube_historiesUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type tube_historiesScalarWhereInput = {
    AND?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
    OR?: tube_historiesScalarWhereInput[]
    NOT?: tube_historiesScalarWhereInput | tube_historiesScalarWhereInput[]
    id?: IntFilter<"tube_histories"> | number
    tube_record_id?: IntNullableFilter<"tube_histories"> | number | null
    tube_history_type_id?: IntNullableFilter<"tube_histories"> | number | null
    employee_id?: IntNullableFilter<"tube_histories"> | number | null
    note?: StringNullableFilter<"tube_histories"> | string | null
    tube_history_note_id?: IntNullableFilter<"tube_histories"> | number | null
    createdAt?: DateTimeFilter<"tube_histories"> | Date | string
    updatedAt?: DateTimeFilter<"tube_histories"> | Date | string
  }

  export type tube_sessionsUpsertWithWhereUniqueWithoutEmployeesInput = {
    where: tube_sessionsWhereUniqueInput
    update: XOR<tube_sessionsUpdateWithoutEmployeesInput, tube_sessionsUncheckedUpdateWithoutEmployeesInput>
    create: XOR<tube_sessionsCreateWithoutEmployeesInput, tube_sessionsUncheckedCreateWithoutEmployeesInput>
  }

  export type tube_sessionsUpdateWithWhereUniqueWithoutEmployeesInput = {
    where: tube_sessionsWhereUniqueInput
    data: XOR<tube_sessionsUpdateWithoutEmployeesInput, tube_sessionsUncheckedUpdateWithoutEmployeesInput>
  }

  export type tube_sessionsUpdateManyWithWhereWithoutEmployeesInput = {
    where: tube_sessionsScalarWhereInput
    data: XOR<tube_sessionsUpdateManyMutationInput, tube_sessionsUncheckedUpdateManyWithoutEmployeesInput>
  }

  export type tube_sessionsScalarWhereInput = {
    AND?: tube_sessionsScalarWhereInput | tube_sessionsScalarWhereInput[]
    OR?: tube_sessionsScalarWhereInput[]
    NOT?: tube_sessionsScalarWhereInput | tube_sessionsScalarWhereInput[]
    id?: IntFilter<"tube_sessions"> | number
    conveyor_id?: IntNullableFilter<"tube_sessions"> | number | null
    employee_id?: IntNullableFilter<"tube_sessions"> | number | null
    finished?: BoolNullableFilter<"tube_sessions"> | boolean | null
    createdAt?: DateTimeFilter<"tube_sessions"> | Date | string
    updatedAt?: DateTimeFilter<"tube_sessions"> | Date | string
  }

  export type employeesCreateWithoutHistoriesInput = {
    name: string
    barcode: string
    createdAt: Date | string
    updatedAt: Date | string
    occupations?: occupationsCreateNestedOneWithoutEmployeesInput
    tube_histories?: tube_historiesCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutHistoriesInput = {
    id?: number
    name: string
    barcode: string
    occupationId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_histories?: tube_historiesUncheckedCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesCreateOrConnectWithoutHistoriesInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutHistoriesInput, employeesUncheckedCreateWithoutHistoriesInput>
  }

  export type history_typesCreateWithoutHistoriesInput = {
    value: string
    description: string
    for_boil?: boolean | null
  }

  export type history_typesUncheckedCreateWithoutHistoriesInput = {
    id?: number
    value: string
    description: string
    for_boil?: boolean | null
  }

  export type history_typesCreateOrConnectWithoutHistoriesInput = {
    where: history_typesWhereUniqueInput
    create: XOR<history_typesCreateWithoutHistoriesInput, history_typesUncheckedCreateWithoutHistoriesInput>
  }

  export type recordsCreateWithoutHistoriesInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutHistoriesInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutHistoriesInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutHistoriesInput, recordsUncheckedCreateWithoutHistoriesInput>
  }

  export type usersCreateWithoutHistoriesInput = {
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    tokens?: tokensCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutHistoriesInput = {
    id?: number
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    tokens?: tokensUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutHistoriesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutHistoriesInput, usersUncheckedCreateWithoutHistoriesInput>
  }

  export type employeesUpsertWithoutHistoriesInput = {
    update: XOR<employeesUpdateWithoutHistoriesInput, employeesUncheckedUpdateWithoutHistoriesInput>
    create: XOR<employeesCreateWithoutHistoriesInput, employeesUncheckedCreateWithoutHistoriesInput>
    where?: employeesWhereInput
  }

  export type employeesUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: employeesWhereInput
    data: XOR<employeesUpdateWithoutHistoriesInput, employeesUncheckedUpdateWithoutHistoriesInput>
  }

  export type employeesUpdateWithoutHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occupations?: occupationsUpdateOneWithoutEmployeesNestedInput
    tube_histories?: tube_historiesUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    occupationId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_histories?: tube_historiesUncheckedUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUncheckedUpdateManyWithoutEmployeesNestedInput
  }

  export type history_typesUpsertWithoutHistoriesInput = {
    update: XOR<history_typesUpdateWithoutHistoriesInput, history_typesUncheckedUpdateWithoutHistoriesInput>
    create: XOR<history_typesCreateWithoutHistoriesInput, history_typesUncheckedCreateWithoutHistoriesInput>
    where?: history_typesWhereInput
  }

  export type history_typesUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: history_typesWhereInput
    data: XOR<history_typesUpdateWithoutHistoriesInput, history_typesUncheckedUpdateWithoutHistoriesInput>
  }

  export type history_typesUpdateWithoutHistoriesInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    for_boil?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type history_typesUncheckedUpdateWithoutHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    for_boil?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type recordsUpsertWithoutHistoriesInput = {
    update: XOR<recordsUpdateWithoutHistoriesInput, recordsUncheckedUpdateWithoutHistoriesInput>
    create: XOR<recordsCreateWithoutHistoriesInput, recordsUncheckedCreateWithoutHistoriesInput>
    where?: recordsWhereInput
  }

  export type recordsUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: recordsWhereInput
    data: XOR<recordsUpdateWithoutHistoriesInput, recordsUncheckedUpdateWithoutHistoriesInput>
  }

  export type recordsUpdateWithoutHistoriesInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type usersUpsertWithoutHistoriesInput = {
    update: XOR<usersUpdateWithoutHistoriesInput, usersUncheckedUpdateWithoutHistoriesInput>
    create: XOR<usersCreateWithoutHistoriesInput, usersUncheckedCreateWithoutHistoriesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutHistoriesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutHistoriesInput, usersUncheckedUpdateWithoutHistoriesInput>
  }

  export type usersUpdateWithoutHistoriesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: tokensUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutHistoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: tokensUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type historiesCreateWithoutHistory_typesInput = {
    boil_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
    employees?: employeesCreateNestedOneWithoutHistoriesInput
    records?: recordsCreateNestedOneWithoutHistoriesInput
    users?: usersCreateNestedOneWithoutHistoriesInput
  }

  export type historiesUncheckedCreateWithoutHistory_typesInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    userId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type historiesCreateOrConnectWithoutHistory_typesInput = {
    where: historiesWhereUniqueInput
    create: XOR<historiesCreateWithoutHistory_typesInput, historiesUncheckedCreateWithoutHistory_typesInput>
  }

  export type historiesCreateManyHistory_typesInputEnvelope = {
    data: historiesCreateManyHistory_typesInput | historiesCreateManyHistory_typesInput[]
    skipDuplicates?: boolean
  }

  export type historiesUpsertWithWhereUniqueWithoutHistory_typesInput = {
    where: historiesWhereUniqueInput
    update: XOR<historiesUpdateWithoutHistory_typesInput, historiesUncheckedUpdateWithoutHistory_typesInput>
    create: XOR<historiesCreateWithoutHistory_typesInput, historiesUncheckedCreateWithoutHistory_typesInput>
  }

  export type historiesUpdateWithWhereUniqueWithoutHistory_typesInput = {
    where: historiesWhereUniqueInput
    data: XOR<historiesUpdateWithoutHistory_typesInput, historiesUncheckedUpdateWithoutHistory_typesInput>
  }

  export type historiesUpdateManyWithWhereWithoutHistory_typesInput = {
    where: historiesScalarWhereInput
    data: XOR<historiesUpdateManyMutationInput, historiesUncheckedUpdateManyWithoutHistory_typesInput>
  }

  export type record_regulationsCreateWithoutMarking_sampleInput = {
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsCreateNestedOneWithoutRecord_regulationsInput
  }

  export type record_regulationsUncheckedCreateWithoutMarking_sampleInput = {
    id?: number
    record_id?: number | null
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type record_regulationsCreateOrConnectWithoutMarking_sampleInput = {
    where: record_regulationsWhereUniqueInput
    create: XOR<record_regulationsCreateWithoutMarking_sampleInput, record_regulationsUncheckedCreateWithoutMarking_sampleInput>
  }

  export type record_regulationsCreateManyMarking_sampleInputEnvelope = {
    data: record_regulationsCreateManyMarking_sampleInput | record_regulationsCreateManyMarking_sampleInput[]
    skipDuplicates?: boolean
  }

  export type regulationsCreateWithoutMarking_sampleInput = {
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    products?: productsCreateNestedOneWithoutRegulationsInput
  }

  export type regulationsUncheckedCreateWithoutMarking_sampleInput = {
    id?: number
    product_id?: number | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type regulationsCreateOrConnectWithoutMarking_sampleInput = {
    where: regulationsWhereUniqueInput
    create: XOR<regulationsCreateWithoutMarking_sampleInput, regulationsUncheckedCreateWithoutMarking_sampleInput>
  }

  export type regulationsCreateManyMarking_sampleInputEnvelope = {
    data: regulationsCreateManyMarking_sampleInput | regulationsCreateManyMarking_sampleInput[]
    skipDuplicates?: boolean
  }

  export type record_regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput = {
    where: record_regulationsWhereUniqueInput
    update: XOR<record_regulationsUpdateWithoutMarking_sampleInput, record_regulationsUncheckedUpdateWithoutMarking_sampleInput>
    create: XOR<record_regulationsCreateWithoutMarking_sampleInput, record_regulationsUncheckedCreateWithoutMarking_sampleInput>
  }

  export type record_regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput = {
    where: record_regulationsWhereUniqueInput
    data: XOR<record_regulationsUpdateWithoutMarking_sampleInput, record_regulationsUncheckedUpdateWithoutMarking_sampleInput>
  }

  export type record_regulationsUpdateManyWithWhereWithoutMarking_sampleInput = {
    where: record_regulationsScalarWhereInput
    data: XOR<record_regulationsUpdateManyMutationInput, record_regulationsUncheckedUpdateManyWithoutMarking_sampleInput>
  }

  export type record_regulationsScalarWhereInput = {
    AND?: record_regulationsScalarWhereInput | record_regulationsScalarWhereInput[]
    OR?: record_regulationsScalarWhereInput[]
    NOT?: record_regulationsScalarWhereInput | record_regulationsScalarWhereInput[]
    id?: IntFilter<"record_regulations"> | number
    record_id?: IntNullableFilter<"record_regulations"> | number | null
    org_base_min_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableFilter<"record_regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableFilter<"record_regulations"> | number | null
    box_per_row?: IntNullableFilter<"record_regulations"> | number | null
    row_on_pallet?: IntNullableFilter<"record_regulations"> | number | null
    gasket?: StringNullableFilter<"record_regulations"> | string | null
    seal?: BoolNullableFilter<"record_regulations"> | boolean | null
    technician_note?: StringNullableFilter<"record_regulations"> | string | null
    packaging_note?: StringNullableFilter<"record_regulations"> | string | null
    marking_sample_id?: IntNullableFilter<"record_regulations"> | number | null
    inc_color?: StringNullableFilter<"record_regulations"> | string | null
    marking_feature?: StringNullableFilter<"record_regulations"> | string | null
    createdAt?: DateTimeFilter<"record_regulations"> | Date | string
    updatedAt?: DateTimeFilter<"record_regulations"> | Date | string
  }

  export type regulationsUpsertWithWhereUniqueWithoutMarking_sampleInput = {
    where: regulationsWhereUniqueInput
    update: XOR<regulationsUpdateWithoutMarking_sampleInput, regulationsUncheckedUpdateWithoutMarking_sampleInput>
    create: XOR<regulationsCreateWithoutMarking_sampleInput, regulationsUncheckedCreateWithoutMarking_sampleInput>
  }

  export type regulationsUpdateWithWhereUniqueWithoutMarking_sampleInput = {
    where: regulationsWhereUniqueInput
    data: XOR<regulationsUpdateWithoutMarking_sampleInput, regulationsUncheckedUpdateWithoutMarking_sampleInput>
  }

  export type regulationsUpdateManyWithWhereWithoutMarking_sampleInput = {
    where: regulationsScalarWhereInput
    data: XOR<regulationsUpdateManyMutationInput, regulationsUncheckedUpdateManyWithoutMarking_sampleInput>
  }

  export type regulationsScalarWhereInput = {
    AND?: regulationsScalarWhereInput | regulationsScalarWhereInput[]
    OR?: regulationsScalarWhereInput[]
    NOT?: regulationsScalarWhereInput | regulationsScalarWhereInput[]
    id?: IntFilter<"regulations"> | number
    product_id?: IntNullableFilter<"regulations"> | number | null
    water_base_min_weight?: DecimalNullableFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: DecimalNullableFilter<"regulations"> | Decimal | DecimalJsLike | number | string | null
    per_box?: IntNullableFilter<"regulations"> | number | null
    box_per_row?: IntNullableFilter<"regulations"> | number | null
    row_on_pallet?: IntNullableFilter<"regulations"> | number | null
    gasket?: StringNullableFilter<"regulations"> | string | null
    seal?: BoolNullableFilter<"regulations"> | boolean | null
    technician_note?: StringNullableFilter<"regulations"> | string | null
    packaging_note?: StringNullableFilter<"regulations"> | string | null
    marking_sample_id?: IntNullableFilter<"regulations"> | number | null
    createdAt?: DateTimeFilter<"regulations"> | Date | string
    updatedAt?: DateTimeFilter<"regulations"> | Date | string
  }

  export type employeesCreateWithoutOccupationsInput = {
    name: string
    barcode: string
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesCreateNestedManyWithoutEmployeesInput
    tube_histories?: tube_historiesCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutOccupationsInput = {
    id?: number
    name: string
    barcode: string
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesUncheckedCreateNestedManyWithoutEmployeesInput
    tube_histories?: tube_historiesUncheckedCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesCreateOrConnectWithoutOccupationsInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutOccupationsInput, employeesUncheckedCreateWithoutOccupationsInput>
  }

  export type employeesCreateManyOccupationsInputEnvelope = {
    data: employeesCreateManyOccupationsInput | employeesCreateManyOccupationsInput[]
    skipDuplicates?: boolean
  }

  export type employeesUpsertWithWhereUniqueWithoutOccupationsInput = {
    where: employeesWhereUniqueInput
    update: XOR<employeesUpdateWithoutOccupationsInput, employeesUncheckedUpdateWithoutOccupationsInput>
    create: XOR<employeesCreateWithoutOccupationsInput, employeesUncheckedCreateWithoutOccupationsInput>
  }

  export type employeesUpdateWithWhereUniqueWithoutOccupationsInput = {
    where: employeesWhereUniqueInput
    data: XOR<employeesUpdateWithoutOccupationsInput, employeesUncheckedUpdateWithoutOccupationsInput>
  }

  export type employeesUpdateManyWithWhereWithoutOccupationsInput = {
    where: employeesScalarWhereInput
    data: XOR<employeesUpdateManyMutationInput, employeesUncheckedUpdateManyWithoutOccupationsInput>
  }

  export type employeesScalarWhereInput = {
    AND?: employeesScalarWhereInput | employeesScalarWhereInput[]
    OR?: employeesScalarWhereInput[]
    NOT?: employeesScalarWhereInput | employeesScalarWhereInput[]
    id?: IntFilter<"employees"> | number
    name?: StringFilter<"employees"> | string
    barcode?: StringFilter<"employees"> | string
    occupationId?: IntNullableFilter<"employees"> | number | null
    createdAt?: DateTimeFilter<"employees"> | Date | string
    updatedAt?: DateTimeFilter<"employees"> | Date | string
  }

  export type docsCreateWithoutPlantsInput = {
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsCreateNestedManyWithoutDocsInput
  }

  export type docsUncheckedCreateWithoutPlantsInput = {
    id?: number
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsUncheckedCreateNestedManyWithoutDocsInput
  }

  export type docsCreateOrConnectWithoutPlantsInput = {
    where: docsWhereUniqueInput
    create: XOR<docsCreateWithoutPlantsInput, docsUncheckedCreateWithoutPlantsInput>
  }

  export type docsCreateManyPlantsInputEnvelope = {
    data: docsCreateManyPlantsInput | docsCreateManyPlantsInput[]
    skipDuplicates?: boolean
  }

  export type docsUpsertWithWhereUniqueWithoutPlantsInput = {
    where: docsWhereUniqueInput
    update: XOR<docsUpdateWithoutPlantsInput, docsUncheckedUpdateWithoutPlantsInput>
    create: XOR<docsCreateWithoutPlantsInput, docsUncheckedCreateWithoutPlantsInput>
  }

  export type docsUpdateWithWhereUniqueWithoutPlantsInput = {
    where: docsWhereUniqueInput
    data: XOR<docsUpdateWithoutPlantsInput, docsUncheckedUpdateWithoutPlantsInput>
  }

  export type docsUpdateManyWithWhereWithoutPlantsInput = {
    where: docsScalarWhereInput
    data: XOR<docsUpdateManyMutationInput, docsUncheckedUpdateManyWithoutPlantsInput>
  }

  export type docsScalarWhereInput = {
    AND?: docsScalarWhereInput | docsScalarWhereInput[]
    OR?: docsScalarWhereInput[]
    NOT?: docsScalarWhereInput | docsScalarWhereInput[]
    id?: IntFilter<"docs"> | number
    plantId?: IntNullableFilter<"docs"> | number | null
    date?: DateTimeFilter<"docs"> | Date | string
    createdAt?: DateTimeFilter<"docs"> | Date | string
    updatedAt?: DateTimeFilter<"docs"> | Date | string
  }

  export type seriesCreateWithoutProductsInput = {
    value: string
  }

  export type seriesUncheckedCreateWithoutProductsInput = {
    id?: number
    value: string
  }

  export type seriesCreateOrConnectWithoutProductsInput = {
    where: seriesWhereUniqueInput
    create: XOR<seriesCreateWithoutProductsInput, seriesUncheckedCreateWithoutProductsInput>
  }

  export type recordsCreateWithoutProductsInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutProductsInput = {
    id?: number
    doc_id?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutProductsInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutProductsInput, recordsUncheckedCreateWithoutProductsInput>
  }

  export type recordsCreateManyProductsInputEnvelope = {
    data: recordsCreateManyProductsInput | recordsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type regulationsCreateWithoutProductsInput = {
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    marking_sample?: marking_sampleCreateNestedOneWithoutRegulationsInput
  }

  export type regulationsUncheckedCreateWithoutProductsInput = {
    id?: number
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type regulationsCreateOrConnectWithoutProductsInput = {
    where: regulationsWhereUniqueInput
    create: XOR<regulationsCreateWithoutProductsInput, regulationsUncheckedCreateWithoutProductsInput>
  }

  export type regulationsCreateManyProductsInputEnvelope = {
    data: regulationsCreateManyProductsInput | regulationsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type semi_productsCreateWithoutProductsInput = {
    createdAt: Date | string
    updatedAt: Date | string
    boils?: boilsCreateNestedOneWithoutSemi_productsInput
    records?: recordsCreateNestedOneWithoutSemi_productsInput
  }

  export type semi_productsUncheckedCreateWithoutProductsInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type semi_productsCreateOrConnectWithoutProductsInput = {
    where: semi_productsWhereUniqueInput
    create: XOR<semi_productsCreateWithoutProductsInput, semi_productsUncheckedCreateWithoutProductsInput>
  }

  export type semi_productsCreateManyProductsInputEnvelope = {
    data: semi_productsCreateManyProductsInput | semi_productsCreateManyProductsInput[]
    skipDuplicates?: boolean
  }

  export type seriesUpsertWithoutProductsInput = {
    update: XOR<seriesUpdateWithoutProductsInput, seriesUncheckedUpdateWithoutProductsInput>
    create: XOR<seriesCreateWithoutProductsInput, seriesUncheckedCreateWithoutProductsInput>
    where?: seriesWhereInput
  }

  export type seriesUpdateToOneWithWhereWithoutProductsInput = {
    where?: seriesWhereInput
    data: XOR<seriesUpdateWithoutProductsInput, seriesUncheckedUpdateWithoutProductsInput>
  }

  export type seriesUpdateWithoutProductsInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type seriesUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type recordsUpsertWithWhereUniqueWithoutProductsInput = {
    where: recordsWhereUniqueInput
    update: XOR<recordsUpdateWithoutProductsInput, recordsUncheckedUpdateWithoutProductsInput>
    create: XOR<recordsCreateWithoutProductsInput, recordsUncheckedCreateWithoutProductsInput>
  }

  export type recordsUpdateWithWhereUniqueWithoutProductsInput = {
    where: recordsWhereUniqueInput
    data: XOR<recordsUpdateWithoutProductsInput, recordsUncheckedUpdateWithoutProductsInput>
  }

  export type recordsUpdateManyWithWhereWithoutProductsInput = {
    where: recordsScalarWhereInput
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyWithoutProductsInput>
  }

  export type regulationsUpsertWithWhereUniqueWithoutProductsInput = {
    where: regulationsWhereUniqueInput
    update: XOR<regulationsUpdateWithoutProductsInput, regulationsUncheckedUpdateWithoutProductsInput>
    create: XOR<regulationsCreateWithoutProductsInput, regulationsUncheckedCreateWithoutProductsInput>
  }

  export type regulationsUpdateWithWhereUniqueWithoutProductsInput = {
    where: regulationsWhereUniqueInput
    data: XOR<regulationsUpdateWithoutProductsInput, regulationsUncheckedUpdateWithoutProductsInput>
  }

  export type regulationsUpdateManyWithWhereWithoutProductsInput = {
    where: regulationsScalarWhereInput
    data: XOR<regulationsUpdateManyMutationInput, regulationsUncheckedUpdateManyWithoutProductsInput>
  }

  export type semi_productsUpsertWithWhereUniqueWithoutProductsInput = {
    where: semi_productsWhereUniqueInput
    update: XOR<semi_productsUpdateWithoutProductsInput, semi_productsUncheckedUpdateWithoutProductsInput>
    create: XOR<semi_productsCreateWithoutProductsInput, semi_productsUncheckedCreateWithoutProductsInput>
  }

  export type semi_productsUpdateWithWhereUniqueWithoutProductsInput = {
    where: semi_productsWhereUniqueInput
    data: XOR<semi_productsUpdateWithoutProductsInput, semi_productsUncheckedUpdateWithoutProductsInput>
  }

  export type semi_productsUpdateManyWithWhereWithoutProductsInput = {
    where: semi_productsScalarWhereInput
    data: XOR<semi_productsUpdateManyMutationInput, semi_productsUncheckedUpdateManyWithoutProductsInput>
  }

  export type marking_sampleCreateWithoutRecord_regulationsInput = {
    value?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    regulations?: regulationsCreateNestedManyWithoutMarking_sampleInput
  }

  export type marking_sampleUncheckedCreateWithoutRecord_regulationsInput = {
    id?: number
    value?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    regulations?: regulationsUncheckedCreateNestedManyWithoutMarking_sampleInput
  }

  export type marking_sampleCreateOrConnectWithoutRecord_regulationsInput = {
    where: marking_sampleWhereUniqueInput
    create: XOR<marking_sampleCreateWithoutRecord_regulationsInput, marking_sampleUncheckedCreateWithoutRecord_regulationsInput>
  }

  export type recordsCreateWithoutRecord_regulationsInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutRecord_regulationsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutRecord_regulationsInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutRecord_regulationsInput, recordsUncheckedCreateWithoutRecord_regulationsInput>
  }

  export type marking_sampleUpsertWithoutRecord_regulationsInput = {
    update: XOR<marking_sampleUpdateWithoutRecord_regulationsInput, marking_sampleUncheckedUpdateWithoutRecord_regulationsInput>
    create: XOR<marking_sampleCreateWithoutRecord_regulationsInput, marking_sampleUncheckedCreateWithoutRecord_regulationsInput>
    where?: marking_sampleWhereInput
  }

  export type marking_sampleUpdateToOneWithWhereWithoutRecord_regulationsInput = {
    where?: marking_sampleWhereInput
    data: XOR<marking_sampleUpdateWithoutRecord_regulationsInput, marking_sampleUncheckedUpdateWithoutRecord_regulationsInput>
  }

  export type marking_sampleUpdateWithoutRecord_regulationsInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: regulationsUpdateManyWithoutMarking_sampleNestedInput
  }

  export type marking_sampleUncheckedUpdateWithoutRecord_regulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: regulationsUncheckedUpdateManyWithoutMarking_sampleNestedInput
  }

  export type recordsUpsertWithoutRecord_regulationsInput = {
    update: XOR<recordsUpdateWithoutRecord_regulationsInput, recordsUncheckedUpdateWithoutRecord_regulationsInput>
    create: XOR<recordsCreateWithoutRecord_regulationsInput, recordsUncheckedCreateWithoutRecord_regulationsInput>
    where?: recordsWhereInput
  }

  export type recordsUpdateToOneWithWhereWithoutRecord_regulationsInput = {
    where?: recordsWhereInput
    data: XOR<recordsUpdateWithoutRecord_regulationsInput, recordsUncheckedUpdateWithoutRecord_regulationsInput>
  }

  export type recordsUpdateWithoutRecord_regulationsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutRecord_regulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type historiesCreateWithoutRecordsInput = {
    boil_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
    employees?: employeesCreateNestedOneWithoutHistoriesInput
    history_types?: history_typesCreateNestedOneWithoutHistoriesInput
    users?: usersCreateNestedOneWithoutHistoriesInput
  }

  export type historiesUncheckedCreateWithoutRecordsInput = {
    id?: number
    boil_id?: number | null
    historyTypeId?: number | null
    userId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type historiesCreateOrConnectWithoutRecordsInput = {
    where: historiesWhereUniqueInput
    create: XOR<historiesCreateWithoutRecordsInput, historiesUncheckedCreateWithoutRecordsInput>
  }

  export type historiesCreateManyRecordsInputEnvelope = {
    data: historiesCreateManyRecordsInput | historiesCreateManyRecordsInput[]
    skipDuplicates?: boolean
  }

  export type record_regulationsCreateWithoutRecordsInput = {
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    marking_sample?: marking_sampleCreateNestedOneWithoutRecord_regulationsInput
  }

  export type record_regulationsUncheckedCreateWithoutRecordsInput = {
    id?: number
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type record_regulationsCreateOrConnectWithoutRecordsInput = {
    where: record_regulationsWhereUniqueInput
    create: XOR<record_regulationsCreateWithoutRecordsInput, record_regulationsUncheckedCreateWithoutRecordsInput>
  }

  export type record_regulationsCreateManyRecordsInputEnvelope = {
    data: record_regulationsCreateManyRecordsInput | record_regulationsCreateManyRecordsInput[]
    skipDuplicates?: boolean
  }

  export type apparatusesCreateWithoutRecordsInput = {
    value: string
  }

  export type apparatusesUncheckedCreateWithoutRecordsInput = {
    id?: number
    value: string
  }

  export type apparatusesCreateOrConnectWithoutRecordsInput = {
    where: apparatusesWhereUniqueInput
    create: XOR<apparatusesCreateWithoutRecordsInput, apparatusesUncheckedCreateWithoutRecordsInput>
  }

  export type cansCreateWithoutRecordsInput = {
    value: string
  }

  export type cansUncheckedCreateWithoutRecordsInput = {
    id?: number
    value: string
  }

  export type cansCreateOrConnectWithoutRecordsInput = {
    where: cansWhereUniqueInput
    create: XOR<cansCreateWithoutRecordsInput, cansUncheckedCreateWithoutRecordsInput>
  }

  export type conveyorsCreateWithoutRecordsInput = {
    value: string
    barcode?: string | null
  }

  export type conveyorsUncheckedCreateWithoutRecordsInput = {
    id?: number
    value: string
    barcode?: string | null
  }

  export type conveyorsCreateOrConnectWithoutRecordsInput = {
    where: conveyorsWhereUniqueInput
    create: XOR<conveyorsCreateWithoutRecordsInput, conveyorsUncheckedCreateWithoutRecordsInput>
  }

  export type docsCreateWithoutRecordsInput = {
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
    plants?: plantsCreateNestedOneWithoutDocsInput
  }

  export type docsUncheckedCreateWithoutRecordsInput = {
    id?: number
    plantId?: number | null
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type docsCreateOrConnectWithoutRecordsInput = {
    where: docsWhereUniqueInput
    create: XOR<docsCreateWithoutRecordsInput, docsUncheckedCreateWithoutRecordsInput>
  }

  export type productsCreateWithoutRecordsInput = {
    code1C: string
    marking: string
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    series?: seriesCreateNestedOneWithoutProductsInput
    regulations?: regulationsCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutRecordsInput = {
    id?: number
    code1C: string
    marking: string
    name?: string | null
    serieId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    regulations?: regulationsUncheckedCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutRecordsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutRecordsInput, productsUncheckedCreateWithoutRecordsInput>
  }

  export type workshopsCreateWithoutRecordsInput = {
    value: string
  }

  export type workshopsUncheckedCreateWithoutRecordsInput = {
    id?: number
    value: string
  }

  export type workshopsCreateOrConnectWithoutRecordsInput = {
    where: workshopsWhereUniqueInput
    create: XOR<workshopsCreateWithoutRecordsInput, workshopsUncheckedCreateWithoutRecordsInput>
  }

  export type boilsCreateWithoutRecordsInput = {
    value: string
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    bases?: basesCreateNestedOneWithoutBoilsInput
    semi_products?: semi_productsCreateNestedManyWithoutBoilsInput
    tube_records?: tube_recordsCreateNestedManyWithoutBoilsInput
  }

  export type boilsUncheckedCreateWithoutRecordsInput = {
    id?: number
    value: string
    base_id?: number | null
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutBoilsInput
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutBoilsInput
  }

  export type boilsCreateOrConnectWithoutRecordsInput = {
    where: boilsWhereUniqueInput
    create: XOR<boilsCreateWithoutRecordsInput, boilsUncheckedCreateWithoutRecordsInput>
  }

  export type semi_productsCreateWithoutRecordsInput = {
    createdAt: Date | string
    updatedAt: Date | string
    boils?: boilsCreateNestedOneWithoutSemi_productsInput
    products?: productsCreateNestedOneWithoutSemi_productsInput
  }

  export type semi_productsUncheckedCreateWithoutRecordsInput = {
    id?: number
    product_id?: number | null
    boil_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type semi_productsCreateOrConnectWithoutRecordsInput = {
    where: semi_productsWhereUniqueInput
    create: XOR<semi_productsCreateWithoutRecordsInput, semi_productsUncheckedCreateWithoutRecordsInput>
  }

  export type semi_productsCreateManyRecordsInputEnvelope = {
    data: semi_productsCreateManyRecordsInput | semi_productsCreateManyRecordsInput[]
    skipDuplicates?: boolean
  }

  export type historiesUpsertWithWhereUniqueWithoutRecordsInput = {
    where: historiesWhereUniqueInput
    update: XOR<historiesUpdateWithoutRecordsInput, historiesUncheckedUpdateWithoutRecordsInput>
    create: XOR<historiesCreateWithoutRecordsInput, historiesUncheckedCreateWithoutRecordsInput>
  }

  export type historiesUpdateWithWhereUniqueWithoutRecordsInput = {
    where: historiesWhereUniqueInput
    data: XOR<historiesUpdateWithoutRecordsInput, historiesUncheckedUpdateWithoutRecordsInput>
  }

  export type historiesUpdateManyWithWhereWithoutRecordsInput = {
    where: historiesScalarWhereInput
    data: XOR<historiesUpdateManyMutationInput, historiesUncheckedUpdateManyWithoutRecordsInput>
  }

  export type record_regulationsUpsertWithWhereUniqueWithoutRecordsInput = {
    where: record_regulationsWhereUniqueInput
    update: XOR<record_regulationsUpdateWithoutRecordsInput, record_regulationsUncheckedUpdateWithoutRecordsInput>
    create: XOR<record_regulationsCreateWithoutRecordsInput, record_regulationsUncheckedCreateWithoutRecordsInput>
  }

  export type record_regulationsUpdateWithWhereUniqueWithoutRecordsInput = {
    where: record_regulationsWhereUniqueInput
    data: XOR<record_regulationsUpdateWithoutRecordsInput, record_regulationsUncheckedUpdateWithoutRecordsInput>
  }

  export type record_regulationsUpdateManyWithWhereWithoutRecordsInput = {
    where: record_regulationsScalarWhereInput
    data: XOR<record_regulationsUpdateManyMutationInput, record_regulationsUncheckedUpdateManyWithoutRecordsInput>
  }

  export type apparatusesUpsertWithoutRecordsInput = {
    update: XOR<apparatusesUpdateWithoutRecordsInput, apparatusesUncheckedUpdateWithoutRecordsInput>
    create: XOR<apparatusesCreateWithoutRecordsInput, apparatusesUncheckedCreateWithoutRecordsInput>
    where?: apparatusesWhereInput
  }

  export type apparatusesUpdateToOneWithWhereWithoutRecordsInput = {
    where?: apparatusesWhereInput
    data: XOR<apparatusesUpdateWithoutRecordsInput, apparatusesUncheckedUpdateWithoutRecordsInput>
  }

  export type apparatusesUpdateWithoutRecordsInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type apparatusesUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type cansUpsertWithoutRecordsInput = {
    update: XOR<cansUpdateWithoutRecordsInput, cansUncheckedUpdateWithoutRecordsInput>
    create: XOR<cansCreateWithoutRecordsInput, cansUncheckedCreateWithoutRecordsInput>
    where?: cansWhereInput
  }

  export type cansUpdateToOneWithWhereWithoutRecordsInput = {
    where?: cansWhereInput
    data: XOR<cansUpdateWithoutRecordsInput, cansUncheckedUpdateWithoutRecordsInput>
  }

  export type cansUpdateWithoutRecordsInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type cansUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type conveyorsUpsertWithoutRecordsInput = {
    update: XOR<conveyorsUpdateWithoutRecordsInput, conveyorsUncheckedUpdateWithoutRecordsInput>
    create: XOR<conveyorsCreateWithoutRecordsInput, conveyorsUncheckedCreateWithoutRecordsInput>
    where?: conveyorsWhereInput
  }

  export type conveyorsUpdateToOneWithWhereWithoutRecordsInput = {
    where?: conveyorsWhereInput
    data: XOR<conveyorsUpdateWithoutRecordsInput, conveyorsUncheckedUpdateWithoutRecordsInput>
  }

  export type conveyorsUpdateWithoutRecordsInput = {
    value?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type conveyorsUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type docsUpsertWithoutRecordsInput = {
    update: XOR<docsUpdateWithoutRecordsInput, docsUncheckedUpdateWithoutRecordsInput>
    create: XOR<docsCreateWithoutRecordsInput, docsUncheckedCreateWithoutRecordsInput>
    where?: docsWhereInput
  }

  export type docsUpdateToOneWithWhereWithoutRecordsInput = {
    where?: docsWhereInput
    data: XOR<docsUpdateWithoutRecordsInput, docsUncheckedUpdateWithoutRecordsInput>
  }

  export type docsUpdateWithoutRecordsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plants?: plantsUpdateOneWithoutDocsNestedInput
  }

  export type docsUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plantId?: NullableIntFieldUpdateOperationsInput | number | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type productsUpsertWithoutRecordsInput = {
    update: XOR<productsUpdateWithoutRecordsInput, productsUncheckedUpdateWithoutRecordsInput>
    create: XOR<productsCreateWithoutRecordsInput, productsUncheckedCreateWithoutRecordsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutRecordsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutRecordsInput, productsUncheckedUpdateWithoutRecordsInput>
  }

  export type productsUpdateWithoutRecordsInput = {
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: seriesUpdateOneWithoutProductsNestedInput
    regulations?: regulationsUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    serieId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    regulations?: regulationsUncheckedUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type workshopsUpsertWithoutRecordsInput = {
    update: XOR<workshopsUpdateWithoutRecordsInput, workshopsUncheckedUpdateWithoutRecordsInput>
    create: XOR<workshopsCreateWithoutRecordsInput, workshopsUncheckedCreateWithoutRecordsInput>
    where?: workshopsWhereInput
  }

  export type workshopsUpdateToOneWithWhereWithoutRecordsInput = {
    where?: workshopsWhereInput
    data: XOR<workshopsUpdateWithoutRecordsInput, workshopsUncheckedUpdateWithoutRecordsInput>
  }

  export type workshopsUpdateWithoutRecordsInput = {
    value?: StringFieldUpdateOperationsInput | string
  }

  export type workshopsUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
  }

  export type boilsUpsertWithoutRecordsInput = {
    update: XOR<boilsUpdateWithoutRecordsInput, boilsUncheckedUpdateWithoutRecordsInput>
    create: XOR<boilsCreateWithoutRecordsInput, boilsUncheckedCreateWithoutRecordsInput>
    where?: boilsWhereInput
  }

  export type boilsUpdateToOneWithWhereWithoutRecordsInput = {
    where?: boilsWhereInput
    data: XOR<boilsUpdateWithoutRecordsInput, boilsUncheckedUpdateWithoutRecordsInput>
  }

  export type boilsUpdateWithoutRecordsInput = {
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    bases?: basesUpdateOneWithoutBoilsNestedInput
    semi_products?: semi_productsUpdateManyWithoutBoilsNestedInput
    tube_records?: tube_recordsUpdateManyWithoutBoilsNestedInput
  }

  export type boilsUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    base_id?: NullableIntFieldUpdateOperationsInput | number | null
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    semi_products?: semi_productsUncheckedUpdateManyWithoutBoilsNestedInput
    tube_records?: tube_recordsUncheckedUpdateManyWithoutBoilsNestedInput
  }

  export type semi_productsUpsertWithWhereUniqueWithoutRecordsInput = {
    where: semi_productsWhereUniqueInput
    update: XOR<semi_productsUpdateWithoutRecordsInput, semi_productsUncheckedUpdateWithoutRecordsInput>
    create: XOR<semi_productsCreateWithoutRecordsInput, semi_productsUncheckedCreateWithoutRecordsInput>
  }

  export type semi_productsUpdateWithWhereUniqueWithoutRecordsInput = {
    where: semi_productsWhereUniqueInput
    data: XOR<semi_productsUpdateWithoutRecordsInput, semi_productsUncheckedUpdateWithoutRecordsInput>
  }

  export type semi_productsUpdateManyWithWhereWithoutRecordsInput = {
    where: semi_productsScalarWhereInput
    data: XOR<semi_productsUpdateManyMutationInput, semi_productsUncheckedUpdateManyWithoutRecordsInput>
  }

  export type marking_sampleCreateWithoutRegulationsInput = {
    value?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    record_regulations?: record_regulationsCreateNestedManyWithoutMarking_sampleInput
  }

  export type marking_sampleUncheckedCreateWithoutRegulationsInput = {
    id?: number
    value?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutMarking_sampleInput
  }

  export type marking_sampleCreateOrConnectWithoutRegulationsInput = {
    where: marking_sampleWhereUniqueInput
    create: XOR<marking_sampleCreateWithoutRegulationsInput, marking_sampleUncheckedCreateWithoutRegulationsInput>
  }

  export type productsCreateWithoutRegulationsInput = {
    code1C: string
    marking: string
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    series?: seriesCreateNestedOneWithoutProductsInput
    records?: recordsCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutRegulationsInput = {
    id?: number
    code1C: string
    marking: string
    name?: string | null
    serieId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsUncheckedCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutRegulationsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutRegulationsInput, productsUncheckedCreateWithoutRegulationsInput>
  }

  export type marking_sampleUpsertWithoutRegulationsInput = {
    update: XOR<marking_sampleUpdateWithoutRegulationsInput, marking_sampleUncheckedUpdateWithoutRegulationsInput>
    create: XOR<marking_sampleCreateWithoutRegulationsInput, marking_sampleUncheckedCreateWithoutRegulationsInput>
    where?: marking_sampleWhereInput
  }

  export type marking_sampleUpdateToOneWithWhereWithoutRegulationsInput = {
    where?: marking_sampleWhereInput
    data: XOR<marking_sampleUpdateWithoutRegulationsInput, marking_sampleUncheckedUpdateWithoutRegulationsInput>
  }

  export type marking_sampleUpdateWithoutRegulationsInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record_regulations?: record_regulationsUpdateManyWithoutMarking_sampleNestedInput
  }

  export type marking_sampleUncheckedUpdateWithoutRegulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutMarking_sampleNestedInput
  }

  export type productsUpsertWithoutRegulationsInput = {
    update: XOR<productsUpdateWithoutRegulationsInput, productsUncheckedUpdateWithoutRegulationsInput>
    create: XOR<productsCreateWithoutRegulationsInput, productsUncheckedCreateWithoutRegulationsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutRegulationsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutRegulationsInput, productsUncheckedUpdateWithoutRegulationsInput>
  }

  export type productsUpdateWithoutRegulationsInput = {
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: seriesUpdateOneWithoutProductsNestedInput
    records?: recordsUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutRegulationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    serieId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUncheckedUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type user_rolesCreateWithoutRolesInput = {
    users: usersCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutRolesInput = {
    id?: number
    userId: number
  }

  export type user_rolesCreateOrConnectWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesCreateManyRolesInputEnvelope = {
    data: user_rolesCreateManyRolesInput | user_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<user_rolesCreateWithoutRolesInput, user_rolesUncheckedCreateWithoutRolesInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutRolesInput, user_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type user_rolesScalarWhereInput = {
    AND?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    OR?: user_rolesScalarWhereInput[]
    NOT?: user_rolesScalarWhereInput | user_rolesScalarWhereInput[]
    id?: IntFilter<"user_roles"> | number
    roleId?: IntFilter<"user_roles"> | number
    userId?: IntFilter<"user_roles"> | number
  }

  export type boilsCreateWithoutSemi_productsInput = {
    value: string
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    bases?: basesCreateNestedOneWithoutBoilsInput
    tube_records?: tube_recordsCreateNestedManyWithoutBoilsInput
    records?: recordsCreateNestedManyWithoutBoilsInput
  }

  export type boilsUncheckedCreateWithoutSemi_productsInput = {
    id?: number
    value: string
    base_id?: number | null
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutBoilsInput
    records?: recordsUncheckedCreateNestedManyWithoutBoilsInput
  }

  export type boilsCreateOrConnectWithoutSemi_productsInput = {
    where: boilsWhereUniqueInput
    create: XOR<boilsCreateWithoutSemi_productsInput, boilsUncheckedCreateWithoutSemi_productsInput>
  }

  export type productsCreateWithoutSemi_productsInput = {
    code1C: string
    marking: string
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    series?: seriesCreateNestedOneWithoutProductsInput
    records?: recordsCreateNestedManyWithoutProductsInput
    regulations?: regulationsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutSemi_productsInput = {
    id?: number
    code1C: string
    marking: string
    name?: string | null
    serieId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsUncheckedCreateNestedManyWithoutProductsInput
    regulations?: regulationsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutSemi_productsInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutSemi_productsInput, productsUncheckedCreateWithoutSemi_productsInput>
  }

  export type recordsCreateWithoutSemi_productsInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    workshops?: workshopsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutSemi_productsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutSemi_productsInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutSemi_productsInput, recordsUncheckedCreateWithoutSemi_productsInput>
  }

  export type boilsUpsertWithoutSemi_productsInput = {
    update: XOR<boilsUpdateWithoutSemi_productsInput, boilsUncheckedUpdateWithoutSemi_productsInput>
    create: XOR<boilsCreateWithoutSemi_productsInput, boilsUncheckedCreateWithoutSemi_productsInput>
    where?: boilsWhereInput
  }

  export type boilsUpdateToOneWithWhereWithoutSemi_productsInput = {
    where?: boilsWhereInput
    data: XOR<boilsUpdateWithoutSemi_productsInput, boilsUncheckedUpdateWithoutSemi_productsInput>
  }

  export type boilsUpdateWithoutSemi_productsInput = {
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    bases?: basesUpdateOneWithoutBoilsNestedInput
    tube_records?: tube_recordsUpdateManyWithoutBoilsNestedInput
    records?: recordsUpdateManyWithoutBoilsNestedInput
  }

  export type boilsUncheckedUpdateWithoutSemi_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    base_id?: NullableIntFieldUpdateOperationsInput | number | null
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_records?: tube_recordsUncheckedUpdateManyWithoutBoilsNestedInput
    records?: recordsUncheckedUpdateManyWithoutBoilsNestedInput
  }

  export type productsUpsertWithoutSemi_productsInput = {
    update: XOR<productsUpdateWithoutSemi_productsInput, productsUncheckedUpdateWithoutSemi_productsInput>
    create: XOR<productsCreateWithoutSemi_productsInput, productsUncheckedCreateWithoutSemi_productsInput>
    where?: productsWhereInput
  }

  export type productsUpdateToOneWithWhereWithoutSemi_productsInput = {
    where?: productsWhereInput
    data: XOR<productsUpdateWithoutSemi_productsInput, productsUncheckedUpdateWithoutSemi_productsInput>
  }

  export type productsUpdateWithoutSemi_productsInput = {
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    series?: seriesUpdateOneWithoutProductsNestedInput
    records?: recordsUpdateManyWithoutProductsNestedInput
    regulations?: regulationsUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutSemi_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    serieId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUncheckedUpdateManyWithoutProductsNestedInput
    regulations?: regulationsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type recordsUpsertWithoutSemi_productsInput = {
    update: XOR<recordsUpdateWithoutSemi_productsInput, recordsUncheckedUpdateWithoutSemi_productsInput>
    create: XOR<recordsCreateWithoutSemi_productsInput, recordsUncheckedCreateWithoutSemi_productsInput>
    where?: recordsWhereInput
  }

  export type recordsUpdateToOneWithWhereWithoutSemi_productsInput = {
    where?: recordsWhereInput
    data: XOR<recordsUpdateWithoutSemi_productsInput, recordsUncheckedUpdateWithoutSemi_productsInput>
  }

  export type recordsUpdateWithoutSemi_productsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutSemi_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type productsCreateWithoutSeriesInput = {
    code1C: string
    marking: string
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsCreateNestedManyWithoutProductsInput
    regulations?: regulationsCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsCreateNestedManyWithoutProductsInput
  }

  export type productsUncheckedCreateWithoutSeriesInput = {
    id?: number
    code1C: string
    marking: string
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    records?: recordsUncheckedCreateNestedManyWithoutProductsInput
    regulations?: regulationsUncheckedCreateNestedManyWithoutProductsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutProductsInput
  }

  export type productsCreateOrConnectWithoutSeriesInput = {
    where: productsWhereUniqueInput
    create: XOR<productsCreateWithoutSeriesInput, productsUncheckedCreateWithoutSeriesInput>
  }

  export type productsCreateManySeriesInputEnvelope = {
    data: productsCreateManySeriesInput | productsCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type productsUpsertWithWhereUniqueWithoutSeriesInput = {
    where: productsWhereUniqueInput
    update: XOR<productsUpdateWithoutSeriesInput, productsUncheckedUpdateWithoutSeriesInput>
    create: XOR<productsCreateWithoutSeriesInput, productsUncheckedCreateWithoutSeriesInput>
  }

  export type productsUpdateWithWhereUniqueWithoutSeriesInput = {
    where: productsWhereUniqueInput
    data: XOR<productsUpdateWithoutSeriesInput, productsUncheckedUpdateWithoutSeriesInput>
  }

  export type productsUpdateManyWithWhereWithoutSeriesInput = {
    where: productsScalarWhereInput
    data: XOR<productsUpdateManyMutationInput, productsUncheckedUpdateManyWithoutSeriesInput>
  }

  export type productsScalarWhereInput = {
    AND?: productsScalarWhereInput | productsScalarWhereInput[]
    OR?: productsScalarWhereInput[]
    NOT?: productsScalarWhereInput | productsScalarWhereInput[]
    id?: IntFilter<"products"> | number
    code1C?: StringFilter<"products"> | string
    marking?: StringFilter<"products"> | string
    name?: StringNullableFilter<"products"> | string | null
    serieId?: IntNullableFilter<"products"> | number | null
    createdAt?: DateTimeFilter<"products"> | Date | string
    updatedAt?: DateTimeFilter<"products"> | Date | string
  }

  export type usersCreateWithoutTokensInput = {
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutTokensInput = {
    id?: number
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesUncheckedCreateNestedManyWithoutUsersInput
    user_roles?: user_rolesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutTokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutTokensInput, usersUncheckedCreateWithoutTokensInput>
  }

  export type usersUpsertWithoutTokensInput = {
    update: XOR<usersUpdateWithoutTokensInput, usersUncheckedUpdateWithoutTokensInput>
    create: XOR<usersCreateWithoutTokensInput, usersUncheckedCreateWithoutTokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutTokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutTokensInput, usersUncheckedUpdateWithoutTokensInput>
  }

  export type usersUpdateWithoutTokensInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUncheckedUpdateManyWithoutUsersNestedInput
    user_roles?: user_rolesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type tube_conveyor_postsCreateWithoutTube_assemblyInput = {
    name: string
  }

  export type tube_conveyor_postsUncheckedCreateWithoutTube_assemblyInput = {
    id?: number
    name: string
  }

  export type tube_conveyor_postsCreateOrConnectWithoutTube_assemblyInput = {
    where: tube_conveyor_postsWhereUniqueInput
    create: XOR<tube_conveyor_postsCreateWithoutTube_assemblyInput, tube_conveyor_postsUncheckedCreateWithoutTube_assemblyInput>
  }

  export type tube_materialsCreateWithoutTube_assemblyInput = {
    code_1C?: string | null
    name?: string | null
    tube_specifications?: tube_specificationsCreateNestedManyWithoutTube_materialsInput
  }

  export type tube_materialsUncheckedCreateWithoutTube_assemblyInput = {
    id?: number
    code_1C?: string | null
    name?: string | null
    tube_specifications?: tube_specificationsUncheckedCreateNestedManyWithoutTube_materialsInput
  }

  export type tube_materialsCreateOrConnectWithoutTube_assemblyInput = {
    where: tube_materialsWhereUniqueInput
    create: XOR<tube_materialsCreateWithoutTube_assemblyInput, tube_materialsUncheckedCreateWithoutTube_assemblyInput>
  }

  export type tube_conveyor_postsUpsertWithoutTube_assemblyInput = {
    update: XOR<tube_conveyor_postsUpdateWithoutTube_assemblyInput, tube_conveyor_postsUncheckedUpdateWithoutTube_assemblyInput>
    create: XOR<tube_conveyor_postsCreateWithoutTube_assemblyInput, tube_conveyor_postsUncheckedCreateWithoutTube_assemblyInput>
    where?: tube_conveyor_postsWhereInput
  }

  export type tube_conveyor_postsUpdateToOneWithWhereWithoutTube_assemblyInput = {
    where?: tube_conveyor_postsWhereInput
    data: XOR<tube_conveyor_postsUpdateWithoutTube_assemblyInput, tube_conveyor_postsUncheckedUpdateWithoutTube_assemblyInput>
  }

  export type tube_conveyor_postsUpdateWithoutTube_assemblyInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tube_conveyor_postsUncheckedUpdateWithoutTube_assemblyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tube_materialsUpsertWithoutTube_assemblyInput = {
    update: XOR<tube_materialsUpdateWithoutTube_assemblyInput, tube_materialsUncheckedUpdateWithoutTube_assemblyInput>
    create: XOR<tube_materialsCreateWithoutTube_assemblyInput, tube_materialsUncheckedCreateWithoutTube_assemblyInput>
    where?: tube_materialsWhereInput
  }

  export type tube_materialsUpdateToOneWithWhereWithoutTube_assemblyInput = {
    where?: tube_materialsWhereInput
    data: XOR<tube_materialsUpdateWithoutTube_assemblyInput, tube_materialsUncheckedUpdateWithoutTube_assemblyInput>
  }

  export type tube_materialsUpdateWithoutTube_assemblyInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_specifications?: tube_specificationsUpdateManyWithoutTube_materialsNestedInput
  }

  export type tube_materialsUncheckedUpdateWithoutTube_assemblyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_specifications?: tube_specificationsUncheckedUpdateManyWithoutTube_materialsNestedInput
  }

  export type tube_assemblyCreateWithoutTube_conveyor_postsInput = {
    tube_record_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_materials?: tube_materialsCreateNestedOneWithoutTube_assemblyInput
  }

  export type tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput = {
    id?: number
    tube_record_id?: number | null
    tube_material_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_assemblyCreateOrConnectWithoutTube_conveyor_postsInput = {
    where: tube_assemblyWhereUniqueInput
    create: XOR<tube_assemblyCreateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput>
  }

  export type tube_assemblyCreateManyTube_conveyor_postsInputEnvelope = {
    data: tube_assemblyCreateManyTube_conveyor_postsInput | tube_assemblyCreateManyTube_conveyor_postsInput[]
    skipDuplicates?: boolean
  }

  export type tube_assemblyUpsertWithWhereUniqueWithoutTube_conveyor_postsInput = {
    where: tube_assemblyWhereUniqueInput
    update: XOR<tube_assemblyUpdateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedUpdateWithoutTube_conveyor_postsInput>
    create: XOR<tube_assemblyCreateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedCreateWithoutTube_conveyor_postsInput>
  }

  export type tube_assemblyUpdateWithWhereUniqueWithoutTube_conveyor_postsInput = {
    where: tube_assemblyWhereUniqueInput
    data: XOR<tube_assemblyUpdateWithoutTube_conveyor_postsInput, tube_assemblyUncheckedUpdateWithoutTube_conveyor_postsInput>
  }

  export type tube_assemblyUpdateManyWithWhereWithoutTube_conveyor_postsInput = {
    where: tube_assemblyScalarWhereInput
    data: XOR<tube_assemblyUpdateManyMutationInput, tube_assemblyUncheckedUpdateManyWithoutTube_conveyor_postsInput>
  }

  export type tube_assemblyScalarWhereInput = {
    AND?: tube_assemblyScalarWhereInput | tube_assemblyScalarWhereInput[]
    OR?: tube_assemblyScalarWhereInput[]
    NOT?: tube_assemblyScalarWhereInput | tube_assemblyScalarWhereInput[]
    id?: IntFilter<"tube_assembly"> | number
    tube_record_id?: IntNullableFilter<"tube_assembly"> | number | null
    tube_material_id?: IntNullableFilter<"tube_assembly"> | number | null
    tube_conveyor_post_id?: IntNullableFilter<"tube_assembly"> | number | null
    createdAt?: DateTimeFilter<"tube_assembly"> | Date | string
    updatedAt?: DateTimeFilter<"tube_assembly"> | Date | string
  }

  export type tube_recordsCreateWithoutTube_conveyorsInput = {
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    boils?: boilsCreateNestedOneWithoutTube_recordsInput
    tube_products?: tube_productsCreateNestedOneWithoutTube_recordsInput
  }

  export type tube_recordsUncheckedCreateWithoutTube_conveyorsInput = {
    id?: number
    tube_product_id?: number | null
    boil_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsCreateOrConnectWithoutTube_conveyorsInput = {
    where: tube_recordsWhereUniqueInput
    create: XOR<tube_recordsCreateWithoutTube_conveyorsInput, tube_recordsUncheckedCreateWithoutTube_conveyorsInput>
  }

  export type tube_recordsCreateManyTube_conveyorsInputEnvelope = {
    data: tube_recordsCreateManyTube_conveyorsInput | tube_recordsCreateManyTube_conveyorsInput[]
    skipDuplicates?: boolean
  }

  export type tube_sessionsCreateWithoutTube_conveyorsInput = {
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    employees?: employeesCreateNestedOneWithoutTube_sessionsInput
  }

  export type tube_sessionsUncheckedCreateWithoutTube_conveyorsInput = {
    id?: number
    employee_id?: number | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_sessionsCreateOrConnectWithoutTube_conveyorsInput = {
    where: tube_sessionsWhereUniqueInput
    create: XOR<tube_sessionsCreateWithoutTube_conveyorsInput, tube_sessionsUncheckedCreateWithoutTube_conveyorsInput>
  }

  export type tube_sessionsCreateManyTube_conveyorsInputEnvelope = {
    data: tube_sessionsCreateManyTube_conveyorsInput | tube_sessionsCreateManyTube_conveyorsInput[]
    skipDuplicates?: boolean
  }

  export type tube_recordsUpsertWithWhereUniqueWithoutTube_conveyorsInput = {
    where: tube_recordsWhereUniqueInput
    update: XOR<tube_recordsUpdateWithoutTube_conveyorsInput, tube_recordsUncheckedUpdateWithoutTube_conveyorsInput>
    create: XOR<tube_recordsCreateWithoutTube_conveyorsInput, tube_recordsUncheckedCreateWithoutTube_conveyorsInput>
  }

  export type tube_recordsUpdateWithWhereUniqueWithoutTube_conveyorsInput = {
    where: tube_recordsWhereUniqueInput
    data: XOR<tube_recordsUpdateWithoutTube_conveyorsInput, tube_recordsUncheckedUpdateWithoutTube_conveyorsInput>
  }

  export type tube_recordsUpdateManyWithWhereWithoutTube_conveyorsInput = {
    where: tube_recordsScalarWhereInput
    data: XOR<tube_recordsUpdateManyMutationInput, tube_recordsUncheckedUpdateManyWithoutTube_conveyorsInput>
  }

  export type tube_sessionsUpsertWithWhereUniqueWithoutTube_conveyorsInput = {
    where: tube_sessionsWhereUniqueInput
    update: XOR<tube_sessionsUpdateWithoutTube_conveyorsInput, tube_sessionsUncheckedUpdateWithoutTube_conveyorsInput>
    create: XOR<tube_sessionsCreateWithoutTube_conveyorsInput, tube_sessionsUncheckedCreateWithoutTube_conveyorsInput>
  }

  export type tube_sessionsUpdateWithWhereUniqueWithoutTube_conveyorsInput = {
    where: tube_sessionsWhereUniqueInput
    data: XOR<tube_sessionsUpdateWithoutTube_conveyorsInput, tube_sessionsUncheckedUpdateWithoutTube_conveyorsInput>
  }

  export type tube_sessionsUpdateManyWithWhereWithoutTube_conveyorsInput = {
    where: tube_sessionsScalarWhereInput
    data: XOR<tube_sessionsUpdateManyMutationInput, tube_sessionsUncheckedUpdateManyWithoutTube_conveyorsInput>
  }

  export type employeesCreateWithoutTube_historiesInput = {
    name: string
    barcode: string
    createdAt: Date | string
    updatedAt: Date | string
    occupations?: occupationsCreateNestedOneWithoutEmployeesInput
    histories?: historiesCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutTube_historiesInput = {
    id?: number
    name: string
    barcode: string
    occupationId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesUncheckedCreateNestedManyWithoutEmployeesInput
    tube_sessions?: tube_sessionsUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesCreateOrConnectWithoutTube_historiesInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutTube_historiesInput, employeesUncheckedCreateWithoutTube_historiesInput>
  }

  export type tube_histories_notesCreateWithoutTube_historiesInput = {
    value?: string | null
  }

  export type tube_histories_notesUncheckedCreateWithoutTube_historiesInput = {
    id?: number
    value?: string | null
  }

  export type tube_histories_notesCreateOrConnectWithoutTube_historiesInput = {
    where: tube_histories_notesWhereUniqueInput
    create: XOR<tube_histories_notesCreateWithoutTube_historiesInput, tube_histories_notesUncheckedCreateWithoutTube_historiesInput>
  }

  export type tube_history_typesCreateWithoutTube_historiesInput = {
    value: string
    description: string
  }

  export type tube_history_typesUncheckedCreateWithoutTube_historiesInput = {
    id?: number
    value: string
    description: string
  }

  export type tube_history_typesCreateOrConnectWithoutTube_historiesInput = {
    where: tube_history_typesWhereUniqueInput
    create: XOR<tube_history_typesCreateWithoutTube_historiesInput, tube_history_typesUncheckedCreateWithoutTube_historiesInput>
  }

  export type employeesUpsertWithoutTube_historiesInput = {
    update: XOR<employeesUpdateWithoutTube_historiesInput, employeesUncheckedUpdateWithoutTube_historiesInput>
    create: XOR<employeesCreateWithoutTube_historiesInput, employeesUncheckedCreateWithoutTube_historiesInput>
    where?: employeesWhereInput
  }

  export type employeesUpdateToOneWithWhereWithoutTube_historiesInput = {
    where?: employeesWhereInput
    data: XOR<employeesUpdateWithoutTube_historiesInput, employeesUncheckedUpdateWithoutTube_historiesInput>
  }

  export type employeesUpdateWithoutTube_historiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occupations?: occupationsUpdateOneWithoutEmployeesNestedInput
    histories?: historiesUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutTube_historiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    occupationId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUncheckedUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUncheckedUpdateManyWithoutEmployeesNestedInput
  }

  export type tube_histories_notesUpsertWithoutTube_historiesInput = {
    update: XOR<tube_histories_notesUpdateWithoutTube_historiesInput, tube_histories_notesUncheckedUpdateWithoutTube_historiesInput>
    create: XOR<tube_histories_notesCreateWithoutTube_historiesInput, tube_histories_notesUncheckedCreateWithoutTube_historiesInput>
    where?: tube_histories_notesWhereInput
  }

  export type tube_histories_notesUpdateToOneWithWhereWithoutTube_historiesInput = {
    where?: tube_histories_notesWhereInput
    data: XOR<tube_histories_notesUpdateWithoutTube_historiesInput, tube_histories_notesUncheckedUpdateWithoutTube_historiesInput>
  }

  export type tube_histories_notesUpdateWithoutTube_historiesInput = {
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_histories_notesUncheckedUpdateWithoutTube_historiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tube_history_typesUpsertWithoutTube_historiesInput = {
    update: XOR<tube_history_typesUpdateWithoutTube_historiesInput, tube_history_typesUncheckedUpdateWithoutTube_historiesInput>
    create: XOR<tube_history_typesCreateWithoutTube_historiesInput, tube_history_typesUncheckedCreateWithoutTube_historiesInput>
    where?: tube_history_typesWhereInput
  }

  export type tube_history_typesUpdateToOneWithWhereWithoutTube_historiesInput = {
    where?: tube_history_typesWhereInput
    data: XOR<tube_history_typesUpdateWithoutTube_historiesInput, tube_history_typesUncheckedUpdateWithoutTube_historiesInput>
  }

  export type tube_history_typesUpdateWithoutTube_historiesInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type tube_history_typesUncheckedUpdateWithoutTube_historiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type tube_historiesCreateWithoutTube_histories_notesInput = {
    tube_record_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    employees?: employeesCreateNestedOneWithoutTube_historiesInput
    tube_history_types?: tube_history_typesCreateNestedOneWithoutTube_historiesInput
  }

  export type tube_historiesUncheckedCreateWithoutTube_histories_notesInput = {
    id?: number
    tube_record_id?: number | null
    tube_history_type_id?: number | null
    employee_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_historiesCreateOrConnectWithoutTube_histories_notesInput = {
    where: tube_historiesWhereUniqueInput
    create: XOR<tube_historiesCreateWithoutTube_histories_notesInput, tube_historiesUncheckedCreateWithoutTube_histories_notesInput>
  }

  export type tube_historiesCreateManyTube_histories_notesInputEnvelope = {
    data: tube_historiesCreateManyTube_histories_notesInput | tube_historiesCreateManyTube_histories_notesInput[]
    skipDuplicates?: boolean
  }

  export type tube_historiesUpsertWithWhereUniqueWithoutTube_histories_notesInput = {
    where: tube_historiesWhereUniqueInput
    update: XOR<tube_historiesUpdateWithoutTube_histories_notesInput, tube_historiesUncheckedUpdateWithoutTube_histories_notesInput>
    create: XOR<tube_historiesCreateWithoutTube_histories_notesInput, tube_historiesUncheckedCreateWithoutTube_histories_notesInput>
  }

  export type tube_historiesUpdateWithWhereUniqueWithoutTube_histories_notesInput = {
    where: tube_historiesWhereUniqueInput
    data: XOR<tube_historiesUpdateWithoutTube_histories_notesInput, tube_historiesUncheckedUpdateWithoutTube_histories_notesInput>
  }

  export type tube_historiesUpdateManyWithWhereWithoutTube_histories_notesInput = {
    where: tube_historiesScalarWhereInput
    data: XOR<tube_historiesUpdateManyMutationInput, tube_historiesUncheckedUpdateManyWithoutTube_histories_notesInput>
  }

  export type tube_historiesCreateWithoutTube_history_typesInput = {
    tube_record_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    employees?: employeesCreateNestedOneWithoutTube_historiesInput
    tube_histories_notes?: tube_histories_notesCreateNestedOneWithoutTube_historiesInput
  }

  export type tube_historiesUncheckedCreateWithoutTube_history_typesInput = {
    id?: number
    tube_record_id?: number | null
    employee_id?: number | null
    note?: string | null
    tube_history_note_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_historiesCreateOrConnectWithoutTube_history_typesInput = {
    where: tube_historiesWhereUniqueInput
    create: XOR<tube_historiesCreateWithoutTube_history_typesInput, tube_historiesUncheckedCreateWithoutTube_history_typesInput>
  }

  export type tube_historiesCreateManyTube_history_typesInputEnvelope = {
    data: tube_historiesCreateManyTube_history_typesInput | tube_historiesCreateManyTube_history_typesInput[]
    skipDuplicates?: boolean
  }

  export type tube_historiesUpsertWithWhereUniqueWithoutTube_history_typesInput = {
    where: tube_historiesWhereUniqueInput
    update: XOR<tube_historiesUpdateWithoutTube_history_typesInput, tube_historiesUncheckedUpdateWithoutTube_history_typesInput>
    create: XOR<tube_historiesCreateWithoutTube_history_typesInput, tube_historiesUncheckedCreateWithoutTube_history_typesInput>
  }

  export type tube_historiesUpdateWithWhereUniqueWithoutTube_history_typesInput = {
    where: tube_historiesWhereUniqueInput
    data: XOR<tube_historiesUpdateWithoutTube_history_typesInput, tube_historiesUncheckedUpdateWithoutTube_history_typesInput>
  }

  export type tube_historiesUpdateManyWithWhereWithoutTube_history_typesInput = {
    where: tube_historiesScalarWhereInput
    data: XOR<tube_historiesUpdateManyMutationInput, tube_historiesUncheckedUpdateManyWithoutTube_history_typesInput>
  }

  export type tube_assemblyCreateWithoutTube_materialsInput = {
    tube_record_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    tube_conveyor_posts?: tube_conveyor_postsCreateNestedOneWithoutTube_assemblyInput
  }

  export type tube_assemblyUncheckedCreateWithoutTube_materialsInput = {
    id?: number
    tube_record_id?: number | null
    tube_conveyor_post_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_assemblyCreateOrConnectWithoutTube_materialsInput = {
    where: tube_assemblyWhereUniqueInput
    create: XOR<tube_assemblyCreateWithoutTube_materialsInput, tube_assemblyUncheckedCreateWithoutTube_materialsInput>
  }

  export type tube_assemblyCreateManyTube_materialsInputEnvelope = {
    data: tube_assemblyCreateManyTube_materialsInput | tube_assemblyCreateManyTube_materialsInput[]
    skipDuplicates?: boolean
  }

  export type tube_specificationsCreateWithoutTube_materialsInput = {
    createdAt: Date | string
    updatedAt: Date | string
    tube_products?: tube_productsCreateNestedOneWithoutTube_specificationsInput
  }

  export type tube_specificationsUncheckedCreateWithoutTube_materialsInput = {
    id?: number
    tube_product_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_specificationsCreateOrConnectWithoutTube_materialsInput = {
    where: tube_specificationsWhereUniqueInput
    create: XOR<tube_specificationsCreateWithoutTube_materialsInput, tube_specificationsUncheckedCreateWithoutTube_materialsInput>
  }

  export type tube_specificationsCreateManyTube_materialsInputEnvelope = {
    data: tube_specificationsCreateManyTube_materialsInput | tube_specificationsCreateManyTube_materialsInput[]
    skipDuplicates?: boolean
  }

  export type tube_assemblyUpsertWithWhereUniqueWithoutTube_materialsInput = {
    where: tube_assemblyWhereUniqueInput
    update: XOR<tube_assemblyUpdateWithoutTube_materialsInput, tube_assemblyUncheckedUpdateWithoutTube_materialsInput>
    create: XOR<tube_assemblyCreateWithoutTube_materialsInput, tube_assemblyUncheckedCreateWithoutTube_materialsInput>
  }

  export type tube_assemblyUpdateWithWhereUniqueWithoutTube_materialsInput = {
    where: tube_assemblyWhereUniqueInput
    data: XOR<tube_assemblyUpdateWithoutTube_materialsInput, tube_assemblyUncheckedUpdateWithoutTube_materialsInput>
  }

  export type tube_assemblyUpdateManyWithWhereWithoutTube_materialsInput = {
    where: tube_assemblyScalarWhereInput
    data: XOR<tube_assemblyUpdateManyMutationInput, tube_assemblyUncheckedUpdateManyWithoutTube_materialsInput>
  }

  export type tube_specificationsUpsertWithWhereUniqueWithoutTube_materialsInput = {
    where: tube_specificationsWhereUniqueInput
    update: XOR<tube_specificationsUpdateWithoutTube_materialsInput, tube_specificationsUncheckedUpdateWithoutTube_materialsInput>
    create: XOR<tube_specificationsCreateWithoutTube_materialsInput, tube_specificationsUncheckedCreateWithoutTube_materialsInput>
  }

  export type tube_specificationsUpdateWithWhereUniqueWithoutTube_materialsInput = {
    where: tube_specificationsWhereUniqueInput
    data: XOR<tube_specificationsUpdateWithoutTube_materialsInput, tube_specificationsUncheckedUpdateWithoutTube_materialsInput>
  }

  export type tube_specificationsUpdateManyWithWhereWithoutTube_materialsInput = {
    where: tube_specificationsScalarWhereInput
    data: XOR<tube_specificationsUpdateManyMutationInput, tube_specificationsUncheckedUpdateManyWithoutTube_materialsInput>
  }

  export type tube_specificationsScalarWhereInput = {
    AND?: tube_specificationsScalarWhereInput | tube_specificationsScalarWhereInput[]
    OR?: tube_specificationsScalarWhereInput[]
    NOT?: tube_specificationsScalarWhereInput | tube_specificationsScalarWhereInput[]
    id?: IntFilter<"tube_specifications"> | number
    tube_product_id?: IntNullableFilter<"tube_specifications"> | number | null
    tube_material_id?: IntNullableFilter<"tube_specifications"> | number | null
    createdAt?: DateTimeFilter<"tube_specifications"> | Date | string
    updatedAt?: DateTimeFilter<"tube_specifications"> | Date | string
  }

  export type tube_recordsCreateWithoutTube_productsInput = {
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    boils?: boilsCreateNestedOneWithoutTube_recordsInput
    tube_conveyors?: tube_conveyorsCreateNestedOneWithoutTube_recordsInput
  }

  export type tube_recordsUncheckedCreateWithoutTube_productsInput = {
    id?: number
    tube_conveyor_id?: number | null
    boil_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsCreateOrConnectWithoutTube_productsInput = {
    where: tube_recordsWhereUniqueInput
    create: XOR<tube_recordsCreateWithoutTube_productsInput, tube_recordsUncheckedCreateWithoutTube_productsInput>
  }

  export type tube_recordsCreateManyTube_productsInputEnvelope = {
    data: tube_recordsCreateManyTube_productsInput | tube_recordsCreateManyTube_productsInput[]
    skipDuplicates?: boolean
  }

  export type tube_specificationsCreateWithoutTube_productsInput = {
    createdAt: Date | string
    updatedAt: Date | string
    tube_materials?: tube_materialsCreateNestedOneWithoutTube_specificationsInput
  }

  export type tube_specificationsUncheckedCreateWithoutTube_productsInput = {
    id?: number
    tube_material_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_specificationsCreateOrConnectWithoutTube_productsInput = {
    where: tube_specificationsWhereUniqueInput
    create: XOR<tube_specificationsCreateWithoutTube_productsInput, tube_specificationsUncheckedCreateWithoutTube_productsInput>
  }

  export type tube_specificationsCreateManyTube_productsInputEnvelope = {
    data: tube_specificationsCreateManyTube_productsInput | tube_specificationsCreateManyTube_productsInput[]
    skipDuplicates?: boolean
  }

  export type tube_recordsUpsertWithWhereUniqueWithoutTube_productsInput = {
    where: tube_recordsWhereUniqueInput
    update: XOR<tube_recordsUpdateWithoutTube_productsInput, tube_recordsUncheckedUpdateWithoutTube_productsInput>
    create: XOR<tube_recordsCreateWithoutTube_productsInput, tube_recordsUncheckedCreateWithoutTube_productsInput>
  }

  export type tube_recordsUpdateWithWhereUniqueWithoutTube_productsInput = {
    where: tube_recordsWhereUniqueInput
    data: XOR<tube_recordsUpdateWithoutTube_productsInput, tube_recordsUncheckedUpdateWithoutTube_productsInput>
  }

  export type tube_recordsUpdateManyWithWhereWithoutTube_productsInput = {
    where: tube_recordsScalarWhereInput
    data: XOR<tube_recordsUpdateManyMutationInput, tube_recordsUncheckedUpdateManyWithoutTube_productsInput>
  }

  export type tube_specificationsUpsertWithWhereUniqueWithoutTube_productsInput = {
    where: tube_specificationsWhereUniqueInput
    update: XOR<tube_specificationsUpdateWithoutTube_productsInput, tube_specificationsUncheckedUpdateWithoutTube_productsInput>
    create: XOR<tube_specificationsCreateWithoutTube_productsInput, tube_specificationsUncheckedCreateWithoutTube_productsInput>
  }

  export type tube_specificationsUpdateWithWhereUniqueWithoutTube_productsInput = {
    where: tube_specificationsWhereUniqueInput
    data: XOR<tube_specificationsUpdateWithoutTube_productsInput, tube_specificationsUncheckedUpdateWithoutTube_productsInput>
  }

  export type tube_specificationsUpdateManyWithWhereWithoutTube_productsInput = {
    where: tube_specificationsScalarWhereInput
    data: XOR<tube_specificationsUpdateManyMutationInput, tube_specificationsUncheckedUpdateManyWithoutTube_productsInput>
  }

  export type boilsCreateWithoutTube_recordsInput = {
    value: string
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    bases?: basesCreateNestedOneWithoutBoilsInput
    semi_products?: semi_productsCreateNestedManyWithoutBoilsInput
    records?: recordsCreateNestedManyWithoutBoilsInput
  }

  export type boilsUncheckedCreateWithoutTube_recordsInput = {
    id?: number
    value: string
    base_id?: number | null
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutBoilsInput
    records?: recordsUncheckedCreateNestedManyWithoutBoilsInput
  }

  export type boilsCreateOrConnectWithoutTube_recordsInput = {
    where: boilsWhereUniqueInput
    create: XOR<boilsCreateWithoutTube_recordsInput, boilsUncheckedCreateWithoutTube_recordsInput>
  }

  export type tube_conveyorsCreateWithoutTube_recordsInput = {
    name?: string | null
    barcode?: string | null
    tube_sessions?: tube_sessionsCreateNestedManyWithoutTube_conveyorsInput
  }

  export type tube_conveyorsUncheckedCreateWithoutTube_recordsInput = {
    id?: number
    name?: string | null
    barcode?: string | null
    tube_sessions?: tube_sessionsUncheckedCreateNestedManyWithoutTube_conveyorsInput
  }

  export type tube_conveyorsCreateOrConnectWithoutTube_recordsInput = {
    where: tube_conveyorsWhereUniqueInput
    create: XOR<tube_conveyorsCreateWithoutTube_recordsInput, tube_conveyorsUncheckedCreateWithoutTube_recordsInput>
  }

  export type tube_productsCreateWithoutTube_recordsInput = {
    code_1C?: string | null
    marking?: string | null
    name?: string | null
    tube_specifications?: tube_specificationsCreateNestedManyWithoutTube_productsInput
  }

  export type tube_productsUncheckedCreateWithoutTube_recordsInput = {
    id?: number
    code_1C?: string | null
    marking?: string | null
    name?: string | null
    tube_specifications?: tube_specificationsUncheckedCreateNestedManyWithoutTube_productsInput
  }

  export type tube_productsCreateOrConnectWithoutTube_recordsInput = {
    where: tube_productsWhereUniqueInput
    create: XOR<tube_productsCreateWithoutTube_recordsInput, tube_productsUncheckedCreateWithoutTube_recordsInput>
  }

  export type boilsUpsertWithoutTube_recordsInput = {
    update: XOR<boilsUpdateWithoutTube_recordsInput, boilsUncheckedUpdateWithoutTube_recordsInput>
    create: XOR<boilsCreateWithoutTube_recordsInput, boilsUncheckedCreateWithoutTube_recordsInput>
    where?: boilsWhereInput
  }

  export type boilsUpdateToOneWithWhereWithoutTube_recordsInput = {
    where?: boilsWhereInput
    data: XOR<boilsUpdateWithoutTube_recordsInput, boilsUncheckedUpdateWithoutTube_recordsInput>
  }

  export type boilsUpdateWithoutTube_recordsInput = {
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    bases?: basesUpdateOneWithoutBoilsNestedInput
    semi_products?: semi_productsUpdateManyWithoutBoilsNestedInput
    records?: recordsUpdateManyWithoutBoilsNestedInput
  }

  export type boilsUncheckedUpdateWithoutTube_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    base_id?: NullableIntFieldUpdateOperationsInput | number | null
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    semi_products?: semi_productsUncheckedUpdateManyWithoutBoilsNestedInput
    records?: recordsUncheckedUpdateManyWithoutBoilsNestedInput
  }

  export type tube_conveyorsUpsertWithoutTube_recordsInput = {
    update: XOR<tube_conveyorsUpdateWithoutTube_recordsInput, tube_conveyorsUncheckedUpdateWithoutTube_recordsInput>
    create: XOR<tube_conveyorsCreateWithoutTube_recordsInput, tube_conveyorsUncheckedCreateWithoutTube_recordsInput>
    where?: tube_conveyorsWhereInput
  }

  export type tube_conveyorsUpdateToOneWithWhereWithoutTube_recordsInput = {
    where?: tube_conveyorsWhereInput
    data: XOR<tube_conveyorsUpdateWithoutTube_recordsInput, tube_conveyorsUncheckedUpdateWithoutTube_recordsInput>
  }

  export type tube_conveyorsUpdateWithoutTube_recordsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    tube_sessions?: tube_sessionsUpdateManyWithoutTube_conveyorsNestedInput
  }

  export type tube_conveyorsUncheckedUpdateWithoutTube_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    tube_sessions?: tube_sessionsUncheckedUpdateManyWithoutTube_conveyorsNestedInput
  }

  export type tube_productsUpsertWithoutTube_recordsInput = {
    update: XOR<tube_productsUpdateWithoutTube_recordsInput, tube_productsUncheckedUpdateWithoutTube_recordsInput>
    create: XOR<tube_productsCreateWithoutTube_recordsInput, tube_productsUncheckedCreateWithoutTube_recordsInput>
    where?: tube_productsWhereInput
  }

  export type tube_productsUpdateToOneWithWhereWithoutTube_recordsInput = {
    where?: tube_productsWhereInput
    data: XOR<tube_productsUpdateWithoutTube_recordsInput, tube_productsUncheckedUpdateWithoutTube_recordsInput>
  }

  export type tube_productsUpdateWithoutTube_recordsInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_specifications?: tube_specificationsUpdateManyWithoutTube_productsNestedInput
  }

  export type tube_productsUncheckedUpdateWithoutTube_recordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_specifications?: tube_specificationsUncheckedUpdateManyWithoutTube_productsNestedInput
  }

  export type tube_conveyorsCreateWithoutTube_sessionsInput = {
    name?: string | null
    barcode?: string | null
    tube_records?: tube_recordsCreateNestedManyWithoutTube_conveyorsInput
  }

  export type tube_conveyorsUncheckedCreateWithoutTube_sessionsInput = {
    id?: number
    name?: string | null
    barcode?: string | null
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutTube_conveyorsInput
  }

  export type tube_conveyorsCreateOrConnectWithoutTube_sessionsInput = {
    where: tube_conveyorsWhereUniqueInput
    create: XOR<tube_conveyorsCreateWithoutTube_sessionsInput, tube_conveyorsUncheckedCreateWithoutTube_sessionsInput>
  }

  export type employeesCreateWithoutTube_sessionsInput = {
    name: string
    barcode: string
    createdAt: Date | string
    updatedAt: Date | string
    occupations?: occupationsCreateNestedOneWithoutEmployeesInput
    histories?: historiesCreateNestedManyWithoutEmployeesInput
    tube_histories?: tube_historiesCreateNestedManyWithoutEmployeesInput
  }

  export type employeesUncheckedCreateWithoutTube_sessionsInput = {
    id?: number
    name: string
    barcode: string
    occupationId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesUncheckedCreateNestedManyWithoutEmployeesInput
    tube_histories?: tube_historiesUncheckedCreateNestedManyWithoutEmployeesInput
  }

  export type employeesCreateOrConnectWithoutTube_sessionsInput = {
    where: employeesWhereUniqueInput
    create: XOR<employeesCreateWithoutTube_sessionsInput, employeesUncheckedCreateWithoutTube_sessionsInput>
  }

  export type tube_conveyorsUpsertWithoutTube_sessionsInput = {
    update: XOR<tube_conveyorsUpdateWithoutTube_sessionsInput, tube_conveyorsUncheckedUpdateWithoutTube_sessionsInput>
    create: XOR<tube_conveyorsCreateWithoutTube_sessionsInput, tube_conveyorsUncheckedCreateWithoutTube_sessionsInput>
    where?: tube_conveyorsWhereInput
  }

  export type tube_conveyorsUpdateToOneWithWhereWithoutTube_sessionsInput = {
    where?: tube_conveyorsWhereInput
    data: XOR<tube_conveyorsUpdateWithoutTube_sessionsInput, tube_conveyorsUncheckedUpdateWithoutTube_sessionsInput>
  }

  export type tube_conveyorsUpdateWithoutTube_sessionsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUpdateManyWithoutTube_conveyorsNestedInput
  }

  export type tube_conveyorsUncheckedUpdateWithoutTube_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    barcode?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUncheckedUpdateManyWithoutTube_conveyorsNestedInput
  }

  export type employeesUpsertWithoutTube_sessionsInput = {
    update: XOR<employeesUpdateWithoutTube_sessionsInput, employeesUncheckedUpdateWithoutTube_sessionsInput>
    create: XOR<employeesCreateWithoutTube_sessionsInput, employeesUncheckedCreateWithoutTube_sessionsInput>
    where?: employeesWhereInput
  }

  export type employeesUpdateToOneWithWhereWithoutTube_sessionsInput = {
    where?: employeesWhereInput
    data: XOR<employeesUpdateWithoutTube_sessionsInput, employeesUncheckedUpdateWithoutTube_sessionsInput>
  }

  export type employeesUpdateWithoutTube_sessionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    occupations?: occupationsUpdateOneWithoutEmployeesNestedInput
    histories?: historiesUpdateManyWithoutEmployeesNestedInput
    tube_histories?: tube_historiesUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutTube_sessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    occupationId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUncheckedUpdateManyWithoutEmployeesNestedInput
    tube_histories?: tube_historiesUncheckedUpdateManyWithoutEmployeesNestedInput
  }

  export type tube_materialsCreateWithoutTube_specificationsInput = {
    code_1C?: string | null
    name?: string | null
    tube_assembly?: tube_assemblyCreateNestedManyWithoutTube_materialsInput
  }

  export type tube_materialsUncheckedCreateWithoutTube_specificationsInput = {
    id?: number
    code_1C?: string | null
    name?: string | null
    tube_assembly?: tube_assemblyUncheckedCreateNestedManyWithoutTube_materialsInput
  }

  export type tube_materialsCreateOrConnectWithoutTube_specificationsInput = {
    where: tube_materialsWhereUniqueInput
    create: XOR<tube_materialsCreateWithoutTube_specificationsInput, tube_materialsUncheckedCreateWithoutTube_specificationsInput>
  }

  export type tube_productsCreateWithoutTube_specificationsInput = {
    code_1C?: string | null
    marking?: string | null
    name?: string | null
    tube_records?: tube_recordsCreateNestedManyWithoutTube_productsInput
  }

  export type tube_productsUncheckedCreateWithoutTube_specificationsInput = {
    id?: number
    code_1C?: string | null
    marking?: string | null
    name?: string | null
    tube_records?: tube_recordsUncheckedCreateNestedManyWithoutTube_productsInput
  }

  export type tube_productsCreateOrConnectWithoutTube_specificationsInput = {
    where: tube_productsWhereUniqueInput
    create: XOR<tube_productsCreateWithoutTube_specificationsInput, tube_productsUncheckedCreateWithoutTube_specificationsInput>
  }

  export type tube_materialsUpsertWithoutTube_specificationsInput = {
    update: XOR<tube_materialsUpdateWithoutTube_specificationsInput, tube_materialsUncheckedUpdateWithoutTube_specificationsInput>
    create: XOR<tube_materialsCreateWithoutTube_specificationsInput, tube_materialsUncheckedCreateWithoutTube_specificationsInput>
    where?: tube_materialsWhereInput
  }

  export type tube_materialsUpdateToOneWithWhereWithoutTube_specificationsInput = {
    where?: tube_materialsWhereInput
    data: XOR<tube_materialsUpdateWithoutTube_specificationsInput, tube_materialsUncheckedUpdateWithoutTube_specificationsInput>
  }

  export type tube_materialsUpdateWithoutTube_specificationsInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_assembly?: tube_assemblyUpdateManyWithoutTube_materialsNestedInput
  }

  export type tube_materialsUncheckedUpdateWithoutTube_specificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_assembly?: tube_assemblyUncheckedUpdateManyWithoutTube_materialsNestedInput
  }

  export type tube_productsUpsertWithoutTube_specificationsInput = {
    update: XOR<tube_productsUpdateWithoutTube_specificationsInput, tube_productsUncheckedUpdateWithoutTube_specificationsInput>
    create: XOR<tube_productsCreateWithoutTube_specificationsInput, tube_productsUncheckedCreateWithoutTube_specificationsInput>
    where?: tube_productsWhereInput
  }

  export type tube_productsUpdateToOneWithWhereWithoutTube_specificationsInput = {
    where?: tube_productsWhereInput
    data: XOR<tube_productsUpdateWithoutTube_specificationsInput, tube_productsUncheckedUpdateWithoutTube_specificationsInput>
  }

  export type tube_productsUpdateWithoutTube_specificationsInput = {
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUpdateManyWithoutTube_productsNestedInput
  }

  export type tube_productsUncheckedUpdateWithoutTube_specificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    code_1C?: NullableStringFieldUpdateOperationsInput | string | null
    marking?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    tube_records?: tube_recordsUncheckedUpdateManyWithoutTube_productsNestedInput
  }

  export type rolesCreateWithoutUser_rolesInput = {
    value: string
    description: string
  }

  export type rolesUncheckedCreateWithoutUser_rolesInput = {
    id?: number
    value: string
    description: string
  }

  export type rolesCreateOrConnectWithoutUser_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
  }

  export type usersCreateWithoutUser_rolesInput = {
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesCreateNestedManyWithoutUsersInput
    tokens?: tokensCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_rolesInput = {
    id?: number
    name: string
    email: string
    password: string
    banned?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
    histories?: historiesUncheckedCreateNestedManyWithoutUsersInput
    tokens?: tokensUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_rolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
  }

  export type rolesUpsertWithoutUser_rolesInput = {
    update: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<rolesCreateWithoutUser_rolesInput, rolesUncheckedCreateWithoutUser_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUser_rolesInput, rolesUncheckedUpdateWithoutUser_rolesInput>
  }

  export type rolesUpdateWithoutUser_rolesInput = {
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateWithoutUser_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpsertWithoutUser_rolesInput = {
    update: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
    create: XOR<usersCreateWithoutUser_rolesInput, usersUncheckedCreateWithoutUser_rolesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUser_rolesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUser_rolesInput, usersUncheckedUpdateWithoutUser_rolesInput>
  }

  export type usersUpdateWithoutUser_rolesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUpdateManyWithoutUsersNestedInput
    tokens?: tokensUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_rolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    banned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUncheckedUpdateManyWithoutUsersNestedInput
    tokens?: tokensUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type historiesCreateWithoutUsersInput = {
    boil_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
    employees?: employeesCreateNestedOneWithoutHistoriesInput
    history_types?: history_typesCreateNestedOneWithoutHistoriesInput
    records?: recordsCreateNestedOneWithoutHistoriesInput
  }

  export type historiesUncheckedCreateWithoutUsersInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    historyTypeId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type historiesCreateOrConnectWithoutUsersInput = {
    where: historiesWhereUniqueInput
    create: XOR<historiesCreateWithoutUsersInput, historiesUncheckedCreateWithoutUsersInput>
  }

  export type historiesCreateManyUsersInputEnvelope = {
    data: historiesCreateManyUsersInput | historiesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type tokensCreateWithoutUsersInput = {
    token: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokensUncheckedCreateWithoutUsersInput = {
    id?: number
    token: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tokensCreateOrConnectWithoutUsersInput = {
    where: tokensWhereUniqueInput
    create: XOR<tokensCreateWithoutUsersInput, tokensUncheckedCreateWithoutUsersInput>
  }

  export type tokensCreateManyUsersInputEnvelope = {
    data: tokensCreateManyUsersInput | tokensCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type user_rolesCreateWithoutUsersInput = {
    roles: rolesCreateNestedOneWithoutUser_rolesInput
  }

  export type user_rolesUncheckedCreateWithoutUsersInput = {
    id?: number
    roleId: number
  }

  export type user_rolesCreateOrConnectWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesCreateManyUsersInputEnvelope = {
    data: user_rolesCreateManyUsersInput | user_rolesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type historiesUpsertWithWhereUniqueWithoutUsersInput = {
    where: historiesWhereUniqueInput
    update: XOR<historiesUpdateWithoutUsersInput, historiesUncheckedUpdateWithoutUsersInput>
    create: XOR<historiesCreateWithoutUsersInput, historiesUncheckedCreateWithoutUsersInput>
  }

  export type historiesUpdateWithWhereUniqueWithoutUsersInput = {
    where: historiesWhereUniqueInput
    data: XOR<historiesUpdateWithoutUsersInput, historiesUncheckedUpdateWithoutUsersInput>
  }

  export type historiesUpdateManyWithWhereWithoutUsersInput = {
    where: historiesScalarWhereInput
    data: XOR<historiesUpdateManyMutationInput, historiesUncheckedUpdateManyWithoutUsersInput>
  }

  export type tokensUpsertWithWhereUniqueWithoutUsersInput = {
    where: tokensWhereUniqueInput
    update: XOR<tokensUpdateWithoutUsersInput, tokensUncheckedUpdateWithoutUsersInput>
    create: XOR<tokensCreateWithoutUsersInput, tokensUncheckedCreateWithoutUsersInput>
  }

  export type tokensUpdateWithWhereUniqueWithoutUsersInput = {
    where: tokensWhereUniqueInput
    data: XOR<tokensUpdateWithoutUsersInput, tokensUncheckedUpdateWithoutUsersInput>
  }

  export type tokensUpdateManyWithWhereWithoutUsersInput = {
    where: tokensScalarWhereInput
    data: XOR<tokensUpdateManyMutationInput, tokensUncheckedUpdateManyWithoutUsersInput>
  }

  export type tokensScalarWhereInput = {
    AND?: tokensScalarWhereInput | tokensScalarWhereInput[]
    OR?: tokensScalarWhereInput[]
    NOT?: tokensScalarWhereInput | tokensScalarWhereInput[]
    id?: IntFilter<"tokens"> | number
    userId?: IntNullableFilter<"tokens"> | number | null
    token?: StringFilter<"tokens"> | string
    createdAt?: DateTimeFilter<"tokens"> | Date | string
    updatedAt?: DateTimeFilter<"tokens"> | Date | string
  }

  export type user_rolesUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    update: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_rolesCreateWithoutUsersInput, user_rolesUncheckedCreateWithoutUsersInput>
  }

  export type user_rolesUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_rolesWhereUniqueInput
    data: XOR<user_rolesUpdateWithoutUsersInput, user_rolesUncheckedUpdateWithoutUsersInput>
  }

  export type user_rolesUpdateManyWithWhereWithoutUsersInput = {
    where: user_rolesScalarWhereInput
    data: XOR<user_rolesUpdateManyMutationInput, user_rolesUncheckedUpdateManyWithoutUsersInput>
  }

  export type recordsCreateWithoutWorkshopsInput = {
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsCreateNestedManyWithoutRecordsInput
    apparatuses?: apparatusesCreateNestedOneWithoutRecordsInput
    cans?: cansCreateNestedOneWithoutRecordsInput
    conveyors?: conveyorsCreateNestedOneWithoutRecordsInput
    docs?: docsCreateNestedOneWithoutRecordsInput
    products?: productsCreateNestedOneWithoutRecordsInput
    boils?: boilsCreateNestedOneWithoutRecordsInput
    semi_products?: semi_productsCreateNestedManyWithoutRecordsInput
  }

  export type recordsUncheckedCreateWithoutWorkshopsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
    histories?: historiesUncheckedCreateNestedManyWithoutRecordsInput
    record_regulations?: record_regulationsUncheckedCreateNestedManyWithoutRecordsInput
    semi_products?: semi_productsUncheckedCreateNestedManyWithoutRecordsInput
  }

  export type recordsCreateOrConnectWithoutWorkshopsInput = {
    where: recordsWhereUniqueInput
    create: XOR<recordsCreateWithoutWorkshopsInput, recordsUncheckedCreateWithoutWorkshopsInput>
  }

  export type recordsCreateManyWorkshopsInputEnvelope = {
    data: recordsCreateManyWorkshopsInput | recordsCreateManyWorkshopsInput[]
    skipDuplicates?: boolean
  }

  export type recordsUpsertWithWhereUniqueWithoutWorkshopsInput = {
    where: recordsWhereUniqueInput
    update: XOR<recordsUpdateWithoutWorkshopsInput, recordsUncheckedUpdateWithoutWorkshopsInput>
    create: XOR<recordsCreateWithoutWorkshopsInput, recordsUncheckedCreateWithoutWorkshopsInput>
  }

  export type recordsUpdateWithWhereUniqueWithoutWorkshopsInput = {
    where: recordsWhereUniqueInput
    data: XOR<recordsUpdateWithoutWorkshopsInput, recordsUncheckedUpdateWithoutWorkshopsInput>
  }

  export type recordsUpdateManyWithWhereWithoutWorkshopsInput = {
    where: recordsScalarWhereInput
    data: XOR<recordsUpdateManyMutationInput, recordsUncheckedUpdateManyWithoutWorkshopsInput>
  }

  export type recordsCreateManyApparatusesInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type recordsUpdateWithoutApparatusesInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutApparatusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateManyWithoutApparatusesInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type boilsCreateManyBasesInput = {
    id?: number
    value: string
    letter?: string | null
    year?: Decimal | DecimalJsLike | number | string | null
    number?: Decimal | DecimalJsLike | number | string | null
    plant_id?: number | null
  }

  export type boilsUpdateWithoutBasesInput = {
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    semi_products?: semi_productsUpdateManyWithoutBoilsNestedInput
    tube_records?: tube_recordsUpdateManyWithoutBoilsNestedInput
    records?: recordsUpdateManyWithoutBoilsNestedInput
  }

  export type boilsUncheckedUpdateWithoutBasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    semi_products?: semi_productsUncheckedUpdateManyWithoutBoilsNestedInput
    tube_records?: tube_recordsUncheckedUpdateManyWithoutBoilsNestedInput
    records?: recordsUncheckedUpdateManyWithoutBoilsNestedInput
  }

  export type boilsUncheckedUpdateManyWithoutBasesInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: StringFieldUpdateOperationsInput | string
    letter?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    number?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type semi_productsCreateManyBoilsInput = {
    id?: number
    record_id?: number | null
    product_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsCreateManyBoilsInput = {
    id?: number
    tube_product_id?: number | null
    tube_conveyor_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type recordsCreateManyBoilsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type semi_productsUpdateWithoutBoilsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: productsUpdateOneWithoutSemi_productsNestedInput
    records?: recordsUpdateOneWithoutSemi_productsNestedInput
  }

  export type semi_productsUncheckedUpdateWithoutBoilsInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semi_productsUncheckedUpdateManyWithoutBoilsInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsUpdateWithoutBoilsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_conveyors?: tube_conveyorsUpdateOneWithoutTube_recordsNestedInput
    tube_products?: tube_productsUpdateOneWithoutTube_recordsNestedInput
  }

  export type tube_recordsUncheckedUpdateWithoutBoilsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsUncheckedUpdateManyWithoutBoilsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recordsUpdateWithoutBoilsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutBoilsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateManyWithoutBoilsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type recordsCreateManyCansInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type recordsUpdateWithoutCansInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutCansInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateManyWithoutCansInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type recordsCreateManyConveyorsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type recordsUpdateWithoutConveyorsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutConveyorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateManyWithoutConveyorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type recordsCreateManyDocsInput = {
    id?: number
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type recordsUpdateWithoutDocsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateManyWithoutDocsInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type historiesCreateManyEmployeesInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    historyTypeId?: number | null
    userId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type tube_historiesCreateManyEmployeesInput = {
    id?: number
    tube_record_id?: number | null
    tube_history_type_id?: number | null
    note?: string | null
    tube_history_note_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_sessionsCreateManyEmployeesInput = {
    id?: number
    conveyor_id?: number | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historiesUpdateWithoutEmployeesInput = {
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    history_types?: history_typesUpdateOneWithoutHistoriesNestedInput
    records?: recordsUpdateOneWithoutHistoriesNestedInput
    users?: usersUpdateOneWithoutHistoriesNestedInput
  }

  export type historiesUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historiesUncheckedUpdateManyWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tube_historiesUpdateWithoutEmployeesInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_histories_notes?: tube_histories_notesUpdateOneWithoutTube_historiesNestedInput
    tube_history_types?: tube_history_typesUpdateOneWithoutTube_historiesNestedInput
  }

  export type tube_historiesUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_history_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    tube_history_note_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_historiesUncheckedUpdateManyWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_history_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    tube_history_note_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_sessionsUpdateWithoutEmployeesInput = {
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_conveyors?: tube_conveyorsUpdateOneWithoutTube_sessionsNestedInput
  }

  export type tube_sessionsUncheckedUpdateWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_sessionsUncheckedUpdateManyWithoutEmployeesInput = {
    id?: IntFieldUpdateOperationsInput | number
    conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historiesCreateManyHistory_typesInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    userId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type historiesUpdateWithoutHistory_typesInput = {
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    employees?: employeesUpdateOneWithoutHistoriesNestedInput
    records?: recordsUpdateOneWithoutHistoriesNestedInput
    users?: usersUpdateOneWithoutHistoriesNestedInput
  }

  export type historiesUncheckedUpdateWithoutHistory_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historiesUncheckedUpdateManyWithoutHistory_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type record_regulationsCreateManyMarking_sampleInput = {
    id?: number
    record_id?: number | null
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type regulationsCreateManyMarking_sampleInput = {
    id?: number
    product_id?: number | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type record_regulationsUpdateWithoutMarking_sampleInput = {
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUpdateOneWithoutRecord_regulationsNestedInput
  }

  export type record_regulationsUncheckedUpdateWithoutMarking_sampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type record_regulationsUncheckedUpdateManyWithoutMarking_sampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type regulationsUpdateWithoutMarking_sampleInput = {
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: productsUpdateOneWithoutRegulationsNestedInput
  }

  export type regulationsUncheckedUpdateWithoutMarking_sampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type regulationsUncheckedUpdateManyWithoutMarking_sampleInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type employeesCreateManyOccupationsInput = {
    id?: number
    name: string
    barcode: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type employeesUpdateWithoutOccupationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUpdateManyWithoutEmployeesNestedInput
    tube_histories?: tube_historiesUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateWithoutOccupationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    histories?: historiesUncheckedUpdateManyWithoutEmployeesNestedInput
    tube_histories?: tube_historiesUncheckedUpdateManyWithoutEmployeesNestedInput
    tube_sessions?: tube_sessionsUncheckedUpdateManyWithoutEmployeesNestedInput
  }

  export type employeesUncheckedUpdateManyWithoutOccupationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    barcode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type docsCreateManyPlantsInput = {
    id?: number
    date: Date | string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type docsUpdateWithoutPlantsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUpdateManyWithoutDocsNestedInput
  }

  export type docsUncheckedUpdateWithoutPlantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUncheckedUpdateManyWithoutDocsNestedInput
  }

  export type docsUncheckedUpdateManyWithoutPlantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type recordsCreateManyProductsInput = {
    id?: number
    doc_id?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    workshopId?: number | null
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type regulationsCreateManyProductsInput = {
    id?: number
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type semi_productsCreateManyProductsInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type recordsUpdateWithoutProductsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    workshops?: workshopsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    workshopId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }

  export type regulationsUpdateWithoutProductsInput = {
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marking_sample?: marking_sampleUpdateOneWithoutRegulationsNestedInput
  }

  export type regulationsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type regulationsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semi_productsUpdateWithoutProductsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boils?: boilsUpdateOneWithoutSemi_productsNestedInput
    records?: recordsUpdateOneWithoutSemi_productsNestedInput
  }

  export type semi_productsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semi_productsUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historiesCreateManyRecordsInput = {
    id?: number
    boil_id?: number | null
    historyTypeId?: number | null
    userId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type record_regulationsCreateManyRecordsInput = {
    id?: number
    org_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: Decimal | DecimalJsLike | number | string | null
    per_box?: number | null
    box_per_row?: number | null
    row_on_pallet?: number | null
    gasket?: string | null
    seal?: boolean | null
    technician_note?: string | null
    packaging_note?: string | null
    marking_sample_id?: number | null
    inc_color?: string | null
    marking_feature?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type semi_productsCreateManyRecordsInput = {
    id?: number
    product_id?: number | null
    boil_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type historiesUpdateWithoutRecordsInput = {
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    employees?: employeesUpdateOneWithoutHistoriesNestedInput
    history_types?: history_typesUpdateOneWithoutHistoriesNestedInput
    users?: usersUpdateOneWithoutHistoriesNestedInput
  }

  export type historiesUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historiesUncheckedUpdateManyWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type record_regulationsUpdateWithoutRecordsInput = {
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    marking_sample?: marking_sampleUpdateOneWithoutRecord_regulationsNestedInput
  }

  export type record_regulationsUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type record_regulationsUncheckedUpdateManyWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    org_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    org_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_min_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    water_base_max_weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    per_box?: NullableIntFieldUpdateOperationsInput | number | null
    box_per_row?: NullableIntFieldUpdateOperationsInput | number | null
    row_on_pallet?: NullableIntFieldUpdateOperationsInput | number | null
    gasket?: NullableStringFieldUpdateOperationsInput | string | null
    seal?: NullableBoolFieldUpdateOperationsInput | boolean | null
    technician_note?: NullableStringFieldUpdateOperationsInput | string | null
    packaging_note?: NullableStringFieldUpdateOperationsInput | string | null
    marking_sample_id?: NullableIntFieldUpdateOperationsInput | number | null
    inc_color?: NullableStringFieldUpdateOperationsInput | string | null
    marking_feature?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semi_productsUpdateWithoutRecordsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boils?: boilsUpdateOneWithoutSemi_productsNestedInput
    products?: productsUpdateOneWithoutSemi_productsNestedInput
  }

  export type semi_productsUncheckedUpdateWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type semi_productsUncheckedUpdateManyWithoutRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    product_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesCreateManyRolesInput = {
    id?: number
    userId: number
  }

  export type user_rolesUpdateWithoutRolesInput = {
    users?: usersUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesUncheckedUpdateManyWithoutRolesInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
  }

  export type productsCreateManySeriesInput = {
    id?: number
    code1C: string
    marking: string
    name?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type productsUpdateWithoutSeriesInput = {
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUpdateManyWithoutProductsNestedInput
    regulations?: regulationsUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateWithoutSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    records?: recordsUncheckedUpdateManyWithoutProductsNestedInput
    regulations?: regulationsUncheckedUpdateManyWithoutProductsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutProductsNestedInput
  }

  export type productsUncheckedUpdateManyWithoutSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code1C?: StringFieldUpdateOperationsInput | string
    marking?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_assemblyCreateManyTube_conveyor_postsInput = {
    id?: number
    tube_record_id?: number | null
    tube_material_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_assemblyUpdateWithoutTube_conveyor_postsInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_materials?: tube_materialsUpdateOneWithoutTube_assemblyNestedInput
  }

  export type tube_assemblyUncheckedUpdateWithoutTube_conveyor_postsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_assemblyUncheckedUpdateManyWithoutTube_conveyor_postsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsCreateManyTube_conveyorsInput = {
    id?: number
    tube_product_id?: number | null
    boil_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_sessionsCreateManyTube_conveyorsInput = {
    id?: number
    employee_id?: number | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsUpdateWithoutTube_conveyorsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boils?: boilsUpdateOneWithoutTube_recordsNestedInput
    tube_products?: tube_productsUpdateOneWithoutTube_recordsNestedInput
  }

  export type tube_recordsUncheckedUpdateWithoutTube_conveyorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsUncheckedUpdateManyWithoutTube_conveyorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_sessionsUpdateWithoutTube_conveyorsInput = {
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: employeesUpdateOneWithoutTube_sessionsNestedInput
  }

  export type tube_sessionsUncheckedUpdateWithoutTube_conveyorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_sessionsUncheckedUpdateManyWithoutTube_conveyorsInput = {
    id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_historiesCreateManyTube_histories_notesInput = {
    id?: number
    tube_record_id?: number | null
    tube_history_type_id?: number | null
    employee_id?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_historiesUpdateWithoutTube_histories_notesInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: employeesUpdateOneWithoutTube_historiesNestedInput
    tube_history_types?: tube_history_typesUpdateOneWithoutTube_historiesNestedInput
  }

  export type tube_historiesUncheckedUpdateWithoutTube_histories_notesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_history_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_historiesUncheckedUpdateManyWithoutTube_histories_notesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_history_type_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_historiesCreateManyTube_history_typesInput = {
    id?: number
    tube_record_id?: number | null
    employee_id?: number | null
    note?: string | null
    tube_history_note_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_historiesUpdateWithoutTube_history_typesInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: employeesUpdateOneWithoutTube_historiesNestedInput
    tube_histories_notes?: tube_histories_notesUpdateOneWithoutTube_historiesNestedInput
  }

  export type tube_historiesUncheckedUpdateWithoutTube_history_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    tube_history_note_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_historiesUncheckedUpdateManyWithoutTube_history_typesInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    tube_history_note_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_assemblyCreateManyTube_materialsInput = {
    id?: number
    tube_record_id?: number | null
    tube_conveyor_post_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_specificationsCreateManyTube_materialsInput = {
    id?: number
    tube_product_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_assemblyUpdateWithoutTube_materialsInput = {
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_conveyor_posts?: tube_conveyor_postsUpdateOneWithoutTube_assemblyNestedInput
  }

  export type tube_assemblyUncheckedUpdateWithoutTube_materialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_assemblyUncheckedUpdateManyWithoutTube_materialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_record_id?: NullableIntFieldUpdateOperationsInput | number | null
    tube_conveyor_post_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_specificationsUpdateWithoutTube_materialsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_products?: tube_productsUpdateOneWithoutTube_specificationsNestedInput
  }

  export type tube_specificationsUncheckedUpdateWithoutTube_materialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_specificationsUncheckedUpdateManyWithoutTube_materialsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_product_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsCreateManyTube_productsInput = {
    id?: number
    tube_conveyor_id?: number | null
    boil_id?: number | null
    plan: number
    start_date?: Date | string | null
    active?: boolean | null
    finished?: boolean | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_specificationsCreateManyTube_productsInput = {
    id?: number
    tube_material_id?: number | null
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type tube_recordsUpdateWithoutTube_productsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    boils?: boilsUpdateOneWithoutTube_recordsNestedInput
    tube_conveyors?: tube_conveyorsUpdateOneWithoutTube_recordsNestedInput
  }

  export type tube_recordsUncheckedUpdateWithoutTube_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_recordsUncheckedUpdateManyWithoutTube_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_conveyor_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    active?: NullableBoolFieldUpdateOperationsInput | boolean | null
    finished?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_specificationsUpdateWithoutTube_productsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tube_materials?: tube_materialsUpdateOneWithoutTube_specificationsNestedInput
  }

  export type tube_specificationsUncheckedUpdateWithoutTube_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tube_specificationsUncheckedUpdateManyWithoutTube_productsInput = {
    id?: IntFieldUpdateOperationsInput | number
    tube_material_id?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type historiesCreateManyUsersInput = {
    id?: number
    record_id?: number | null
    boil_id?: number | null
    historyTypeId?: number | null
    employeeId?: number | null
    note?: string | null
    createdAt: Date | string
    updatedAt: Date | string
    note_id?: number | null
    plant_id?: number | null
  }

  export type tokensCreateManyUsersInput = {
    id?: number
    token: string
    createdAt: Date | string
    updatedAt: Date | string
  }

  export type user_rolesCreateManyUsersInput = {
    id?: number
    roleId: number
  }

  export type historiesUpdateWithoutUsersInput = {
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
    employees?: employeesUpdateOneWithoutHistoriesNestedInput
    history_types?: history_typesUpdateOneWithoutHistoriesNestedInput
    records?: recordsUpdateOneWithoutHistoriesNestedInput
  }

  export type historiesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type historiesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    record_id?: NullableIntFieldUpdateOperationsInput | number | null
    boil_id?: NullableIntFieldUpdateOperationsInput | number | null
    historyTypeId?: NullableIntFieldUpdateOperationsInput | number | null
    employeeId?: NullableIntFieldUpdateOperationsInput | number | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    note_id?: NullableIntFieldUpdateOperationsInput | number | null
    plant_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tokensUpdateWithoutUsersInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type tokensUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_rolesUpdateWithoutUsersInput = {
    roles?: rolesUpdateOneRequiredWithoutUser_rolesNestedInput
  }

  export type user_rolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type user_rolesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    roleId?: IntFieldUpdateOperationsInput | number
  }

  export type recordsCreateManyWorkshopsInput = {
    id?: number
    doc_id?: number | null
    productId?: number | null
    boilId?: number | null
    apparatusId?: number | null
    canId?: number | null
    conveyorId?: number | null
    plan: number
    bbf: string
    note: string
    createdAt: Date | string
    updatedAt: Date | string
    isSet?: boolean | null
    organic_base_id?: number | null
    water_base_id?: number | null
    dm?: string
  }

  export type recordsUpdateWithoutWorkshopsInput = {
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUpdateManyWithoutRecordsNestedInput
    apparatuses?: apparatusesUpdateOneWithoutRecordsNestedInput
    cans?: cansUpdateOneWithoutRecordsNestedInput
    conveyors?: conveyorsUpdateOneWithoutRecordsNestedInput
    docs?: docsUpdateOneWithoutRecordsNestedInput
    products?: productsUpdateOneWithoutRecordsNestedInput
    boils?: boilsUpdateOneWithoutRecordsNestedInput
    semi_products?: semi_productsUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateWithoutWorkshopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
    histories?: historiesUncheckedUpdateManyWithoutRecordsNestedInput
    record_regulations?: record_regulationsUncheckedUpdateManyWithoutRecordsNestedInput
    semi_products?: semi_productsUncheckedUpdateManyWithoutRecordsNestedInput
  }

  export type recordsUncheckedUpdateManyWithoutWorkshopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    doc_id?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
    boilId?: NullableIntFieldUpdateOperationsInput | number | null
    apparatusId?: NullableIntFieldUpdateOperationsInput | number | null
    canId?: NullableIntFieldUpdateOperationsInput | number | null
    conveyorId?: NullableIntFieldUpdateOperationsInput | number | null
    plan?: IntFieldUpdateOperationsInput | number
    bbf?: StringFieldUpdateOperationsInput | string
    note?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isSet?: NullableBoolFieldUpdateOperationsInput | boolean | null
    organic_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    water_base_id?: NullableIntFieldUpdateOperationsInput | number | null
    dm?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}